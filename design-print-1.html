<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>QR Print Station</title>

  <!-- pdfmake (and its fonts) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/pdfmake.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/vfs_fonts.js"></script>

  <!-- qrcode.js (for generating QR) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <style>
    html, body { margin:0; padding:0; }
  </style>
</head>
<body>
<script>
/********************************************************
 *  COMPAT MODE SWITCH
 *  ─────────────────────────────────────────────────────
 *  • NEW FLOW  : design-1.html stashes `metalOrderLists`
 *                { gold:[], silver:[], rose:[], "14k":[] }
 *  • LEGACY    : Sorting page stashes `qrPrintAll`
 *                { dispatchDate, items[], userTypedOrderNum }
 ********************************************************/
window.addEventListener("load", async () => {
  const metalJSON = localStorage.getItem("metalOrderLists");
  if (metalJSON) {
    await handleMetalBundles(JSON.parse(metalJSON));
    localStorage.removeItem("metalOrderLists");   // one-shot transfer
    return;
  }

  const legacyJSON = localStorage.getItem("qrPrintAll");
  if (legacyJSON) {
    await handleLegacy(JSON.parse(legacyJSON));
    return;
  }

  console.error("Nothing to print: no metalOrderLists or qrPrintAll found.");
});

// Allow the opener to push the lists directly via postMessage.
window.addEventListener("message", async (e) => {
  if (e?.data?.type === "qr-print-start" && e.data.lists) {
    try {
      await handleMetalBundles(e.data.lists);
    } catch (err) {
      console.error("qr-print-start failed:", err);
    }
  }
});

/* ──────────────────────────────────────────────────────────
 *  NEW FLOW  – single print job, one page per metal
 * ────────────────────────────────────────────────────────── */
async function handleMetalBundles(lists) {
  // 1) De-dupe *within* each metal only (do not cross-metal collapse)
  const byMetal = {};
  for (const m of Object.keys(lists || {})) {
    const arr = (lists[m] || []).map(String);
    byMetal[m] = [...new Set(arr)];
  }

  // 2) Build a single pdfMake document with pages in a stable metal order
  const order = ["gold", "silver", "rose", "14k"];  // matches your documented keys
  const content = [];

  for (const metal of order) {
    const arr = byMetal[metal] || [];
    if (!arr.length) continue;

    const imgData = await makeQRDataURL(arr.join(","));

    // Page nodes (size/positions match your existing per-metal page)
    content.push(
      { image: imgData, width:85, absolutePosition:{ x:3, y:3 } },
      { text : `${metal.toUpperCase()} (${arr.length})`,
        fontSize:9, bold:true,
        absolutePosition:{ x:1, y:93 } },
      { text: "Notes:",
        fontSize: 9, bold: true,
        absolutePosition: { x:92, y:0.5 },
        pageBreak: "after" }     // force next metal on a new page
    );
  }

  // 3) Remove trailing pageBreak on the last node (if any pages exist)
  if (content.length) {
    delete content[content.length - 1].pageBreak;
  }

  const unifiedDoc = {
    pageSize   : { width:145, height:145 },  // 1″ × 1″
    pageMargins: [0,0,0,0],
    content
  };

  // 4) One print dialog, all pages together
  await autoPrint(unifiedDoc);
}

/* ──────────────────────────────────────────────────────────
 *  LEGACY FLOW  – single order QR (unchanged)
 * ────────────────────────────────────────────────────────── */
async function handleLegacy(dataObj){
  if (!dataObj || !Array.isArray(dataObj.items) || !dataObj.items.length) {
    console.error("'qrPrintAll' payload malformed."); return;
  }
  const dispatchDate = dataObj.dispatchDate || "N/A";
  const orderNum     = dataObj.userTypedOrderNum
                    || dataObj.items[0].receipt_id
                    || "UnknownOrder";

  const imgData = await makeQRDataURL(orderNum);
  const docDef  = {
    pageSize   : { width:72, height:72 },          // 1″ × 1″
    pageMargins: [0,0,0,0],
    content : [
      { image: imgData, width:12, absolutePosition:{ x:27.5, y:2 } },
      { text : dispatchDate,
        fontSize:2, bold:true,
        absolutePosition:{ x:27.5, y:13.75 } }
    ]
  };
  await autoPrint(docDef);
}

/* ──────────────────────────────────────────────────────────
 *  HELPERS
 * ────────────────────────────────────────────────────────── */
async function makeQRDataURL(text){
  const holder = document.createElement("div");
  holder.style.display = "none";
  document.body.appendChild(holder);

  new QRCode(holder, {
    text, width:1024, height:1024, correctLevel:QRCode.CorrectLevel.H
  });
  await new Promise(r => setTimeout(r, 2000));      // allow render

  const img = holder.querySelector("img")
         || holder.querySelector("canvas")?.toDataURL("image/png");
  return img.tagName ? img.src : img;              // normalize
}

async function autoPrint(docDefinition){
  return new Promise(res => {
    pdfMake.createPdf(docDefinition).getBlob(blob => {
      const url = URL.createObjectURL(blob);
      const frame = document.createElement("iframe");
      frame.style.visibility = "hidden";
      frame.src = url;
      frame.onload = () => {
        const w = frame.contentWindow;
        const notifyDone = () => {
          try {
            // Tell opener (popup) or parent (iframe) that printing finished.
            (window.opener || parent).postMessage({ type: "qr-print-done", printSuccess: true }, "*");
          } catch (e) {}
          res();
        };
        // Prefer a real afterprint signal from the printing context.
        if (w) w.onafterprint = notifyDone;
        try { if (w) w.focus(); } catch (e) {}
        if (w) w.print();

        // Fallback in case onafterprint doesn't fire on some browsers.
        setTimeout(notifyDone, 2000);
      };
      document.body.appendChild(frame);
    });
  });
}
</script>
</body>
</html>