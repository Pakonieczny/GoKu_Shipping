<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>QR Print Station</title>

  <!-- pdfmake (and its fonts) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/pdfmake.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/vfs_fonts.js"></script>

  <!-- qrcode.js (for generating QR) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <style>
    html, body { margin:0; padding:0; }
      #printGrid{ display:flex; flex-wrap:wrap; gap:20px; }
      .qr-tile{ width:120px; text-align:center; }
      .qr-caption{ font-size:.8em; margin-top:4px; }
  </style>
</head>
<body>  
<script>
  
/********************************************************
 *  COMPAT MODE SWITCH
 *  ─────────────────────────────────────────────────────
 *  • PREFERRED : design-1.html stashes `metalOrderJobs`
 *                [{ metal, ids, partIndex, partTotal, total }]
 *  • NEW FLOW  : design-1.html stashes `metalOrderLists`
 *                { gold:[], silver:[], rose:[], "14k":[] }
 *  • LEGACY    : Sorting page stashes `qrPrintAll`
 *                { dispatchDate, items[], userTypedOrderNum }
 ********************************************************/
window.addEventListener("load", async () => { 
  // Preferred: jobs (support both sessionStorage and localStorage)
  const jobJSON =
    sessionStorage.getItem("metalOrderJobs") ||
    localStorage.getItem("metalOrderJobs");
  if (jobJSON) {
    await handleMetalJobs(JSON.parse(jobJSON));     // one page per split slice
    sessionStorage.removeItem("metalOrderJobs");
    localStorage.removeItem("metalOrderJobs");
    return;
  }

  // Fallback: metal bundles (auto-split into pages of 50)
  const metalJSON = localStorage.getItem("metalOrderLists");
  if (metalJSON) {
    await handleMetalBundles(JSON.parse(metalJSON));
    localStorage.removeItem("metalOrderLists");   // one-shot transfer
    return;
  }

  // Legacy single-order QR
  const legacyJSON = localStorage.getItem("qrPrintAll");
  if (legacyJSON) {
    await handleLegacy(JSON.parse(legacyJSON));
    return;
  }

  console.error("Nothing to print: no metalOrderJobs, metalOrderLists or qrPrintAll found.");
});

/* ──────────────────────────────────────────────────────────
 *  JOB FLOW – one PDF page per split slice (preferred)
 *  Expects: [{ metal, ids, partIndex, partTotal, total }]
 * ────────────────────────────────────────────────────────── */
async function handleMetalJobs(jobs){
  if (!Array.isArray(jobs) || !jobs.length) return;
  const pages = [];
  for (const job of jobs){
    if (!Array.isArray(job.ids) || !job.ids.length) continue;
    const payload = encodeOrderList(job.ids, job.metal);
    const imgData = await makeQRDataURL(payload, "M"); // ECC=M (fallback→L inside)
    const label = `${String(job.metal||"").toUpperCase()} (${job.ids.length} of ${job.total})` +
                  (job.partTotal > 1 ? ` [${job.partIndex}/${job.partTotal}]` : "");
    pages.push({
      stack: [
        { image: imgData, width:85, absolutePosition:{ x:3, y:3 } },
        { text : label, fontSize:9, bold:true, absolutePosition:{ x:1, y:93 } },
        { text : "Notes:", fontSize:9, bold:true, absolutePosition:{ x:92, y:0.5 } }
      ],
      pageBreak: 'after'
    });
  }
  if (!pages.length) return;
  pages[pages.length - 1].pageBreak = undefined;
  const docDef = { pageSize:{ width:145, height:145 }, pageMargins:[0,0,0,0], content: pages };
  await autoPrint(docDef);
}

/* ──────────────────────────────────────────────────────────
 *  NEW FLOW – metal bundles (auto-split into pages of 50)
 * ────────────────────────────────────────────────────────── */
async function handleMetalBundles(lists) {
  // 1) De-dupe across bundles
  const seen = new Set();
  for (const m of Object.keys(lists)) {
    lists[m] = (lists[m] || []).filter(id => {
      const k = String(id);
      if (seen.has(k)) return false;
      seen.add(k);
      return true;
    });
  }

  // 2) Build pages (SPLIT into chunks of 50 per metal)
  const pages = [];
  for (const [metal, arr] of Object.entries(lists)) {
    if (!arr || !arr.length) continue;
    const parts = [];
    for (let i = 0; i < arr.length; i += 50) parts.push(arr.slice(i, i + 50));
    const total = arr.length;

    for (let idx = 0; idx < parts.length; idx++){
      const slice   = parts[idx];
      const payload = encodeOrderList(slice, metal);
      const imgData = await makeQRDataURL(payload, "M"); // ECC=M (fallback→L inside)
      const label   = `${metal.toUpperCase()} (${slice.length} of ${total})`
                    + (parts.length > 1 ? ` [${idx+1}/${parts.length}]` : "");
      pages.push({
        stack: [
          { image: imgData, width:85, absolutePosition:{ x:3, y:3 } },
          { text : label, fontSize:9, bold:true, absolutePosition:{ x:1, y:93 } },
          { text : "Notes:", fontSize:9, bold:true, absolutePosition:{ x:92, y:0.5 } }
        ],
        pageBreak: 'after'
      });
    }
  }
  if (!pages.length) return;

  // 3) Single print with all pages
  pages[pages.length - 1].pageBreak = undefined;  // Drop the last pageBreak
  const docDef = {
    pageSize   : { width:145, height:145 },  // 1″ × 1″ for every page
    pageMargins: [0,0,0,0],
    content    : pages
  };
  await autoPrint(docDef);
}

/* ──────────────────────────────────────────────────────────
 *  LEGACY FLOW  – single order QR (unchanged)
 * ────────────────────────────────────────────────────────── */
async function handleLegacy(dataObj){
  if (!dataObj || !Array.isArray(dataObj.items) || !dataObj.items.length) {
    console.error("'qrPrintAll' payload malformed."); return;
  }
  const dispatchDate = dataObj.dispatchDate || "N/A";
  const orderNum     = dataObj.userTypedOrderNum
                    || dataObj.items[0].receipt_id
                    || "UnknownOrder";

  const imgData = await makeQRDataURL(orderNum, "M");
  const docDef  = {
    pageSize   : { width:72, height:72 },          // 1″ × 1″
    pageMargins: [0,0,0,0],
    content : [
      { image: imgData, width:12, absolutePosition:{ x:27.5, y:2 } },
      { text : dispatchDate,
        fontSize:2, bold:true,
        absolutePosition:{ x:27.5, y:13.75 } }
    ]
  };
  await autoPrint(docDef);
}

/* ──────────────────────────────────────────────────────────
 *  BASE-36 COMPACT ENCODING
 * ────────────────────────────────────────────────────────── */
function toB36(numStr) {
  const clean = String(numStr).trim();
  if (!/^\d+$/.test(clean)) return clean;   // fall back if non-numeric
  let n = BigInt(clean);
  if (n === 0n) return "0";
  const digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  let out = "";
  while (n > 0n) {
    const r = Number(n % 36n);
    out = digits[r] + out;
    n = n / 36n;
  }
  return out;
}

/**
 * Encode a list of decimal order IDs (strings or numbers) as:
 *   "B36|<metal>|id.id.id"
 * where ids are base-36 and joined by '.'
 */
function encodeOrderList(ids, metal) {
  const b36 = (ids || []).map(x => {
    const digits = String(x).replace(/\D/g, "");
    return digits ? toB36(digits) : String(x);
  });
  return `B36|${metal}|` + b36.join(".");
}

/* ──────────────────────────────────────────────────────────
 *  HELPERS
 * ────────────────────────────────────────────────────────── */
async function makeQRDataURL(text, ecc = "M"){
  const holder = document.createElement("div");
  holder.style.display = "none";
  document.body.appendChild(holder);

  const lvl = (QRCode && QRCode.CorrectLevel) || {};
  const pick = lvl[ecc] ?? lvl.M ?? 1;
  try{
    new QRCode(holder, { text, width:1024, height:1024, correctLevel: pick });
  }catch(e){
    // last-resort if library throws for very long text
    new QRCode(holder, { text, width:1024, height:1024, correctLevel: lvl.L ?? 0 });
  }
  await new Promise(r => setTimeout(r, 300));      // allow render

  const img = holder.querySelector("img")
         || holder.querySelector("canvas")?.toDataURL("image/png");
  return img && img.tagName ? img.src : img;       // normalize
}

async function autoPrint(docDefinition){
  return new Promise(res => {
    pdfMake.createPdf(docDefinition).getBlob(blob => {
      const url = URL.createObjectURL(blob);
      const frame = document.createElement("iframe");
      frame.style.visibility = "hidden";
      frame.src = url;
      frame.onload = () => { frame.contentWindow.print(); res(); };
      document.body.appendChild(frame);
    });
  });
}
</script>
</body>
</html>