<!-- brites-vfx.html — Sora-2 demo with reference-image drag/drop + image/video toggle -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sora-2 Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' data: blob:;
                 img-src 'self' data: blob: https:;
                 media-src 'self' blob: https:;
                 connect-src 'self' https:;
                 style-src 'self' 'unsafe-inline';
                 script-src 'self' 'unsafe-inline'">
  <style>
    html, body { margin:0; padding:24px; font-family: system-ui, sans-serif; background:#f7f7f7; color:#111; }
    h1 { margin:0 0 12px; }
    label { display:block; margin: 12px 0 4px; }
    button { padding: 10px 16px; border-radius: 8px; border: 1px solid #ccc; cursor: pointer; background:#fff; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .log { margin-top: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space: pre-wrap; background:#fff; border:1px solid #ddd; padding:10px; border-radius:8px; }
    video { width: 360px; max-width: 100%; margin-top: 16px; border-radius: 8px; background:#000; }
    img.thumb { width: 96px; height: 96px; object-fit: cover; border-radius: 8px; border:1px solid #ddd; background:#fff; }
    progress { width: 320px; height: 10px; }
    #error-overlay{position:fixed;inset:0;background:rgba(255,255,255,.96);color:#b00;z-index:99999;padding:20px;overflow:auto;display:none}
    #error-overlay h2{margin:0 0 8px}
    #error-overlay pre{white-space:pre-wrap}

    /* Drag & drop panel */
    .dropzone {
      border: 2px dashed #9aa7b2;
      border-radius: 10px;
      background: #fefefe;
      padding: 16px;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: #5a6772;
      transition: background .15s, border-color .15s;
      cursor: pointer;
    }
    .dropzone.dragover { background:#eef6ff; border-color:#4b9cff; color:#234; }
    .muted { color:#666; font-size: 12px; }
    #refThumbs { display:flex; gap:10px; margin-top:10px; align-items:center; flex-wrap:wrap; }
    #outImgs { display:flex; gap:12px; flex-wrap:wrap; margin-top: 12px; }
    .chip { padding:4px 8px; border:1px solid #ddd; border-radius: 999px; background:#fff; font-size:12px; }
  </style>
</head>
<body>
  <h1>Sora-2 Quick Test</h1>

  <label for="prompt">Prompt</label>
  <textarea id="prompt" rows="5" style="width:100%;">A wide shot of gentle ocean waves at sunset, slow dolly forward, soft golden light, subtle ambient surf.</textarea>

  <div class="row">
    <label for="mode">Mode
      <select id="mode">
        <option value="video" selected>Video (Sora)</option>
        <option value="image">Image (gpt-image-1)</option>
      </select>
    </label>

    <label for="model">Model / Quality
      <select id="model">
        <option value="sora-2" selected>sora-2 (Standard)</option>
        <option value="sora-2-pro">sora-2-pro (Pro)</option>
      </select>
    </label>

    <label for="size">Size
      <select id="size">
        <!-- options are dynamically managed based on model -->
        <option value="720x1280">720x1280 (vertical)</option>
        <option value="1280x720">1280x720 (landscape)</option>
      </select>
    </label>

    <label for="seconds" id="secondsLabel">Seconds
      <select id="seconds">
        <option value="4" selected>4</option>
        <option value="8">8</option>
        <option value="12">12</option>
      </select>
    </label>

    <span class="chip" id="capsNote" aria-live="polite" title="Constraints from Sora docs">Sora: 1 ref image • seconds must be “4/8/12”</span>
  </div>

  <!-- Reference image uploader (drag & drop, jpg/png only) -->
  <label>Reference image (optional)</label>
  <div id="dropZone" class="dropzone" role="button" tabindex="0" aria-label="Drop a JPG/PNG here or click to choose">
    Drop one JPG/PNG here (or click)
  </div>
  <input id="refInput" type="file" accept=".jpg,.jpeg,.png,image/jpeg,image/png" hidden />
  <div id="refThumbs" aria-live="polite"></div>
  <div class="muted">Tip: Sora uses the reference as the first frame; match your chosen size/aspect. (We restrict to JPG/PNG here.)</div>

  <div class="row" style="margin-top:12px;">
    <button id="goBtn" type="button">Generate</button>
    <progress id="prog" max="100" value="2" hidden></progress>
    <span id="status" aria-live="polite"></span>
  </div>

  <pre class="log" id="log" aria-live="polite"></pre>
  <video id="outVid" controls hidden></video>
  <div id="outImgs" hidden></div>

  <div id="error-overlay">
    <h2>Runtime Error</h2>
    <pre id="err-pre"></pre>
  </div>

  <script>
    (function () {
      const $ = (id) => document.getElementById(id);
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      // ---- New constants for reference images ----
      // Sora 2 docs describe a single input_reference image; enforce 1 on the UI.
      const MAX_INPUT_IMAGES = 1;
      const ACCEPTED_MIME = new Set(['image/jpeg','image/png']);
      const ACCEPTED_EXT = /\.(jpg|jpeg|png)$/i;
      const REF_FIT_MODE = 'contain';

      // PATCH A1 — keep request bodies small by downscaling the reference image client-side
      async function downscaleDataUrl(srcDataUrl, maxW = 1280, maxH = 1280, mime = 'image/jpeg', quality = 0.85) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            let w = img.naturalWidth, h = img.naturalHeight;
            const scale = Math.min(1, maxW / w, maxH / h);
            if (scale < 1) { w = Math.round(w * scale); h = Math.round(h * scale); }
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            const g = c.getContext('2d');
            g.drawImage(img, 0, 0, w, h);
            try { resolve(c.toDataURL(mime, quality)); } catch { resolve(srcDataUrl); }
          };
          img.onerror = () => resolve(srcDataUrl);
          img.src = srcDataUrl;
        });
      }

      // --- parse "WxH" like "720x1280" ---
      function parseSizeWH(s) {
        const m = /^(\d+)x(\d+)$/.exec(String(s||'').trim());
        return m ? { W: parseInt(m[1],10), H: parseInt(m[2],10) } : { W: 0, H: 0 };
      }

      // --- ensure reference EXACTLY matches requested size (letterbox by default) ---
      async function ensureRefExactSize(dataUrl, sizeStr, mode = REF_FIT_MODE, bg = '#000') {
        const { W, H } = parseSizeWH(sizeStr);
        if (!W || !H || !dataUrl) return dataUrl;

        const img = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = reject;
          im.src = dataUrl;
        });

        if (img.naturalWidth === W && img.naturalHeight === H) return dataUrl;

        const c = document.createElement('canvas');
        c.width = W; c.height = H;
        const g = c.getContext('2d');

        // Fill background; solid black avoids odd edges in the first video frame.
        g.fillStyle = bg; g.fillRect(0, 0, W, H);

        const sx = W / img.naturalWidth;
        const sy = H / img.naturalHeight;
        const s = (mode === 'cover') ? Math.max(sx, sy) : Math.min(sx, sy); // cover=crop, contain=letterbox

        const drawW = Math.round(img.naturalWidth * s);
        const drawH = Math.round(img.naturalHeight * s);
        const dx = Math.round((W - drawW) / 2);
        const dy = Math.round((H - drawH) / 2);

        g.imageSmoothingQuality = 'high';
        g.drawImage(img, dx, dy, drawW, drawH);

        // Force PNG; backend will send as multipart with image/png content-type
        return c.toDataURL('image/png');
      }

      // in-memory reference image (at most one)
      let refImage = null; // { name, type, dataUrl, width, height }

      function log(x){
        const el = $('log');
        el.textContent = (el.textContent ? el.textContent + '\n' : '') + x;
      }

      function showError(e) {
        try {
          const p = $('err-pre');
          $('error-overlay').style.display = 'block';
          p.textContent = (typeof e === 'string') ? e : (e?.stack || e?.message || JSON.stringify(e, null, 2));
        } catch {}
      }
      window.addEventListener('error', (ev) => showError(ev.error || ev.message || ev));
      window.addEventListener('unhandledrejection', (ev) => showError(ev.reason || ev));

      function safeJSON(text) { try { return JSON.parse(text); } catch { return { raw: text }; } }
      async function readJSON(resp) { const txt = await resp.text(); return safeJSON(txt); }

      // Deep, cautious search for a video URL
      function deepScanForVideoUrl(obj) {
        function isHttpish(s) {
          return typeof s === 'string' && /^https?:\/\//.test(s);
        }
        function looksLikeVideoUrl(s) {
          return isHttpish(s) && /\.(mp4|webm|mov)(\?|#|$)/i.test(s);
        }
        function isVideoishMeta(o) {
          const meta = `${o?.mime||''} ${o?.type||''} ${o?.kind||''} ${o?.role||''} ${o?.content_type||''}`;
          return /(video|mp4|webm|quicktime)/i.test(meta);
        }
        function pickFromRecord(o) {
          const cand = [
            o?.video_url, o?.download_url, o?.cdn_url, o?.signed_url,
            o?.url, o?.uri, o?.href, o?.file_url, o?.source, o?.src
          ];
          for (const c of cand) {
            if (typeof c === 'string' && (looksLikeVideoUrl(c) || isVideoishMeta(o))) return c;
          }
          if (typeof o?.video === 'string' && isHttpish(o.video)) return o.video;
          if (o?.video && isHttpish(o.video.url)) return o.video.url;
          if (o?.media && isHttpish(o.media.url)) return o.media.url;
          return null;
        }
        const seen = new Set();
        const stack = [obj];
        while (stack.length) {
          const cur = stack.pop();
          if (!cur || typeof cur !== 'object' || seen.has(cur)) continue;
          seen.add(cur);
          const direct = pickFromRecord(cur);
          if (direct) return direct;
          for (const k in cur) {
            const v = cur[k];
            if (!v) continue;
            if (Array.isArray(v)) {
              for (const it of v) {
                const got = pickFromRecord(it);
                if (got) return got;
                if (it && typeof it === 'object') stack.push(it);
                else if (typeof it === 'string' && looksLikeVideoUrl(it)) return it;
              }
            } else if (typeof v === 'object') {
              stack.push(v);
            } else if (typeof v === 'string' && looksLikeVideoUrl(v)) {
              return v;
            }
          }
        }
        return null;
      }

      function pickVideoUrl(job) {
        try {
          if (job.video_url) return job.video_url;

          const arrays = [
            job.assets, job.files, job.results, job.output, job.outputs,
            job.result?.files, job.result?.assets, job.result?.outputs,
            job.output?.files, job.output?.assets, job.output?.outputs,
            job.render?.outputs, job.media?.sources
          ].filter(Array.isArray);
          for (const arr of arrays) {
            const hit = arr.find(a => {
              const meta = `${a?.mime||''} ${a?.type||''} ${a?.kind||''} ${a?.role||''} ${a?.content_type||''}`;
              return /(video|mp4|webm|quicktime)/i.test(meta);
            }) || arr.find(a => {
              const s = a?.url || a?.uri || a?.href || a?.download_url || a?.signed_url || a?.cdn_url || a?.file_url;
              return typeof s === 'string' && /\.(mp4|webm|mov)(\?|#|$)/i.test(s);
            });
            if (hit) {
              return hit.url || hit.uri || hit.href || hit.download_url || hit.signed_url || hit.cdn_url || hit.file_url || null;
            }
          }

          if (job.output?.video?.url) return job.output.video.url;
          if (job.result?.video?.url) return job.result.video.url;

          const deep = deepScanForVideoUrl(job);
          if (deep) return deep;
        } catch {}
        return null;
      }

      async function pingFunctions() {
        try {
          const s = await fetch('/.netlify/functions/soraStatus?id=ping', { method: 'GET' });
          log(`soraStatus ping → ${s.status}`);
        } catch (e) { log('soraStatus ping failed: ' + (e?.message || e)); }

        try {
          const c = await fetch('/.netlify/functions/soraCreate', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ prompt:'__ping__' })
          });
          const preview = (await c.text()).slice(0, 200);
          log(`soraCreate ping → ${c.status} ${preview}...`);
        } catch (e) { log('soraCreate ping failed: ' + (e?.message || e)); }
      }

      // Dynamically adjust supported sizes by model (per Sora docs)
      function refreshSizeOptions() {
        const model = $('model').value;
        const sizeSel = $('size');
        const prev = sizeSel.value;
        sizeSel.innerHTML = '';

        // sora-2 supports 1280x720 and 720x1280; sora-2-pro also supports 1024x1792 and 1792x1024
        const sizes = (model === 'sora-2-pro')
          ? ['720x1280','1280x720','1024x1792','1792x1024']
          : ['720x1280','1280x720'];

        for (const s of sizes) {
          const opt = document.createElement('option');
          opt.value = s;
          opt.textContent = s + (s === '720x1280' ? ' (vertical)'
                               : s === '1280x720' ? ' (landscape)'
                               : (s === '1024x1792' || s === '1792x1024') ? ' (tall/pro)' : '');
          sizeSel.appendChild(opt);
        }
        if (sizes.includes(prev)) sizeSel.value = prev;
      }

      // ---- Reference image handling ----
      function clearRef() {
        refImage = null;
        $('refThumbs').innerHTML = '';
      }

      async function fileToDataUrl(file) {
        return new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onerror = () => reject(fr.error);
          fr.onload = () => resolve(fr.result);
          fr.readAsDataURL(file);
        });
      }

      async function acceptFiles(list) {
        const arr = Array.from(list || []);
        // filter by extension & mime
        const valid = arr.filter(f => ACCEPTED_MIME.has(f.type) || ACCEPTED_EXT.test(f.name || ''));
        if (!valid.length) {
          log('No valid JPG/PNG files detected.');
          return;
        }
        if (valid.length > MAX_INPUT_IMAGES) {
          log(`Only ${MAX_INPUT_IMAGES} reference image supported by Sora; extra files ignored.`);
        }
        const file = valid[0]; // enforce 1
        // Read original, then downscale to keep payload well under common function limits
        const dataUrlOrig = await fileToDataUrl(file);
        const dataUrl = await downscaleDataUrl(dataUrlOrig, 1280, 1280, 'image/jpeg', 0.85);

        // Probe intrinsic size
        const img = new Image();
        const dims = await new Promise((res) => {
          img.onload = () => res({ w: img.naturalWidth, h: img.naturalHeight });
          img.onerror = () => res({ w: 0, h: 0 });
          img.src = dataUrl;
        });

        refImage = { name: file.name, type: file.type, dataUrl, width: dims.w, height: dims.h };
        renderThumbs();
      }

      function renderThumbs() {
        const box = $('refThumbs');
        box.innerHTML = '';
        if (!refImage) return;
        const img = document.createElement('img');
        img.src = refImage.dataUrl;
        img.className = 'thumb';
        img.alt = 'reference';
        const rm = document.createElement('button');
        rm.textContent = 'Remove';
        rm.type = 'button';
        rm.onclick = clearRef;
        box.appendChild(img);
        box.appendChild(rm);
      }

      function wireDropzone() {
        const dz = $('dropZone');
        const fi = $('refInput');

        dz.addEventListener('click', () => fi.click());
        dz.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fi.click(); }
        });
        fi.addEventListener('change', (e) => acceptFiles(e.target.files));

        const prevent = (e) => { e.preventDefault(); e.stopPropagation(); };
        ['dragenter','dragover','dragleave','drop'].forEach(ev => dz.addEventListener(ev, prevent));
        dz.addEventListener('dragover', () => dz.classList.add('dragover'));
        dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
        dz.addEventListener('drop', async (e) => {
          dz.classList.remove('dragover');
          await acceptFiles(e.dataTransfer.files);
        });
      }

      // ---- API calls ----
      // NOTE: seconds is a STRING per API requirements
      async function createJob() {
        const prompt = $('prompt').value.trim();
        const model = $('model').value;
        const size = $('size').value;
        const seconds = $('seconds').value; // string "4" | "8" | "12"
        const mode = $('mode').value;       // "video" | "image"

        // Prepare optional reference payload — MUST match selected size to avoid:
        // "Inpaint image must match the requested width and height"
        let input_reference = null;
        if (refImage) {
          const exactDataUrl = await ensureRefExactSize(refImage.dataUrl, size, REF_FIT_MODE);
          input_reference = {
            filename: 'reference.png',
            content_type: 'image/png',
            data_url: exactDataUrl
          };
        }

        const body = { prompt, model, size, seconds, mode, input_reference };

        const resp = await fetch('/.netlify/functions/soraCreate', {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(body)
        });
        const nfId =
          resp.headers.get('x-nf-request-id') ||
          resp.headers.get('x-request-id') ||
          resp.headers.get('x-amzn-requestid') ||
          null;
        const txt = await resp.text();
        const parsed = safeJSON(txt);
        if (!resp.ok) {
          parsed.http = { status: resp.status, statusText: resp.statusText, requestId: nfId };
          throw new Error(JSON.stringify(parsed));
        }
        return parsed;
      }

      async function getStatus(id) {
        const resp = await fetch('/.netlify/functions/soraStatus?id=' + encodeURIComponent(id));
        const data = await readJSON(resp);
        if (!resp.ok) throw new Error(JSON.stringify(data));
        return data;
      }

      function setModeUI() {
        const mode = $('mode').value;
        const isVideo = (mode === 'video');
        $('secondsLabel').style.display = isVideo ? '' : 'none';
        $('outVid').hidden = true;
        $('outImgs').hidden = true;
      }

      document.addEventListener('DOMContentLoaded', async () => {
        document.documentElement.style.visibility = 'visible';
        document.body.style.visibility = 'visible';

        log('Booting… If this stalls here, check the red error overlay or the function pings below.');
        await pingFunctions();

        // wire UI
        wireDropzone();
        refreshSizeOptions();
        $('model').addEventListener('change', refreshSizeOptions);
        $('mode').addEventListener('change', setModeUI);
        setModeUI();

        $('goBtn').onclick = async () => {
          $('goBtn').disabled = true;
          $('outVid').hidden = true;
          $('outImgs').hidden = true;
          $('prog').hidden = false;
          $('prog').value = 3;
          $('status').textContent = 'starting…';
          $('log').textContent = '';

          try {
            const isVideo = ($('mode').value === 'video');
            const job = await createJob();
            log('created: ' + (job.id || '(no id)'));
            $('status').textContent = 'queued';
            let pct = 5;

            // If the backend returns immediate image URLs for mode=image, render and return.
            if (!isVideo && (Array.isArray(job.images) || job.image_url)) {
              const urls = job.images || [job.image_url];
              const wrap = $('outImgs');
              wrap.innerHTML = '';
              for (const u of urls) {
                const im = document.createElement('img');
                im.src = u;
                im.className = 'thumb';
                im.alt = 'generated';
                wrap.appendChild(im);
              }
              $('outImgs').hidden = false;
              $('status').textContent = 'done';
              $('prog').hidden = true;
              return;
            }

            // Otherwise, poll (video jobs and image jobs that return a job id)
            while (true) {
              await sleep(3000);
              const s = await getStatus(job.id);
              log(JSON.stringify({ id: s.id, status: s.status }, null, 2));
              $('status').textContent = s.status || 'processing';
              $('prog').value = Math.min(95, pct += 7);

              const st = (s.status || '').toLowerCase();
              if (st === 'completed' || st === 'succeeded') {
                $('prog').value = 100;

                if ($('mode').value === 'image') {
                  // Expect images array or a proxied content stream
                  const wrap = $('outImgs');
                  wrap.innerHTML = '';
                  if (Array.isArray(s.images)) {
                    for (const u of s.images) {
                      const im = document.createElement('img');
                      im.src = u;
                      im.className = 'thumb';
                      im.alt = 'generated';
                      wrap.appendChild(im);
                    }
                    $('outImgs').hidden = false;
                  } else {
                    // Fallback to content proxy if backend supports it
                    const proxy = '/.netlify/functions/soraStatus?id=' + encodeURIComponent(s.id) + '&content=image';
                    const im = document.createElement('img');
                    im.src = proxy;
                    im.className = 'thumb';
                    im.alt = 'generated';
                    wrap.appendChild(im);
                    $('outImgs').hidden = false;
                  }
                  $('status').textContent = 'done';
                  break;
                }

                // video mode
                const url = pickVideoUrl(s);
                if (!url) {
                  log('No direct URL in JSON — falling back to /content proxy…');
                  const proxy = '/.netlify/functions/soraStatus?id=' + encodeURIComponent(s.id) + '&content=video';
                  $('outVid').src = proxy;
                  $('outVid').hidden = false;
                  $('status').textContent = 'done';
                  break;
                }
                $('outVid').src = url;
                $('outVid').hidden = false;
                $('status').textContent = 'done';
                break;
              }
              if (st === 'failed' || st === 'error') {
                throw new Error('Generation failed: ' + (s.error?.message || s.status || 'unknown error'));
              }
            }
          } catch (e) {
            log('ERROR: ' + (e?.message || e));
            $('status').textContent = 'error';
            showError(e);
          } finally {
            $('prog').hidden = true;
            $('goBtn').disabled = false;
          }
        };
      });
    })();
  </script>
</body>
</html>