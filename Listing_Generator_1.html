<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    .slotPrev{ width:100%; height:190px; border-radius:12px; border:1px solid var(--line); background:#0b0d12; overflow:hidden; }
    .slotPrev img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- LEFT -->
    <div class="card">
      <h1>Listing-Generator-1</h1>
      
        <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>


      <label>Category (Storage source of truth)</label>
      <select id="activeCategory"></select>
      <div class="muted" style="margin-top:6px;">
        Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
        Generation is disabled for <code>New_Charms</code> + <code>Completed_Charm</code>.
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="generateSet">Generate Set</button>
      </div>

      <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
      <div id="panels"></div>

      <label style="margin-top:12px;">Shared Pool: New_Charms (always used in generation)</label>
      <div id="panelNewCharms"></div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <!-- Firebase (same style as shipping-1 uses: compat init + modular storage/auth) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, listAll, getMetadata } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";


    // --- Netlify functions base ---
    const functionsBaseUrl = `${window.location.origin}/.netlify/functions`;

    // -------------------------
    // Per-slot folder layout (Firebase Storage)
    // -------------------------
    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "New_Charms",
      "Completed_Charm",
    ];

    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Hoop_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots",
        "Hoop_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      New_Charms: [],
      Completed_Charm: [],
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Hoop_Size_Guide" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
    };

    // --- Firebase config (matches shipping-1 patterns) ---
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    // ✅ IMPORTANT: use COMPAT auth so COMPAT firestore (window.db) has permissions
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth ✔", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth ❌", e);
    }

    window.db = firebase.firestore();

    // Firestore transport hardening
    // Fixes: "Deadline expired before operation could complete."
    // Must be called BEFORE any reads/writes/onSnapshot listeners.
    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    // modular twin (same approach as shipping-1 resumable uploader)
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    // Gate specifically for Storage (modular) so request.auth is never null in Storage rules
    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 420000);  // 7 min
      const intervalMs = Number(opts.intervalMs ?? 1500);   // 1.5s
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);

      const t0 = Date.now();
      while (true) {
        await ensureStorageSignedIn();

        // ✅ Only LIST-first polling.
        // This guarantees the browser never issues a GET for Slot_*.png before it exists,
        // so you won't see any 404s in DevTools.
        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            // If this call is part of a Redo, the slot file likely already exists.
            // Only return once we detect the file has been overwritten (metadata changed).
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  // Found the file, but it's still the old version — keep waiting.
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (String(e2?.message || e2).includes("slot_not_updated_yet")) {
                  // keep waiting
                } else {
                  // transient metadata issue — keep waiting
                }
                throw e2;
              }
            }

            const url = await getDownloadURL(hit);
            return { storagePath: hit.fullPath, url };
          }
        } catch (e) {
          // If LIST is blocked by Storage rules, we cannot poll without causing 404s.
          // Fail loudly with a targeted message instead of hammering getDownloadURL().
          const msg = String(e?.message || e);
          const looksUnauthorized =
            msg.includes("storage/unauthorized") ||
            msg.includes("403") ||
            msg.toLowerCase().includes("permission");
          if (looksUnauthorized) {
            throw new Error(
              `Storage rules block LIST on: ${outputBasePath}\n` +
              `Allow LIST for Ready_To_List (or at least ${outputBasePath}) so the UI can detect Slot PNGs without any 404 polling.`
            );
          }
          // transient listing issue: keep waiting
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs);
      }
    }

    // --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    // Category-only UI (no legacy slot editor / per-slot uploads)


    function setStatus(msg){ statusEl.textContent = msg; }

    // Busy-state helper (Generate button + basic UI lock)
    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
    }

   // Current generated set context (used by per-slot Redo)
    let CURRENT_SET = null; // { category, outputBasePath, setN }

    function setAllRedoEnabled(enabled){
      gridEl.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet. Generate a set first.");
      }

      const category = CURRENT_SET.category;
      const outputBasePath = CURRENT_SET.outputBasePath;
      const slotPlan = SLOT_MAP[category];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex} for ${category}`);

     // Capture the CURRENT slot PNG metadata so we can wait for a real overwrite.
      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${outputBasePath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {
        // Slot may not exist yet (first run) — that's fine.
      }

      const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
      const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
      const metaEl   = slotCard?.querySelector(`#slotMeta_${slotIndex}`);
      const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);

      const setImg = (url) => {
        if (!prevBox) return;
        prevBox.innerHTML = `<img src="${cacheBust(url)}" />`;
      };

      // UI lock for this slot only
      if (redoBtn) redoBtn.disabled = true;
      if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Working…</div>`;
      setStatus(`Redo Slot ${slotIndex + 1}…`);

      // Always re-pull latest inputs at the time of redo
      const srcFolder = slotRefFolder(category, spec.folder);
      const srcLatest = await listLatestFile(srcFolder);
      if (!srcLatest) throw new Error(`No files in ${srcFolder}/`);

      const charmLatest = await listLatestFile(newCharmsPath());
      if (!charmLatest) throw new Error("No files in listing-generator-1/New_Charms/");

      if (spec.type === "copy") {
        const r = await postJson(GEMINI_FN, {
          kind: "copy_to_slot",
          activeCategory: category,
          source_storage_path: srcLatest.fullPath,
          output_base_path: outputBasePath,
          slotIndex,
        });

        // Even if the server returns a URL, it may still be the old object if overwrite hasn't landed yet.
        // Wait until Storage metadata shows the Slot PNG was actually replaced.
        const waited = await waitForSlotPngUrl(outputBasePath, slotIndex, {
          afterUpdatedMs: beforeUpdatedMs,
          afterGeneration: beforeGeneration,
        });
        setImg(waited.url);
      } else {
        await postJson(GEMINI_BG_FN, {
          kind: "edits",
          activeCategory: category,
          input_storage_path: srcLatest.fullPath,
          input_charm_storage_path: charmLatest.fullPath,
          output_base_path: outputBasePath,
          slotIndex,
          model: "gemini-3-pro-image-preview",
          prompt: buildSlotPrompt(category, spec.folder, slotIndex + 1),
        });

          const waited = await waitForSlotPngUrl(outputBasePath, slotIndex, {
          afterUpdatedMs: beforeUpdatedMs,
          afterGeneration: beforeGeneration,
        });
        setImg(waited.url);
      }

      if (metaEl) metaEl.textContent = `Source: ${srcLatest.fullPath}`;
      setStatus(`Ready (Set_${CURRENT_SET.setN ?? "?"})`);
      if (redoBtn) redoBtn.disabled = false;
    }

    // Back-compat alias (some blocks reference categoryEl)
    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/New_Charms`;
    }

    async function listLatestFile(fullFolderPath) {
      // Deterministic:
      // 1) prefer most recently uploaded (metadata.updated/timeCreated)
      // 2) tie-break lexicographically by name
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      // Only fetch download URL for the chosen file (faster)
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loading…</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          const msg = String(e?.message || e);
          const looksUnauthorized =
            msg.includes("storage/unauthorized") ||
            msg.includes("403") ||
            msg.toLowerCase().includes("permission");
          if (looksUnauthorized) {
            countEl.textContent = `No permission to list: ${targetFullPath} (update Firebase Storage rules to allow LIST)`;
          } else {
            countEl.textContent = `Error: ${msg}`;
          }
          console.warn("[Storage:listAll] failed", { targetFullPath, msg, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading → ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms"));

      // Slot visibility hint in UI (Stud_Earrings = 7 slots)
      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    // Populate dropdown
    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);
    activeCategoryEl.addEventListener("change", () => renderCategoryUI(activeCategoryEl.value));
    
    async function postJson(path, body) {
      const res = await fetch(`${functionsBaseUrl}/${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      // IMPORTANT: do NOT silently turn non-JSON into {}
      const raw = await res.text().catch(() => "");
      let j = null;
      try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

      if (!res.ok) {
        const msg =
          (j?.error?.message || j?.error) ||
          (raw ? raw.slice(0, 300) : "") ||
          `HTTP ${res.status}`;
        throw new Error(msg);
      }

      // Netlify background functions often return 202 with an empty body.
      if (!j) {
        if (res.status === 202 && (!raw || !raw.trim())) {
          return { ok: true, accepted: true, status: 202 };
        }
        throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
      }
      return j;
    }

    // Use the NON-background endpoint so we always get JSON back.
    const GEMINI_FN = "geminiImageProxy";
    const GEMINI_BG_FN = "geminiImageProxy-background";

    async function allocSet(category) {
      return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
    }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      // Some backends return a string directly, others nest under data/result/payload.
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        // top-level
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        // common nesting
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

      setStatus("Allocating Set…");
      const alloc = await allocSet(category);
      console.log("alloc_set response:", alloc);
      const outputBasePath = normalizeAllocOutputBasePath(alloc);
      if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

      // Prefer server-provided setN, but fall back to parsing from outputBasePath
      let setN = alloc?.setN ?? alloc?.set_n;
      if (setN == null) {
        const m = outputBasePath.match(/\/Set_(\d+)\b/);
        if (m) setN = Number(m[1]);
      }

      // Save current set context for per-slot Redo
      CURRENT_SET = { category, outputBasePath, setN };

      const charmLatest = await listLatestFile(newCharmsPath());
      if (!charmLatest) throw new Error("No files in listing-generator-1/New_Charms/");

      const manifest = {
        category,
        setN,
        outputBasePath,
        timestamp: new Date().toISOString(),
        slots: [],
        model: "gemini-3-pro-image-preview",
      };

      // Clear grid
      gridEl.innerHTML = "";

     // Redo buttons should be disabled while a full set is generating
     // (they will be enabled when the set is complete)

      // 1) Resolve all slot sources up front (Storage-only; no Gemini calls here)
      setStatus("Preparing slots…");
      const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
        const srcFolder = slotRefFolder(category, spec.folder);
        const srcLatest = await listLatestFile(srcFolder);
        if (!srcLatest) throw new Error(`No files in ${srcFolder}/`);
        return { spec, i, slotNum: i + 1, srcLatest };
      }));

      // 2) Render all slot cards immediately
      for (const r of slotResolved) {
        const { spec, i, slotNum, srcLatest } = r;
        const slotCard = document.createElement("div");
        slotCard.className = "slot";
        slotCard.innerHTML = `
          <div class="slotTop">
            <b>Slot ${slotNum}</b>
            <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
          </div>
          <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Queued…</div></div>
          <div class="small" id="slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
        `;
        gridEl.appendChild(slotCard);
      }

      // 3) Kick off ONE background run that processes slots sequentially with delay between Gemini calls
      setStatus("Starting background run…");
      const tasks = slotResolved.map((r) => {
        const { spec, i, slotNum, srcLatest } = r;
        if (spec.type === "copy") {
          return {
            type: "copy",
            slotIndex: i,
            source_storage_path: srcLatest.fullPath,
          };
        }
        return {
          type: "edits",
          slotIndex: i,
          input_storage_path: srcLatest.fullPath,
          input_charm_storage_path: charmLatest.fullPath,
          prompt: buildSlotPrompt(category, spec.folder, slotNum),
          // model is hard-locked server-side; included here is harmless but not required
          model: "gemini-3-pro-image-preview",
        };
      });

      // Netlify background function returns 202 immediately; work continues server-side.
      await postJson(GEMINI_BG_FN, {
       kind: "run_set_async",
        activeCategory: category,
        output_base_path: outputBasePath,
       delayMs: 1000,          // ✅ 1000ms spacing between Gemini slot submissions (server-enforced)
        tasks,
      });

      // 4) Poll each Slot PNG in parallel; update previews as each arrives
      setStatus("Generating…");
      const slotWaiters = slotResolved.map(async (r) => {
       const { spec, i, slotNum, srcLatest } = r;
       const prevBox = document.getElementById(`slotPrev_${i}`);
       const setImg = (url) => { if (prevBox) prevBox.innerHTML = `<img src="${url}" />`; };

        const waited = await waitForSlotPngUrl(outputBasePath, i);
        // cache-bust so the preview updates even if the filename is overwritten
        const finalUrl = `${waited.url}${waited.url.includes("?") ? "&" : "?"}cb=${Date.now()}`;
        setImg(finalUrl);

        return {
          slot: slotNum,
          type: spec.type === "copy" ? "copy" : "gen",
          source: srcLatest.fullPath,
          newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
          output: waited.storagePath,
        };
      });

      const results = await Promise.all(slotWaiters);
      results.sort((a, b) => a.slot - b.slot);
      manifest.slots = results;

      setStatus("Writing manifest…");
      await postJson("geminiImageProxy", {
        kind: "write_manifest",
        activeCategory: category,
        output_base_path: outputBasePath,
        manifest,
      });

      setStatus(`Done → ${category}/Ready_To_List/Set_${setN}`);
      // Now that the set is done, enable per-slot Redo buttons
      setAllRedoEnabled(true);
      } finally {
        setBusy(false);
      }
    }

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1–8)
    // ------------------------------------------------------------

    // Slot 2 prompt: ONE-PASS charm replacement + engraving fidelity + OUTPUT zoom-out 1.6×
    const SLOT2_DUPLICATE_PROMPT =
    `CRITICAL: Slot 2 is a charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use Image[0] as the base photo.
    • Replace the charm/pendant in Image[0] with the charm from Image[1].

    INPUT IMAGES (ORDER MATTERS)
    • Image[0] = base photo (scene + camera + chain placement + hardware position)
    • Image[1] = charm macro (pixel-truth source for silhouette + cutouts + engraving)

    CHARM SCALE OVERRIDE (NON-NEGOTIABLE)
    • The placed/replaced charm MUST be smaller than the charm being replaced in Image[0].
    • Apply an extra downscale of 1.6× (i.e. final charm must be ~40% of the size you would normally choose).
    • Do NOT compensate by thickening lines, enlarging cutouts, or changing engraving. Size change must be a pure scale change only.

    ENGRAVING + CUTOUT FIDELITY (TOP PRIORITY — IMAGE[1] IS SINGLE TRUTH SOURCE)
    • Treat Image[1] as pixel-truth. Do NOT redraw, “enhance,” simplify, smooth, stylize, thicken, sharpen, clean up, or reinterpret.
    • Add a subtle contact shadow under charm + mild specular alignment as needed to the Final generated image.
    • Outline lock: the outer perimeter must match Image[1] exactly (no rounding, no warping, no missing corners, no bulges).
    • Cutout lock: every internal cutout/negative-space hole must match Image[1] exactly (shape + position + proportions). Do not fill-in holes. Do not merge holes.
    • Engraving lock: preserve every stroke exactly as in Image[1] (no stroke loss, no merging, no thickening, no cleanup, no mirrored text, no invented marks).
    • Edge integrity: keep cutout edges crisp. Do not blur/smear/over-anti-alias away fine cutout detail.
    • Allowed Charm Edits: tiny exposure/white-balance match to Image[0] + subtle contact shadow under charm + mild specular alignment. No geometry changes.

    HARDWARE + HOOP CONNECTION (NON-NEGOTIABLE)
    • The charm’s top hoop/bail/loop MUST be an INTEGRATED part of the charm silhouette exactly like Image[1] — as if the entire charm (including the hoop) was laser-cut from one single sheet of metal.
    • The hoop-to-charm attachment MUST have a robust, wide contact area like Image[1]. This is NOT a tiny touch-point. It must NOT look “barely touching.”
    • The attachment must read like one continuous metal piece: no seam line, no solder/weld look, no separate part glued on, no “ring sitting on top.”
    • Geometry lock: preserve the exact bridge/tab shape that connects the hoop to the charm body in Image[1] (width, curvature, thickness, edge bevel).
    • The hoop must be fully connected with a broad “tab” of metal. HARD FAIL if the hoop connects via a hairline neck, thin spike, or point-contact.
    • The jump ring must pass through the hoop and sit naturally inside it, but the hoop itself must remain part of the charm’s perimeter geometry (not re-invented hardware).
    • ONE-PIECE LASER-CUT RULE: the hoop/bail is part of the SAME continuous metal piece as the charm body (like Image[1]) — NOT a separate ring “added,” “welded,” “soldered,” or “barely touching.”
    • ROBUST ATTACHMENT RULE: the hoop-to-charm connection must have a thick/wide bridge of metal (large surface-area contact), not a tangential touchpoint.
      - Minimum bridge width: ≥ 35% of the hoop’s OUTER diameter.
      - Minimum contact length: ≥ 25% of the hoop’s outer arc must visibly blend into the charm’s body at the attachment region.
      - If uncertain, OVER-CONNECT (thicker/wider bridge) rather than under-connect. Never reduce the bridge to a thin neck.
    • HARD FAIL if the hoop looks “just barely touching,” hairline-connected, separated by any visible slit/gap, or reads as a separate component sitting on top of the charm.
    • Scale rule: when you shrink the charm, the hoop + its bridge/tab must shrink proportionally as part of the same silhouette (do NOT shrink only the body and leave a weak connection).

    LOCKS (NON-NEGOTIABLE)
    • Preserve EVERYTHING ELSE from Image[0]: chain links, bead stations, jump ring placement, clasp, metal tone, lighting, background, hardware alignment.
    • Do not add objects. Do not remove objects (other than replacing the charm itself). Do not change the chain geometry.

    HARD FAIL CONDITIONS
    - Any charm larger than Image[0]'s charm, any engraving changes, any altered cutout geometry, any changed chain geometry/station spacing, blur/smear on charm details, or any added objects.
    - Any hoop/bail connection that is point-touching, hairline, barely touching, offset, floating, or looks like a separate welded/soldered ring.
    - Any hoop/bail that appears barely touching, point-connected, hairline-connected, floating, hovering, separated, or “attached later” (weld/solder/glue look). The hoop must look like part of the same laser-cut charm silhouette from Image[1].`;

        // Slot 3 prompt: ONE-PASS sizing-guide charm replacement (NO necklace)
        const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use Image[0] as the base sizing-guide graphic.
    • Replace ONLY the charm in Image[0] with the charm from Image[1].

    INPUT IMAGES (ORDER MATTERS)
    • Image[0] = sizing guide base image (ALL text, layout, pencil, line, background)
    • Image[1] = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in Image[0].
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (IMAGE[1] IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Image[1].
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any necklace or jewelry added.
    - Any charm size mismatch vs Image[0].
    - Any weak or disconnected hoop connection.`;

    // Slot 1 prompt (edit freely)
    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be bright yellow gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as Image[0]. Only the charm is scaled.

    TASK (SLOT 1 — IMAGE EDIT, SINGLE PASS)
    Duplicate and zoom-in into the female model in Image[0], only replace the charm from Image[1] onto the existing necklace chain in Image[0] as a hanging flat charm.
    Match the subject identity from Image[0]; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Image_0
    Focus on Charm Engraving details and ensure 100% accuracy to Image_1
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Image_0.`;

    // ------------------------------------------------------------
    // Explicit per-slot prompt pipelines (Slots 1–8)
    // NOTE: Slots 4–8 currently reuse Slot 1 prompt text, but remain
    // explicitly mapped so each slot has its own pipeline hook.
    // ------------------------------------------------------------
    const SLOT_PROMPTS = Object.freeze({
      1: DEFAULT_PROMPT,
      2: SLOT2_DUPLICATE_PROMPT,
      3: SLOT3_SIZING_GUIDE_PROMPT,
      4: DEFAULT_PROMPT,
      5: DEFAULT_PROMPT,
      6: DEFAULT_PROMPT,
      7: DEFAULT_PROMPT,
      8: DEFAULT_PROMPT,
    });

    function buildSlotPrompt(category, folderName, slotNum) {
      // Keep signature the same to avoid touching callsites.
      // (category/folderName reserved for future slot-specific prompt variants)
      return SLOT_PROMPTS[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
  </script>
</body>
</html>