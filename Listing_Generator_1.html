<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    .slotPrev{ width:100%; height:190px; border-radius:12px; border:1px solid var(--line); background:#0b0d12; overflow:hidden; }
    .slotPrev img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    
    /* NEW: Success border style */
    .slotPrev.success-border {
      border: 3px solid lightgreen !important;
    }

    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Listing-Generator-1</h1>

      <div class="row" style="margin-bottom: 14px; background: #0e1220; padding: 4px; border-radius: 12px; border: 1px solid var(--line);">
        <button class="btn" id="toggleGenerate" style="flex:1; background: var(--line); border:none; color: var(--text);">Generate</button>
        <button class="btn" id="toggleReview" style="flex:1; background: transparent; border:none; color: var(--muted);">Review</button>
      </div>
      
      <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>

      <label>Category (Storage source of truth)</label>
      <select id="activeCategory"></select>
      <div class="muted" style="margin-top:6px;">
        Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
        <br>
        <strong>Note:</strong> Stud/Hoop Earrings use <code>New_Charms_Earrings</code>. Others use <code>New_Charms</code>.
      </div>

      <div id="generateSection">
        <div class="row" style="margin-top:10px;">
          <button class="btn" id="generateSet">Generate Set (Randomized Refs)</button>
        </div>

        <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
        <div id="panels"></div>

        <label style="margin-top:12px;">Shared Pool (Autoselected based on category)</label>
        <div id="panelNewCharms"></div>
      </div>

      <div id="reviewSection" style="display: none;">
        <label style="margin-top:12px;">Select Set to Review</label>
        <div class="row">
          <select id="reviewSetSelect"></select>
        </div>
        <div class="row" style="margin-top:10px;">
           <button class="btn" id="approveSetBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Approve Set (Move to Completed)</button>
        </div>
        <div style="margin-top: 8px; font-size: 11px; color: var(--muted);" id="backgroundQueueStatus"></div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, getBytes, listAll, getMetadata, deleteObject } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";


    // --- Netlify functions base ---
    const functionsBaseUrl = `${window.location.origin}/.netlify/functions`;

    // -------------------------
    // Per-slot folder layout (Firebase Storage)
    // -------------------------
    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "New_Charms",
      "New_Charms_Earrings", // Added for clarity, though it's a shared folder
      "Completed_Charm",
    ];


    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Product_Shots_2",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],

      Hoop_Earrings: [
        "Hoop_Earring_Models","Hoop_Earring_Sec_Models","Hoop_Charm_Dimensions","Hoop_Metal_Options","Hoop_Size_Options","Hoop_Model_Size_Guide","Hoop_Earring_Care_Guide","Hoop_Primary_Product","Ready_To_List","Completed_&_Listed_Sets" 
      ],

      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      New_Charms: [],
      New_Charms_Earrings: [],
      Completed_Charm: [],
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots_2" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Hoop_Earring_Models" },       // Slot 1
        { type:"gen", folder:"Hoop_Primary_Product" },      // Slot 2
        { type:"gen", folder:"Hoop_Size_Options" },         // Slot 3
        { type:"gen", folder:"Hoop_Earring_Sec_Models" },   // Slot 4       
        { type:"gen", folder:"Hoop_Charm_Dimensions" },     // Slot 5
        { type:"copy", folder:"Hoop_Model_Size_Guide" },    // Slot 6
        { type:"gen", folder:"Hoop_Metal_Options" },        // Slot 7 
        { type:"copy", folder:"Hoop_Earring_Care_Guide" },  // Slot 8
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Care_Metal_Guide" },
      ],
    };

    // --- Firebase config (matches shipping-1 patterns) ---
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    // âœ… IMPORTANT: use COMPAT auth so COMPAT firestore (window.db) has permissions
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth âœ”", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth âŒ", e);
    }

    window.db = firebase.firestore();

    // Firestore transport hardening
    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    // modular twin (same approach as shipping-1 resumable uploader)
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    // Gate specifically for Storage (modular) so request.auth is never null in Storage rules
    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 600000);  // Increased to 10 min
      const intervalMs = Number(opts.intervalMs ?? 3000);   // Increased to 3s to reduce load
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);

      // Stagger initial check to prevent thundering herd of 8 concurrent requests
      await sleep(Math.random() * 3000); 

      const t0 = Date.now();
      while (true) {
        await ensureStorageSignedIn();

        // âœ… Only LIST-first polling.
        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            // If this call is part of a Redo, the slot file likely already exists.
            // Only return once we detect the file has been overwritten (metadata changed).
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  // Found the file, but it's still the old version â€” keep waiting.
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (String(e2?.message || e2).includes("slot_not_updated_yet")) {
                  // keep waiting
                } else {
                  // transient metadata issue â€” keep waiting
                }
                throw e2;
              }
            }

            try {
              const url = await getDownloadURL(hit);
              return { storagePath: hit.fullPath, url };
            } catch (eUrl) {
              const msg = String(eUrl?.message || eUrl);
              const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");

              if (looksUnauthorized) {
                throw new Error(
                  `Cannot download ${hit.fullPath} (permission/token issue).\n` +
                  `If this slot was produced via server-side copy(), ensure metadata.firebaseStorageDownloadTokens is set on the copied object.\n` +
                  `Server fix: after copy() call setMetadata({ metadata: { firebaseStorageDownloadTokens: <uuid> } }).`
                );
              }
              throw eUrl;
            }
          }
        } catch (e) {
          // If LIST is blocked by Storage rules, we cannot poll without causing 404s.
          const msg = String(e?.message || e);
          
          // Check for 500 error specifically and backoff
          if (msg.includes("500") || msg.includes("internal")) {
             console.warn("Storage 500 error, retrying with backoff...", outputBasePath);
             await sleep(5000); 
             // Don't throw, just loop again after wait
          } else {
             const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");
             if (looksUnauthorized) {
                throw new Error(
                `Storage rules block LIST on: ${outputBasePath}\n` +
                `Allow LIST for Ready_To_List (or at least ${outputBasePath}) so the UI can detect Slot PNGs without any 404 polling.`
                );
             }
             // transient listing issue: keep waiting
          }
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs);
      }
    }

    // --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");

    // --- Mode Variables ---
    const toggleGenerateBtn = document.getElementById("toggleGenerate");
    const toggleReviewBtn = document.getElementById("toggleReview");
    const generateSection = document.getElementById("generateSection");
    const reviewSection = document.getElementById("reviewSection");
    const reviewSetSelect = document.getElementById("reviewSetSelect");
    const approveSetBtn = document.getElementById("approveSetBtn"); 
    const backgroundQueueStatus = document.getElementById("backgroundQueueStatus"); // Status text
    let appMode = "generate"; // 'generate' or 'review'

    function setStatus(msg){ statusEl.textContent = msg; }

    // Busy-state helper (Generate button + basic UI lock)
    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
      // approveSetBtn is now managed by the background Queue, not blocking the UI globally
    }

   // Current generated set context (used by per-slot Redo)
    let CURRENT_SET = null; // { category, outputBasePath, setN }
    
    // NEW: Global tracker for Redo operations across all sets
    const REDO_STATE = {}; 

    function setAllRedoEnabled(enabled){
      gridEl.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet. Generate a set first.");
      }

      const ctxSetPath = CURRENT_SET.outputBasePath;
      const ctxCategory = CURRENT_SET.category;
      const ctxSetN = CURRENT_SET.setN;
      
      const slotPlan = SLOT_MAP[ctxCategory];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex} for ${ctxCategory}`);
      
      const redoKey = `${ctxSetPath}::${slotIndex}`;

      REDO_STATE[redoKey] = { status: 'running' };
      updateDropdownLabels(); 

      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${ctxSetPath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {
        // Slot may not exist yet
      }

      // Check if we are still viewing the set we initiated this from
      const isViewing = (CURRENT_SET?.outputBasePath === ctxSetPath);
      
      if (isViewing) {
          const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
          const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
          const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
          
          if (redoBtn) redoBtn.disabled = true;
          if (prevBox) {
              prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
              prevBox.classList.remove("success-border"); // RESET BORDER
          }
          setStatus(`Redo Slot ${slotIndex + 1}â€¦`);
      }

      const srcFolder = slotRefFolder(ctxCategory, spec.folder);
      const srcRandom = await listRandomFile(srcFolder); 
      if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);

      const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(ctxCategory);
      const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
      const charmLatest = await listLatestFile(charmFolderPath); 
      if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);
      
      let waitedResult = null; 

      try {
          if (spec.type === "copy") {
            const r = await postJson(GEMINI_FN, {
              kind: "copy_to_slot",
              activeCategory: ctxCategory,
              source_storage_path: srcRandom.fullPath, 
              output_base_path: ctxSetPath,
              slotIndex,
            });

            waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          } else {
            await postJson(GEMINI_BG_FN, {
              kind: "edits",
              activeCategory: ctxCategory,
              input_storage_path: srcRandom.fullPath, 
              input_charm_storage_path: charmLatest.fullPath,
              output_base_path: ctxSetPath,
              slotIndex,
              model: "gemini-3-pro-image-preview",
              prompt: buildSlotPrompt(ctxCategory, spec.folder, slotIndex + 1),
            });

              waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          }
          
          // SUCCESSS Handling
          const finalUrl = cacheBust(waitedResult.url);
          REDO_STATE[redoKey] = { status: 'completed', url: finalUrl };
          updateDropdownLabels(); 

          // If still viewing, update DOM
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
              const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
              const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
              const metaEl   = slotCard?.querySelector(`#slotMeta_${slotIndex}`);
              const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
              
              if (prevBox) {
                  prevBox.innerHTML = `<img src="${finalUrl}" />`;
                  prevBox.classList.add("success-border"); 
              }
              if (metaEl) metaEl.textContent = `Source: ${srcRandom.fullPath}`;
              if (redoBtn) redoBtn.disabled = false;
              setStatus(`Ready (Set_${ctxSetN})`);
          }

      } catch(err) {
          console.error("Redo failed", err);
          delete REDO_STATE[redoKey];
          updateDropdownLabels();
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
             const prevBox = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"] #slotPrev_${slotIndex}`);
             if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Error</div>`;
             setStatus("Redo failed: " + err.message);
          }
      }

      // MANIFEST UPDATE (Non-blocking usually, but await here for consistency)
      try {
        const manifestRef = ref(storage, `${ctxSetPath}/manifest.json`);
        
        const url = await getDownloadURL(manifestRef);
        const manifestJson = await fetch(`${url}${url.includes('?') ? '&' : '?'}t=${Date.now()}`).then(r => r.json());

        const slotNum = slotIndex + 1;
        const idx = manifestJson.slots.findIndex(s => s.slot === slotNum);
        
        const newEntry = {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcRandom.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waitedResult?.storagePath || "",
            updatedAt: new Date().toISOString()
        };

        if (idx > -1) {
            manifestJson.slots[idx] = { ...manifestJson.slots[idx], ...newEntry };
        } else {
            manifestJson.slots.push(newEntry);
            manifestJson.slots.sort((a,b) => a.slot - b.slot);
        }

        await postJson("geminiImageProxy", {
            kind: "write_manifest",
            activeCategory: ctxCategory,
            output_base_path: ctxSetPath,
            manifest: manifestJson,
        });
      } catch (e) {
        console.warn("Manifest update failed (non-fatal):", e);
      }
    }
    
    window.redoSlot = redoSlot;

    // Back-compat alias
    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/New_Charms`;
    }

    function newCharmsEarringsPath() {
      return `${ROOT}/New_Charms_Earrings`;
    }

    // -------------------------------------------------------------------------
    // NEW: Randomizer Function
    // -------------------------------------------------------------------------
    async function listRandomFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      
      if (!res.items?.length) return null;

      const randomIndex = Math.floor(Math.random() * res.items.length);
      const randomItem = res.items[randomIndex];
      const url = await getDownloadURL(randomItem);
      return { fullPath: randomItem.fullPath, name: randomItem.name, url };
    }

    async function listLatestFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loadingâ€¦</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          console.warn("[Storage:listAll] failed", { targetFullPath, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading â†’ ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      if (["Stud_Earrings", "Hoop_Earrings"].includes(category)) {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsEarringsPath(), "New_Charms_Earrings (Earrings Only)"));
      } else {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms (Necklaces/Other)"));
      }

      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);

    toggleGenerateBtn.addEventListener("click", () => {
      appMode = "generate";
      toggleGenerateBtn.style.background = "var(--line)";
      toggleGenerateBtn.style.color = "var(--text)";
      toggleReviewBtn.style.background = "transparent";
      toggleReviewBtn.style.color = "var(--muted)";
      generateSection.style.display = "block";
      reviewSection.style.display = "none";
      renderCategoryUI(activeCategoryEl.value);
      gridEl.innerHTML = "";
      setStatus("Ready");
    });

    toggleReviewBtn.addEventListener("click", () => {
      appMode = "review";
      toggleReviewBtn.style.background = "var(--line)";
      toggleReviewBtn.style.color = "var(--text)";
      toggleGenerateBtn.style.background = "transparent";
      toggleGenerateBtn.style.color = "var(--muted)";
      generateSection.style.display = "none";
      reviewSection.style.display = "block";
      gridEl.innerHTML = "";
      loadReviewSets();
    });

    activeCategoryEl.addEventListener("change", () => {
      if (appMode === "generate") {
        renderCategoryUI(activeCategoryEl.value);
      } else {
        loadReviewSets();
        gridEl.innerHTML = "";
      }
    });

    // --- Loading Sets functionality ---
    async function loadReviewSets() {
      const category = activeCategoryEl.value;
      setStatus("Loading sets...");
      reviewSetSelect.innerHTML = `<option>Loading...</option>`;
      try {
        await ensureStorageSignedIn();
        const readyToListRef = ref(storage, `${ROOT}/${category}/Ready_To_List`);
        const res = await listAll(readyToListRef);
        const sets = res.prefixes.map(p => p.name).filter(n => n.startsWith('Set_'));
        sets.sort((a, b) => {
          const numA = parseInt(a.replace('Set_', '')) || 0;
          const numB = parseInt(b.replace('Set_', '')) || 0;
          return numB - numA;
        });

        if (sets.length > 0) {
          reviewSetSelect.innerHTML = sets.map(s => `<option value="${s}">${s}</option>`).join("");
          setStatus(`Found ${sets.length} sets.`);
          
          updateDropdownLabels();
          
          // Auto-load first item if present
          if (reviewSetSelect.value) {
              loadSetImages(reviewSetSelect.value);
          }
        } else {
          reviewSetSelect.innerHTML = `<option value="">No sets found</option>`;
          setStatus("No sets found.");
          gridEl.innerHTML = "";
        }
      } catch (e) {
        console.error("Error loading sets:", e);
        setStatus("Error loading sets");
        reviewSetSelect.innerHTML = `<option value="">Error loading</option>`;
      }
    }
    
    function updateDropdownLabels() {
        const category = activeCategoryEl.value;
        const options = Array.from(reviewSetSelect.options);
        
        options.forEach(opt => {
            const setName = opt.value;
            if (!setName) return;
            
            const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
            
            const statuses = [];
            Object.keys(REDO_STATE).forEach(key => {
                if (key.startsWith(setPath)) {
                    const slotIdx = key.split('::')[1];
                    const slotNum = parseInt(slotIdx) + 1;
                    const state = REDO_STATE[key];
                    if (state.status === 'running') {
                        statuses.push(`Slot ${slotNum}: â³`);
                    } else if (state.status === 'completed') {
                        statuses.push(`Slot ${slotNum}: ðŸŸ¢`);
                    }
                }
            });
            
            if (statuses.length > 0) {
                opt.text = `${setName} (${statuses.join(', ')})`;
            } else {
                opt.text = setName;
            }
        });
    }

    // NEW: Consolidated Load Function
    async function loadSetImages(setName) {
      if (!setName) return;

      const category = activeCategoryEl.value;
      setBusy(true);
      setStatus(`Loading ${setName}...`);
      gridEl.innerHTML = "";

      try {
        await ensureStorageSignedIn();
        const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const setRef = ref(storage, setPath);
        const res = await listAll(setRef);

        let parsedSetN = parseInt(setName.replace('Set_', '')) || 0;
        CURRENT_SET = { category, outputBasePath: setPath, setN: parsedSetN };

        // 404 Safety: try/catch the manifest load
        let manifestData = null;
        try {
            const manifestRef = ref(storage, `${setPath}/manifest.json`);
            const mUrl = await getDownloadURL(manifestRef);
            manifestData = await fetch(`${mUrl}${mUrl.includes('?') ? '&' : '?'}t=${Date.now()}`).then(r => r.json());
        } catch(err) {
            // expected if manifest doesn't exist
        }

        const slotPlan = SLOT_MAP[category] || [];
        
        slotPlan.forEach((spec, i) => {
          const slotNum = i + 1;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i;

          let sourceStr = "Unknown";
          if (manifestData && manifestData.slots) {
              const slotMeta = manifestData.slots.find(s => s.slot === slotNum);
              if (slotMeta && slotMeta.source) sourceStr = slotMeta.source;
          }

          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">Review: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Loadingâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${sourceStr}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        });

        slotPlan.forEach((_, i) => {
             const key = `${setPath}::${i}`;
             const state = REDO_STATE[key];
             const prevBox = document.getElementById(`slotPrev_${i}`);
             const redoBtn = document.getElementById(`redo_${i}`);

             if (state && state.status === 'running') {
                 if (prevBox) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
                    prevBox.classList.remove("success-border");
                 }
                 if (redoBtn) redoBtn.disabled = true;
             } 
             else if (state && state.status === 'completed') {
                 if (prevBox) prevBox.classList.add("success-border");
             }
        });

        const slotFiles = res.items.filter(item => item.name.startsWith("Slot_") && item.name.endsWith(".png"));
        
        await Promise.all(slotFiles.map(async (fileRef) => {
          const match = fileRef.name.match(/Slot_(\d+)\.png/);
          if (match) {
            const slotIndex = parseInt(match[1]) - 1;
            
            const key = `${setPath}::${slotIndex}`;
            if (REDO_STATE[key]?.status === 'running') return;

            try {
              const url = await getDownloadURL(fileRef);
              const prevBox = document.getElementById(`slotPrev_${slotIndex}`);
              if (prevBox) {
                const finalUrl = cacheBust(url);
                prevBox.innerHTML = `<img src="${finalUrl}" />`;
              }
            } catch (err) {
              // ignore
            }
          }
        }));

        slotPlan.forEach((spec, i) => {
          const prevBox = document.getElementById(`slotPrev_${i}`);
          if (prevBox && prevBox.innerHTML.includes("Loadingâ€¦")) {
            prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
          }
        });

        setStatus(`Viewing ${category} / ${setName}`);
      } catch (e) {
        // If the set folder itself is gone (404 on listAll), handle gracefully
        if (e.code === 'storage/object-not-found') {
             gridEl.innerHTML = `<div class='slotRefEmpty'>Set '${setName}' not found (might be deleted/moved).</div>`;
        } else {
             console.error(e);
             setStatus(`Error: ${e.message}`);
        }
      } finally {
        setBusy(false);
      }
    }
    
    reviewSetSelect.addEventListener("change", (e) => {
        loadSetImages(e.target.value);
    });

    // NEW: "Optimistic" Approve function
    function approveSet() {
      const category = activeCategoryEl.value;
      const setName = reviewSetSelect.value;
      if (!setName) return;

      if (!confirm(`Approve ${setName}? (Instant Queue)`)) return;

      // 1. Remove from UI immediately
      const optionToRemove = reviewSetSelect.querySelector(`option[value="${setName}"]`);
      if (optionToRemove) optionToRemove.remove();

      // 2. Load next set immediately if exists
      if (reviewSetSelect.options.length > 0) {
          // Select first available (or keep index)
          reviewSetSelect.selectedIndex = 0; 
          loadSetImages(reviewSetSelect.value);
      } else {
          gridEl.innerHTML = "<div class='slotRefEmpty'>No more sets to review!</div>";
          setStatus("Queue clear.");
      }

      // 3. Trigger background move
      runBackgroundApproval(category, setName);
    }

    // NEW: Background Task
    async function runBackgroundApproval(category, setName) {
        const queueId = `${category}/${setName}`;
        backgroundQueueStatus.textContent = `Queued: ${setName}...`;
        console.log(`[Queue] Starting background move for ${setName}`);

        const srcFolder = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const destFolderName = `${category}_${setName}`; 
        const destFolder = `${ROOT}/Completed_Sets/${destFolderName}`;

        try {
            await ensureStorageSignedIn();
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const itemRef of res.items) {
               // Download -> Upload -> Delete
               const url = await getDownloadURL(itemRef);
               const blob = await fetch(url).then(r => r.blob());
               const newRef = ref(storage, `${destFolder}/${itemRef.name}`);
               await uploadBytesResumable(newRef, blob);
               await deleteObject(itemRef);
            }
            console.log(`[Queue] Finished moving ${setName}`);
            backgroundQueueStatus.textContent = `Completed: ${setName}`;
            
            // Clear status after 3s
            setTimeout(() => {
                if (backgroundQueueStatus.textContent.includes(setName)) {
                    backgroundQueueStatus.textContent = "";
                }
            }, 3000);

        } catch (e) {
            console.error(`[Queue] Failed to move ${setName}`, e);
            backgroundQueueStatus.textContent = `Error moving ${setName}`;
        }
    }

    approveSetBtn.addEventListener("click", approveSet);
    
    async function postJson(path, body) {
      const res = await fetch(`${functionsBaseUrl}/${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      // IMPORTANT: do NOT silently turn non-JSON into {}
      const raw = await res.text().catch(() => "");
      let j = null;
      try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

      if (!res.ok) {
        const msg =
          (j?.error?.message || j?.error) ||
          (raw ? raw.slice(0, 300) : "") ||
          `HTTP ${res.status}`;
        throw new Error(msg);
      }

      // Netlify background functions often return 202 with an empty body.
      if (!j) {
        if (res.status === 202 && (!raw || !raw.trim())) {
          return { ok: true, accepted: true, status: 202 };
        }
        throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
      }
      return j;
    }

    // Use the NON-background endpoint so we always get JSON back.
    const GEMINI_FN = "geminiImageProxy";
    const GEMINI_BG_FN = "geminiImageProxy-background";

    async function allocSet(category) {
      return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
    }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      // Some backends return a string directly, others nest under data/result/payload.
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        // top-level
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        // common nesting
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

        setStatus("Allocating Setâ€¦");
        const alloc = await allocSet(category);
        console.log("alloc_set response:", alloc);
        const outputBasePath = normalizeAllocOutputBasePath(alloc);
        if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

        // Prefer server-provided setN, but fall back to parsing from outputBasePath
        let setN = alloc?.setN ?? alloc?.set_n;
        if (setN == null) {
          const m = outputBasePath.match(/\/Set_(\d+)\b/);
          if (m) setN = Number(m[1]);
        }

        // Save current set context for per-slot Redo
        CURRENT_SET = { category, outputBasePath, setN };

        // âœ… LOGIC UPDATE: Pick charm source based on category
        const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(category);
        const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
        
        // Constraint C: Charms are NOT randomized. Keep listLatestFile here.
        const charmLatest = await listLatestFile(charmFolderPath);
        if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);

        const manifest = {
          category,
          setN,
          outputBasePath,
          timestamp: new Date().toISOString(),
          slots: [],
          model: "gemini-3-pro-image-preview",
        };

        // 1) Resolve all slot sources up front
        // Constraint A & B: Randomize slot reference images.
        setStatus("Preparing slots (Randomizing)â€¦");
        const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
          const srcFolder = slotRefFolder(category, spec.folder);
          // CHANGED: Use listRandomFile instead of listLatestFile
          const srcRandom = await listRandomFile(srcFolder);
          if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);
          return { spec, i, slotNum: i + 1, srcLatest: srcRandom };
        }));

        // 2) Render all slot cards immediately
        gridEl.innerHTML = "";
        for (const r of slotResolved) {
          const { spec, i, slotNum, srcLatest } = r;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          // Add data-slot-index for easier selection
          slotCard.dataset.slotIndex = i; 
          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Queuedâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" disabled onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        }

        setStatus("Starting background runâ€¦");

        // 3) Construct Tasks Object
        const tasks = slotResolved.map((r) => {
          const { spec, i, slotNum, srcLatest } = r;
          if (spec.type === "copy") {
            return {
              type: "copy",
              slotIndex: i,
              source_storage_path: srcLatest.fullPath,
            };
          }
          return {
            type: "edits",
            slotIndex: i,
            input_storage_path: srcLatest.fullPath,
            input_charm_storage_path: charmLatest.fullPath, // Pass the correct charm file
            prompt: buildSlotPrompt(category, spec.folder, slotNum),
            model: "gemini-3-pro-image-preview",
          };
        });

        // ---------------------------------------------------------
        // FIX: Decouple Trigger and Polling
        // ---------------------------------------------------------

        // A. Start Polling Logic (Wait for images to appear in Storage)
        // We start this PROMISE immediately, but await it later.
        const pollingPromise = Promise.all(slotResolved.map(async (r) => {
          const { spec, i, slotNum, srcLatest } = r;
          const prevBox = document.getElementById(`slotPrev_${i}`);
          const setImg = (url) => { if (prevBox) prevBox.innerHTML = `<img src="${url}" />`; };

          // Wait for the file to appear
          const waited = await waitForSlotPngUrl(outputBasePath, i);
          
          // cache-bust so the preview updates even if the filename is overwritten
          const finalUrl = `${waited.url}${waited.url.includes("?") ? "&" : "?"}cb=${Date.now()}`;
          setImg(finalUrl);

          return {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcLatest.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waited.storagePath,
          };
        }));

        // B. Fire the Trigger (Send request to server)
        // âœ… CRITICAL FIX: We MUST await this. 
        // If the request fails, we throw immediately instead of waiting 10 minutes for a timeout.
        try {
            await postJson(GEMINI_BG_FN, {
              kind: "run_set_async",
              activeCategory: category,
              output_base_path: outputBasePath,
              delayMs: 20000, // 20.0s spacing between Gemini slot submissions
              tasks,
            });
            console.log("Background run triggered successfully");
        } catch (err) {
            // Throwing here stops execution, preventing the polling timeout error.
            throw new Error(`Failed to start generation on server: ${err.message}`);
        }

        setStatus("Generatingâ€¦ (Monitoring Storage)");

        // C. Wait for Polling to finish (This confirms images are created)
        const results = await pollingPromise;
        
        // Sort results to match manifest order
        results.sort((a, b) => a.slot - b.slot);
        manifest.slots = results;

        setStatus("Writing manifestâ€¦");
        await postJson("geminiImageProxy", {
          kind: "write_manifest",
          activeCategory: category,
          output_base_path: outputBasePath,
          manifest,
        });

        setStatus(`Done â†’ ${category}/Ready_To_List/Set_${setN}`);
        // Now that the set is done, enable per-slot Redo buttons
        setAllRedoEnabled(true);
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      } finally {
        setBusy(false);
      }
    }

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1â€“8)
    // ------------------------------------------------------------
    // ... [Rest of the Prompt strings and PROMPT_MAPS remain unchanged] ...
    
    // =========================================================================
    // 0. BEADY_NECKLACE
    // =========================================================================

    const SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).

    â€¢ Critical: Never Cut out darkened areas of the Charm/Pendant. Darkened portions of the Charm/Pendant are typically hatched engravings.

    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task.

    PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Single pass only.
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    â€¢ Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;


    // =========================================================================
    // 1. // REGULAR NECKLACE
    // =========================================================================
    const REGULAR_SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    Do noy cutout any engravings, preserve ALL Charm/Pendant engravings in great detail.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const REGULAR_SLOT3_SIZING_GUIDE_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Slightly vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT7_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

  



    // =========================================================================
    // 2. // BRACELET PROMPTS
    // =========================================================================
    const BRACELET_MODEL_PROMPT =
    `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_CREATIVE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SIZE_GUIDE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;

    const BRACELET_ENGRAVING_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SEC_MODEL_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    const BRACELET_PRODUCT_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;





    // =========================================================================
    // 3. // STUD EARRINGS PROMPTS
    // =========================================================================
    const STUD_MODEL_PROMPT =
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and thin sheet of metal, always render the Charm/Pendant completely flat
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. `;

    const STUD_CREATIVE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SIZE_GUIDE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be VERY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow engraving colour to be dark, brown, or black, ensure all engraving colours are a light shade of copper colour`;

    const STUD_PRODUCT_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin.  
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_PRODUCT_2_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;



















    // =========================================================================
    // 4. // HOOP EARRINGS PROMPTS
    // =========================================================================

    const HOOP_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
    â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
    â€¢ The new Charm must be the same or smaller size then the Reference Image. 
    â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
    â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
    â€¢ HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    â€¢ DO NOT allow any rounded/radius on the cutout edges.
    â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
    â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
    â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.
    â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;

    const HOOP_METAL_OPTIONS_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm (2 Yellow Gold & 2 Silver) using the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth. `;

    const HOOP_SIZE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;

    const HOOP_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
        â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
          HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.`;

    const HOOP_DIMENSION_PROMPT =
    `TASK
        â€¢ Duplicate the Reference product image exactly and only update the 1 charm from the Charm Reference image.
        â€¢ Preserve all engravings as they appear in the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;



    const HOOP_PRIMARY_PRODUCT_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and only update the 2 charms from the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
        â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;




















    // =========================================================================
    // 5. // CHARM ONLY PROMPTS 
    // =========================================================================
    const CHARM_TEMPLATE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.`;

    const CHARM_TYPES_PROMPT = 
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the reference image exactly, only replace the 3 charms (2 smaller huggie Charms and 1 necklace Charm) with the Charm Refernce image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.
        â€¢ Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const CHARM_MODEL_PROMPT = 
    `TASK: (Force the Charm to be EXTREMELY SMALL)
        â€¢Generate a high-end photorealistic commercial jewelry image based on the attached reference image, use soft studio lighting and sharp focus on the necklace chain and charm/pendant details.
        â€¢ Critically: Keep necklace chain details, chainlink spacing, size, Yellow 14K gold colour, and fidelity just like in the reference image. 
        â€¢ Maintain zoom level and frame.
        â€¢ Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ The chain must be bright realistic Yellow 14K gold colour and light reflections.
        â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
        â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
        â€¢ The chain must remain exactly the same size and detail as in the reference image.`;

    const CHARM_ENGRAVING_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.

      HARD FAIL CONDITIONS
        â€¢ Any weak or disconnected hoop connection.`;


    const CHARM_HOOP_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    const CHARM_SIZE_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    // =========================================================================
    // 3. MASTER MAPPING
    // =========================================================================

    const PROMPT_MAPS = {
      // 1. Regular_Necklace (Uses identical prompts to Beady)
      "Regular_Necklace": {
        1: REGULAR_DEFAULT_PROMPT,
        2: REGULAR_SLOT2_DUPLICATE_PROMPT,
        3: REGULAR_SLOT3_SIZING_GUIDE_PROMPT,
        4: REGULAR_SLOT4_PROMPT,
        5: REGULAR_SLOT5_PROMPT,
        7: REGULAR_SLOT7_PROMPT
      },
      // 2. Beady_Necklace (Original)
      "Beady_Necklace": {
        1: DEFAULT_PROMPT,
        2: SLOT2_DUPLICATE_PROMPT,
        3: SLOT3_SIZING_GUIDE_PROMPT,
        4: SLOT4_PROMPT,
        5: SLOT5_PROMPT,
        7: SLOT7_PROMPT
      },
      // 3. Stud_Earrings
      "Stud_Earrings": {
        1: STUD_MODEL_PROMPT,
        2: STUD_CREATIVE_PROMPT,
        3: STUD_SIZE_GUIDE_PROMPT,
        4: STUD_PRODUCT_PROMPT,
        5: STUD_SEC_MODEL_PROMPT,
        6: STUD_PRODUCT_2_PROMPT 
      },
      // 4. Hoop_Earrings
      "Hoop_Earrings": {
        1: HOOP_MODEL_PROMPT,
        2: HOOP_PRIMARY_PRODUCT_PROMPT,
        3: HOOP_SIZE_PROMPT,
        4: HOOP_SEC_MODEL_PROMPT,
        5: HOOP_DIMENSION_PROMPT,
        7: HOOP_METAL_OPTIONS_PROMPT
      }, 
      // 5. Charms
      "Charms": {
        1: CHARM_TEMPLATE_PROMPT, 
        2: CHARM_TYPES_PROMPT, 
        3: CHARM_MODEL_PROMPT, 
        4: CHARM_ENGRAVING_PROMPT, 
        5: CHARM_HOOP_GUIDE_PROMPT, 
        7: CHARM_SIZE_GUIDE_PROMPT 
      },
      // 6. Bracelets
      "Bracelets": {
        1: BRACELET_MODEL_PROMPT,
        2: BRACELET_CREATIVE_PROMPT,
        3: BRACELET_SIZE_GUIDE_PROMPT,
        4: BRACELET_ENGRAVING_PROMPT,
        5: BRACELET_SEC_MODEL_PROMPT,
        6: BRACELET_PRODUCT_PROMPT
      }
    };

    function buildSlotPrompt(category, folderName, slotNum) {
      // Look up the specific map for this category
      const map = PROMPT_MAPS[category];
      
      // If we have a map and a specific prompt for this slot, use it.
      if (map && map[slotNum]) {
        return map[slotNum];
      }
      
      // Fallback to default (Beady style) if category or slot undefined
      // This preserves existing behavior for unknown inputs.
      const DEFAULT_MAP = PROMPT_MAPS["Beady_Necklace"];
      return DEFAULT_MAP[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
  </script>
</body>
</html>