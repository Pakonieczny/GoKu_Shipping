<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    .slotPrev{ width:100%; height:190px; border-radius:12px; border:1px solid var(--line); background:#0b0d12; overflow:hidden; }
    .slotPrev img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Listing-Generator-1</h1>
      
        <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>


      <label>Category (Storage source of truth)</label>
      <select id="activeCategory"></select>
      <div class="muted" style="margin-top:6px;">
        Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
        Generation is disabled for <code>New_Charms</code> + <code>Completed_Charm</code>.
      </div>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="generateSet">Generate Set</button>
      </div>

      <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
      <div id="panels"></div>

      <label style="margin-top:12px;">Shared Pool: New_Charms (always used in generation)</label>
      <div id="panelNewCharms"></div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, getBytes, listAll, getMetadata } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";


    // --- Netlify functions base ---
    const functionsBaseUrl = `${window.location.origin}/.netlify/functions`;

    // -------------------------
    // Per-slot folder layout (Firebase Storage)
    // -------------------------
    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "New_Charms",
      "Completed_Charm",
    ];

    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Hoop_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots",
        "Hoop_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      New_Charms: [],
      Completed_Charm: [],
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Hoop_Size_Guide" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
    };

    // --- Firebase config (matches shipping-1 patterns) ---
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    // ✅ IMPORTANT: use COMPAT auth so COMPAT firestore (window.db) has permissions
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth ✔", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth ❌", e);
    }

    window.db = firebase.firestore();

    // Firestore transport hardening
    // Fixes: "Deadline expired before operation could complete."
    // Must be called BEFORE any reads/writes/onSnapshot listeners.
    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    // modular twin (same approach as shipping-1 resumable uploader)
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    // Gate specifically for Storage (modular) so request.auth is never null in Storage rules
    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 420000);  // 7 min
      const intervalMs = Number(opts.intervalMs ?? 1500);   // 1.5s
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);

      const t0 = Date.now();
      while (true) {
        await ensureStorageSignedIn();

        // ✅ Only LIST-first polling.
        // This guarantees the browser never issues a GET for Slot_*.png before it exists,
        // so you won't see any 404s in DevTools.
        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            // If this call is part of a Redo, the slot file likely already exists.
            // Only return once we detect the file has been overwritten (metadata changed).
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  // Found the file, but it's still the old version — keep waiting.
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (String(e2?.message || e2).includes("slot_not_updated_yet")) {
                  // keep waiting
                } else {
                  // transient metadata issue — keep waiting
                }
                throw e2;
              }
            }

            try {
              const url = await getDownloadURL(hit);
              return { storagePath: hit.fullPath, url };
            } catch (eUrl) {
              const msg = String(eUrl?.message || eUrl);
              const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");

              if (looksUnauthorized) {
                throw new Error(
                  `Cannot download ${hit.fullPath} (permission/token issue).\n` +
                  `If this slot was produced via server-side copy(), ensure metadata.firebaseStorageDownloadTokens is set on the copied object.\n` +
                  `Server fix: after copy() call setMetadata({ metadata: { firebaseStorageDownloadTokens: <uuid> } }).`
                );
              }
              throw eUrl;
            }
          }
        } catch (e) {
          // If LIST is blocked by Storage rules, we cannot poll without causing 404s.
          // Fail loudly with a targeted message instead of hammering getDownloadURL().
          const msg = String(e?.message || e);
          const looksUnauthorized =
            msg.includes("storage/unauthorized") ||
            msg.includes("403") ||
            msg.toLowerCase().includes("permission");
          if (looksUnauthorized) {
            throw new Error(
              `Storage rules block LIST on: ${outputBasePath}\n` +
              `Allow LIST for Ready_To_List (or at least ${outputBasePath}) so the UI can detect Slot PNGs without any 404 polling.`
            );
          }
          // transient listing issue: keep waiting
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs);
      }
    }

    // --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    // Category-only UI (no legacy slot editor / per-slot uploads)


    function setStatus(msg){ statusEl.textContent = msg; }

    // Busy-state helper (Generate button + basic UI lock)
    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
    }

   // Current generated set context (used by per-slot Redo)
    let CURRENT_SET = null; // { category, outputBasePath, setN }

    function setAllRedoEnabled(enabled){
      gridEl.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet. Generate a set first.");
      }

      const category = CURRENT_SET.category;
      const outputBasePath = CURRENT_SET.outputBasePath;
      const slotPlan = SLOT_MAP[category];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex} for ${category}`);

     // Capture the CURRENT slot PNG metadata so we can wait for a real overwrite.
      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${outputBasePath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {
        // Slot may not exist yet (first run) — that's fine.
      }

      const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
      const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
      const metaEl   = slotCard?.querySelector(`#slotMeta_${slotIndex}`);
      const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);

      const setImg = (url) => {
        if (!prevBox) return;
        prevBox.innerHTML = `<img src="${cacheBust(url)}" />`;
      };

      // UI lock for this slot only
      if (redoBtn) redoBtn.disabled = true;
      if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Working…</div>`;
      setStatus(`Redo Slot ${slotIndex + 1}…`);

      // Always re-pull latest inputs at the time of redo
      const srcFolder = slotRefFolder(category, spec.folder);
      const srcLatest = await listLatestFile(srcFolder);
      if (!srcLatest) throw new Error(`No files in ${srcFolder}/`);

      const charmLatest = await listLatestFile(newCharmsPath());
      if (!charmLatest) throw new Error("No files in listing-generator-1/New_Charms/");

      if (spec.type === "copy") {
        const r = await postJson(GEMINI_FN, {
          kind: "copy_to_slot",
          activeCategory: category,
          source_storage_path: srcLatest.fullPath,
          output_base_path: outputBasePath,
          slotIndex,
        });

        // Even if the server returns a URL, it may still be the old object if overwrite hasn't landed yet.
        // Wait until Storage metadata shows the Slot PNG was actually replaced.
        const waited = await waitForSlotPngUrl(outputBasePath, slotIndex, {
          afterUpdatedMs: beforeUpdatedMs,
          afterGeneration: beforeGeneration,
        });
        setImg(waited.url);
      } else {
        await postJson(GEMINI_BG_FN, {
          kind: "edits",
          activeCategory: category,
          input_storage_path: srcLatest.fullPath,
          input_charm_storage_path: charmLatest.fullPath,
          output_base_path: outputBasePath,
          slotIndex,
          model: "gemini-3-pro-image-preview",
          prompt: buildSlotPrompt(category, spec.folder, slotIndex + 1),
        });

          const waited = await waitForSlotPngUrl(outputBasePath, slotIndex, {
          afterUpdatedMs: beforeUpdatedMs,
          afterGeneration: beforeGeneration,
        });
        setImg(waited.url);
      }

      if (metaEl) metaEl.textContent = `Source: ${srcLatest.fullPath}`;
      setStatus(`Ready (Set_${CURRENT_SET.setN ?? "?"})`);
      if (redoBtn) redoBtn.disabled = false;
    }
    
    // Explicitly expose redoSlot to the window object so HTML onclick handlers can find it
    window.redoSlot = redoSlot;

    // Back-compat alias (some blocks reference categoryEl)
    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/New_Charms`;
    }

    async function listLatestFile(fullFolderPath) {
      // Deterministic:
      // 1) prefer most recently uploaded (metadata.updated/timeCreated)
      // 2) tie-break lexicographically by name
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      // Only fetch download URL for the chosen file (faster)
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loading…</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          const msg = String(e?.message || e);
          const looksUnauthorized =
            msg.includes("storage/unauthorized") ||
            msg.includes("403") ||
            msg.toLowerCase().includes("permission");
          if (looksUnauthorized) {
            countEl.textContent = `No permission to list: ${targetFullPath} (update Firebase Storage rules to allow LIST)`;
          } else {
            countEl.textContent = `Error: ${msg}`;
          }
          console.warn("[Storage:listAll] failed", { targetFullPath, msg, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading → ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms"));

      // Slot visibility hint in UI (Stud_Earrings = 7 slots)
      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    // Populate dropdown
    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);
    activeCategoryEl.addEventListener("change", () => renderCategoryUI(activeCategoryEl.value));
    
    async function postJson(path, body) {
      const res = await fetch(`${functionsBaseUrl}/${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      // IMPORTANT: do NOT silently turn non-JSON into {}
      const raw = await res.text().catch(() => "");
      let j = null;
      try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

      if (!res.ok) {
        const msg =
          (j?.error?.message || j?.error) ||
          (raw ? raw.slice(0, 300) : "") ||
          `HTTP ${res.status}`;
        throw new Error(msg);
      }

      // Netlify background functions often return 202 with an empty body.
      if (!j) {
        if (res.status === 202 && (!raw || !raw.trim())) {
          return { ok: true, accepted: true, status: 202 };
        }
        throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
      }
      return j;
    }

    // Use the NON-background endpoint so we always get JSON back.
    const GEMINI_FN = "geminiImageProxy";
    const GEMINI_BG_FN = "geminiImageProxy-background";

    async function allocSet(category) {
      return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
    }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      // Some backends return a string directly, others nest under data/result/payload.
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        // top-level
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        // common nesting
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

        setStatus("Allocating Set…");
        const alloc = await allocSet(category);
        console.log("alloc_set response:", alloc);
        const outputBasePath = normalizeAllocOutputBasePath(alloc);
        if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

        // Prefer server-provided setN, but fall back to parsing from outputBasePath
        let setN = alloc?.setN ?? alloc?.set_n;
        if (setN == null) {
          const m = outputBasePath.match(/\/Set_(\d+)\b/);
          if (m) setN = Number(m[1]);
        }

        // Save current set context for per-slot Redo
        CURRENT_SET = { category, outputBasePath, setN };

        const charmLatest = await listLatestFile(newCharmsPath());
        if (!charmLatest) throw new Error("No files in listing-generator-1/New_Charms/");

        const manifest = {
          category,
          setN,
          outputBasePath,
          timestamp: new Date().toISOString(),
          slots: [],
          model: "gemini-3-pro-image-preview",
        };

        // 1) Resolve all slot sources up front (Storage-only; no Gemini calls here)
        setStatus("Preparing slots…");
        const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
          const srcFolder = slotRefFolder(category, spec.folder);
          const srcLatest = await listLatestFile(srcFolder);
          if (!srcLatest) throw new Error(`No files in ${srcFolder}/`);
          return { spec, i, slotNum: i + 1, srcLatest };
        }));

        // 2) Render all slot cards immediately
        gridEl.innerHTML = "";
        for (const r of slotResolved) {
          const { spec, i, slotNum, srcLatest } = r;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          // Add data-slot-index for easier selection
          slotCard.dataset.slotIndex = i; 
          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Queued…</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" disabled onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        }

        setStatus("Starting background run…");

        // 3) Construct Tasks Object
        const tasks = slotResolved.map((r) => {
          const { spec, i, slotNum, srcLatest } = r;
          if (spec.type === "copy") {
            return {
              type: "copy",
              slotIndex: i,
              source_storage_path: srcLatest.fullPath,
            };
          }
          return {
            type: "edits",
            slotIndex: i,
            input_storage_path: srcLatest.fullPath,
            input_charm_storage_path: charmLatest.fullPath,
            prompt: buildSlotPrompt(category, spec.folder, slotNum),
            model: "gemini-3-pro-image-preview",
          };
        });

        // ---------------------------------------------------------
        // FIX: Decouple Trigger and Polling
        // ---------------------------------------------------------

        // A. Start Polling Logic (Wait for images to appear in Storage)
        // We start this PROMISE immediately, but await it later.
        const pollingPromise = Promise.all(slotResolved.map(async (r) => {
          const { spec, i, slotNum, srcLatest } = r;
          const prevBox = document.getElementById(`slotPrev_${i}`);
          const setImg = (url) => { if (prevBox) prevBox.innerHTML = `<img src="${url}" />`; };

          // Wait for the file to appear
          const waited = await waitForSlotPngUrl(outputBasePath, i);
          
          // cache-bust so the preview updates even if the filename is overwritten
          const finalUrl = `${waited.url}${waited.url.includes("?") ? "&" : "?"}cb=${Date.now()}`;
          setImg(finalUrl);

          return {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcLatest.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waited.storagePath,
          };
        }));

        // B. Fire the Trigger (Send request to server)
        // Do NOT await this here. We let it run in the background.
        // We catch errors so they don't block the polling (if the server is working but the response is lost).
        postJson(GEMINI_BG_FN, {
           kind: "run_set_async",
           activeCategory: category,
           output_base_path: outputBasePath,
           delayMs: 4000, // 4.0s spacing between Gemini slot submissions
           tasks,
        }).then(res => {
            console.log("Background run triggered successfully", res);
        }).catch(err => {
            console.error("Background run trigger warning:", err);
            setStatus(`Trigger sent (with warning: ${err.message})`);
        });

        setStatus("Generating… (Monitoring Storage)");

        // C. Wait for Polling to finish (This confirms images are created)
        const results = await pollingPromise;
        
        // Sort results to match manifest order
        results.sort((a, b) => a.slot - b.slot);
        manifest.slots = results;

        setStatus("Writing manifest…");
        await postJson("geminiImageProxy", {
          kind: "write_manifest",
          activeCategory: category,
          output_base_path: outputBasePath,
          manifest,
        });

        setStatus(`Done → ${category}/Ready_To_List/Set_${setN}`);
        // Now that the set is done, enable per-slot Redo buttons
        setAllRedoEnabled(true);
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      } finally {
        setBusy(false);
      }
    }

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1–8)
    // ------------------------------------------------------------



    
    // =========================================================================
    // 0. BEADY_NECKLACE
    // =========================================================================

    const SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    • Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;






    // =========================================================================
    // 1. // REGULAR NECKLACE
    // =========================================================================
    const REGULAR_SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const REGULAR_SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    • Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

  



    // =========================================================================
    // 2. // BRACELET PROMPTS
    // =========================================================================
    const BRACELET_MODEL_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing bracelet chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model's wrist or arm.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;
    
    const BRACELET_CREATIVE_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing bracelet chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;
    
    const BRACELET_SIZE_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any bracelet chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;
    
    const BRACELET_ENGRAVING_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver bracelet charm is the backside of the gold bracelet chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;
    
    const BRACELET_SEC_MODEL_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing bracelet chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model's wrist or arm.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const BRACELET_PRODUCT_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    • Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing bracelet chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;





    // =========================================================================
    // 3. // STUD EARRINGS PROMPTS
    // =========================================================================
    const STUD_MODEL_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • When several charms are present on the model ear then only replace the charm on the lower Lobe of the ear.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The earring Charm must be gold colour, do not saturate the Earring Charm gold colour.
    • The earrings must remain exactly the same size and detail as reference image.

    HARD LOCKS (ABSOLUTE)
    • Never render the full face or profile—ear-only framing.
    • Do not zoom out or change camera perspective.
    • Do not change lighting direction, intensity, or environment.
    • Do not redraw, simplify, or reinterpret the charm geometry.
    • Focus on 100% engraving accuracy relative to the Reference Charm Image.
    • Output one photorealistic image only.
    • Do not output text.

      HARD LOCK: Never render female model above the neck and below the bust.
      HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
      DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
      Focus on Charm Engraving details and ensure 100% accuracy to Charm Image`;

    const STUD_CREATIVE_PROMPT =
    `(PRODUCT PHOTO — AI BACKGROUND, MICRO DETAIL PRESERVATION)
    • Replace both stud earring charms with the Reference Earring Charm (left and right earrings).
    • The charm must be rendered as a perfectly flat, ultra-thin metal sheet.
    • Preserve the Earring studs, the earring studs must be clearly visible exactly like in th ereference image.
    • Always render the earring leaning  on the earring studs.
    • DO NOT add earring backings, never render earring backings.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The earring Charm must be gold colour, do not saturate the Earring Charm gold colour.
    • The earrings must remain exactly the same size and detail as reference image.

    HARD LOCKS (ABSOLUTE)
    Keep the size/scaling of the generated stud earrings the same as the refernce image. 
    • Do not output text.`;

    const STUD_SIZE_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any earring part, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~8mm x 8mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const STUD_SEC_MODEL_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • When several charms are present on the model ear then only replace the charm on the lower Lobe of the ear.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The earring Charm must be gold colour, do not saturate the Earring Charm gold colour.
    • The earrings must remain exactly the same size and detail as reference image.

    HARD LOCKS (ABSOLUTE)
    • Never render the full face or profile—ear-only framing.
    • Do not zoom out or change camera perspective.
    • Do not change lighting direction, intensity, or environment.
    • Do not redraw, simplify, or reinterpret the charm geometry.
    • Focus on 100% engraving accuracy relative to the Reference Charm Image.
    • Output one photorealistic image only.
    • Do not output text.

      HARD LOCK: Never render female model above the neck and below the bust.
      HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
      DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
      Focus on Charm Engraving details and ensure 100% accuracy to Charm Image`;

    const STUD_PRODUCT_PROMPT =
    `(PRODUCT PHOTO — WHITE BACKGROUND, MICRO DETAIL PRESERVATION)
    • Replace both stud earring charms with the Reference Earring Charm (left and right earrings).
    • The charm must be rendered as a perfectly flat, ultra-thin metal sheet.
    • Preserve the Earring studs, the earring studs must be clearly visible exactly like in th ereference image.
    • Always render the earring leaning  on the earring studs.
    • DO NOT add earring backings, never render earring backings.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The earring Charm must be gold colour, do not saturate the Earring Charm gold colour.
    • The earrings must remain exactly the same size and detail as reference image.

    BACKGROUND + COMPOSITION
    • Background must remain pure white or near-white, clean and uncluttered.
    • No texture, gradients, props, or environmental elements.
    • Do not change framing, orientation, or spacing of the earrings relative to the reference image.

    HARD LOCKS (ABSOLUTE)
    • Do not output text.`;



    // =========================================================================
    // 4. // HOOP EARRINGS PROMPTS
    // =========================================================================
    const HOOP_MODEL_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 11 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image as a charm sliding on the hoop.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model's ear and face profile.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const HOOP_CREATIVE_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing hoop earring in the reference image as a charm on the hoop.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const HOOP_SIZE_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any hoop earring, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const HOOP_SEC_MODEL_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image as a charm sliding on the hoop.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model's ear.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const HOOP_PRODUCT_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    • Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing hoop earring in the reference image as a charm on the hoop.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;



    // =========================================================================
    // 5. // CHARM ONLY PROMPTS 
    // =========================================================================
    const CHARM_TEMPLATE_PROMPT = 
    `TASK: Create a pure white background product shot of the Charm.
    • Use the Charm Image as the absolute source of truth for the shape, engraving, and cutouts.
    • The output must be a high-resolution, sharp product image on #FFFFFF background.
    • Flatten the charm logic: It must look like a flat metal sheet.
    • Ensure the jump ring is visible and aligned at the top.`;

    const CHARM_TYPES_PROMPT = 
    `TASK: Create a composite view of the Charm variations if applicable, or a stylized macro shot.
    • Keep the charm flat and metallic.
    • Focus on the engraving details from the Charm Image.`;
    
    // Explicitly expanded to avoid variable dependency
    const CHARM_MODEL_PROMPT = 
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    // Explicitly expanded to avoid variable dependency
    const CHARM_ENGRAVING_PROMPT = 
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    // Explicitly expanded to avoid variable dependency
    const CHARM_HOOP_GUIDE_PROMPT = 
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any hoop earring, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    // Explicitly expanded to avoid variable dependency
    const CHARM_SIZE_GUIDE_PROMPT = 
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task. This must be a single-pass edit.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;


    // =========================================================================
    // 3. MASTER MAPPING
    // =========================================================================

    const PROMPT_MAPS = {
      // 1. Regular_Necklace (Uses identical prompts to Beady)
      "Regular_Necklace": {
        1: REGULAR_DEFAULT_PROMPT,
        2: REGULAR_SLOT2_DUPLICATE_PROMPT,
        3: REGULAR_SLOT3_SIZING_GUIDE_PROMPT,
        4: REGULAR_SLOT4_PROMPT,
        5: REGULAR_SLOT5_PROMPT,
        7: REGULAR_SLOT7_PROMPT
      },
      // 2. Beady_Necklace (Original)
      "Beady_Necklace": {
        1: DEFAULT_PROMPT,
        2: SLOT2_DUPLICATE_PROMPT,
        3: SLOT3_SIZING_GUIDE_PROMPT,
        4: SLOT4_PROMPT,
        5: SLOT5_PROMPT,
        7: SLOT7_PROMPT
      },
      // 3. Stud_Earrings
      "Stud_Earrings": {
        1: STUD_MODEL_PROMPT,
        2: STUD_CREATIVE_PROMPT,
        3: STUD_SIZE_GUIDE_PROMPT,
        4: STUD_PRODUCT_PROMPT,
        5: STUD_SEC_MODEL_PROMPT,
        6: STUD_PRODUCT_PROMPT // Mapped to Slot 6 in SLOT_MAP
      },
      // 4. Hoop_Earrings
      "Hoop_Earrings": {
        1: HOOP_MODEL_PROMPT,
        2: HOOP_CREATIVE_PROMPT,
        3: HOOP_SIZE_GUIDE_PROMPT,
        4: HOOP_PRODUCT_PROMPT, 
        5: HOOP_SIZE_GUIDE_PROMPT, // Slot 5 is "Hoop_Size_Guide"
        6: HOOP_SEC_MODEL_PROMPT,
        7: HOOP_PRODUCT_PROMPT
      },
      // 5. Charms
      "Charms": {
        1: CHARM_TEMPLATE_PROMPT,
        2: CHARM_TYPES_PROMPT,
        3: CHARM_MODEL_PROMPT,
        4: CHARM_ENGRAVING_PROMPT,
        5: CHARM_HOOP_GUIDE_PROMPT,
        6: CHARM_SIZE_GUIDE_PROMPT
      },
      // 6. Bracelets
      "Bracelets": {
        1: BRACELET_MODEL_PROMPT,
        2: BRACELET_CREATIVE_PROMPT,
        3: BRACELET_SIZE_GUIDE_PROMPT,
        4: BRACELET_ENGRAVING_PROMPT,
        5: BRACELET_SEC_MODEL_PROMPT,
        7: BRACELET_PRODUCT_PROMPT
      }
    };

    function buildSlotPrompt(category, folderName, slotNum) {
      // Look up the specific map for this category
      const map = PROMPT_MAPS[category];
      
      // If we have a map and a specific prompt for this slot, use it.
      if (map && map[slotNum]) {
        return map[slotNum];
      }
      
      // Fallback to default (Beady style) if category or slot undefined
      // This preserves existing behavior for unknown inputs.
      const DEFAULT_MAP = PROMPT_MAPS["Beady_Necklace"];
      return DEFAULT_MAP[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
  </script>
</body>
</html>