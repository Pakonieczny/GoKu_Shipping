<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
      text-align:center;
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    
    /* === UPDATED SLOT PREVIEW STYLES (Zoom/Grid support) === */
    .slotPrev {
      width:100%; 
      height:190px; 
      border-radius:12px; 
      border:1px solid var(--line); 
      background:#0b0d12; 
      overflow:hidden; /* Critical for cropping zoom */
      position: relative; /* Anchor for grid overlay */
    }
    
    .slotPrev img { 
      width:100%; 
      height:100%; 
      object-fit:contain; 
      transform-origin:center center; 
      transition: transform 0.3s ease; /* Smooth zoom transition */
      display: block;
      cursor: grab;
    }
    
    .slotPrev img:active {
      cursor: grabbing;
    }

    /* Rule-of-thirds overlay (from Index.html) */
    .slotPrev::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 700; 

      /* four thin lines at 1/3 and 2/3 */
      background-image:
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25));
      background-size: 1px 100%, 1px 100%, 100% 1px, 100% 1px;
      background-position: 33.333% 0, 66.666% 0, 0 33.333%, 0 66.666%;
      background-repeat: no-repeat;
    }

    /* Success border style */
    .slotPrev.success-border {
      border: 3px solid lightgreen !important;
    }

    /* Visual feedback for working state */
    .working-box {
      border: 2px solid #fdba74 !important;
      opacity: 0.7;
      animation: pulse 1.5s infinite;
    }
    .working-card {
      border: 2px solid #fdba74 !important;
      transition: all 0.3s ease;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

    /* === CHARM MAKER QUAD LAYOUT === */
    .charm-card {
      background: #0e1220; 
      border: 1px solid var(--line); 
      border-radius: 14px; 
      padding: 14px;
      grid-column: span 2; /* takes 2 columns out of 4 */
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 14px;
    }
    .charm-card-title { 
      grid-column: span 2; 
      font-size: 14px; 
      color: #7fdb96; 
      border-bottom: 1px solid var(--line); 
      padding-bottom: 8px; 
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .charm-col { 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
    }
    .charm-col .muted { margin-bottom: 0; }

    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    /* === SPINNER & BUTTON GUARDS === */
    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid rgba(255,255,255,0.1);
      border-radius: 50%;
      border-top-color: #7fdb96;
      animation: spin 1s ease-in-out infinite;
      margin: 0 auto 6px auto;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    .spinner-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      color: #fdba74;
      font-size: 11px;
    }
    
    /* We use pointer-events: none to fully kill clicks while disabled */
    button.disabled-action {
      background: #1a1e2b !important;
      border-color: #2a3143 !important;
      color: #5b637a !important;
      cursor: not-allowed !important;
      pointer-events: none !important;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Listing-Generator-1</h1>

      <div class="row" style="margin-bottom: 14px; background: #0e1220; padding: 4px; border-radius: 12px; border: 1px solid var(--line);">
        <button class="btn" id="toggleGenerate" style="flex:1; background: var(--line); border:none; color: var(--text);">Generate</button>
        <button class="btn" id="toggleReview" style="flex:1; background: transparent; border:none; color: var(--muted);">Review</button>
        <button class="btn" id="toggleCharmMaker" style="flex:1; background: transparent; border:none; color: var(--muted);">Charm Maker</button>
        <button class="btn" id="toggleApprovedCharms" style="flex:1; background: transparent; border:none; color: var(--muted);">Approved Sets</button>
      </div>
      
      <div id="generateSection">
        <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>

        <label>Category (Storage source of truth)</label>
        <select id="activeCategory"></select>
        <div class="muted" style="margin-top:6px;">
          Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
          <br>
          <strong>Note:</strong> Stud/Hoop Earrings use <code>Charm_Maker/New_Charms_Earrings</code>. Others use <code>Charm_Maker/New_Charms</code>.
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="generateSet">Generate Set (Randomized Refs)</button>
        </div>

        <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
        <div id="panels"></div>

        <label style="margin-top:12px;">Shared Pool (Autoselected based on category)</label>
        <div id="panelNewCharms"></div>
      </div>

        <div id="reviewSection" style="display: none;">
        <label style="margin-top:12px;">Category</label>
        <select id="reviewCategory"></select>

        <label style="margin-top:12px;">Select Set to Review</label>
        <div class="row">
          <select id="reviewSetSelect"></select>
        </div>
        
        <div class="row" style="margin-top:10px;">
           <button class="btn" id="approveSetBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Approve Set (Move to Completed)</button>
        </div>
        
        <div class="row" style="margin-top:10px;">
           <button class="btn" id="deleteSetBtn" style="width:100%; background: #3d1c1c; color: #fca5a5; border: 1px solid #7a3838;">Delete Set</button>
        </div>
        
        <div class="row" style="margin-top: 10px; justify-content: space-between; align-items: center; background: #0e1220; padding: 10px; border-radius: 12px; border: 1px solid var(--line);">
           <div id="completedSetsCounter" style="font-size: 13px; color: #7fdb96;">
             Completed Sets Available: <span style="font-weight: bold; font-size: 15px;">0</span>
           </div>
           <button class="btn" id="downloadCompletedSetsBtn" style="background: #2b6cff; color: #fff; border: 1px solid #1a4bbf; font-weight: bold; font-size: 12px; padding: 6px 12px;">Download Sets (ZIP)</button>
        </div>

        <div class="row" style="margin-top: 8px; justify-content: space-between; align-items: center; background: #0b0d12; padding: 10px; border-radius: 12px; border: 1px dashed #3a4262;">
           <div>
               <div style="font-size: 12px; color: var(--muted);">Permanent Storage:</div>
               <div id="totalAllTimeCounter" style="font-size: 13px; color: #a5b4fc; font-weight: bold;">
                 Total Approved (All Time): <span>0</span>
               </div>
           </div>
           <button class="btn" id="downloadPermanentSetsBtn" style="background: #3a4262; color: #fff; border: 1px dashed #5c6792; font-weight: bold; font-size: 12px; padding: 6px 12px;">Download All (ZIP)</button>
        </div>
        
        <div style="margin-top: 8px; font-size: 11px; color: var(--muted);" id="backgroundQueueStatus"></div>
      </div> 
      
      <div id="charmMakerSection" style="display: none;">
        <div class="row" style="margin-top:12px; gap: 14px;">
          <div style="flex:1;">
            <label style="display: flex; justify-content: space-between; align-items: center;">
              New_Charms (Next Available)
              <span id="newCharmsTotalCount" style="color: #7fdb96; font-weight: bold; background: #1f4026; padding: 4px 8px; border-radius: 6px; border: 1px solid #2f5e3a;">Count: Loading...</span>
            </label>
            <div class="slotPrev" id="previewNewCharms" style="height: 380px;"><div class="slotRefEmpty">Loading...</div></div>
          </div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn" id="executeCharmGenBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Generate Charms</button>
        </div>

        <div class="row" style="margin-top:14px; gap:14px;">
           <div style="flex:1; background: #0e1220; padding: 12px; border-radius: 12px; border: 1px solid var(--line);">
              <label style="margin-top:0;">Amount of Charm images to process simultaneously:</label>
              <div class="row" style="margin-top:8px;">
                 <select id="batchProcessCount" style="width: 80px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                 </select>
                 <input type="number" id="batchProcessCountInput" value="1" min="1" style="flex:1;" placeholder="Count...">
              </div>
           </div>
           
           <div style="flex:1; background: #0e1220; padding: 12px; border-radius: 12px; border: 1px solid var(--line);">
              <label style="margin-top:0;">Derivatives per Charm (Times same charm is used):</label>
              <div class="row" style="margin-top:8px;">
                 <select id="derivativesPerCharm" style="width: 80px;">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                 </select>
                 <input type="number" id="derivativesPerCharmInput" value="1" min="1" style="flex:1;" placeholder="Count...">
              </div>
           </div>
        </div>

      </div> 
    </div> 
    
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;" id="mainGridTitle">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      
      <div id="approvedSetsHeader" style="display: none; justify-content: space-between; align-items: center; margin-top: 10px; margin-bottom: 10px;">
        <div id="approvedSetsCounter" style="font-size: 13px; color: #7fdb96; background: #1f4026; padding: 8px 12px; border-radius: 8px; border: 1px solid #2f5e3a; width: max-content;">
          Total Approved Sets: <span style="font-weight: bold; font-size: 15px;">0</span>
        </div>
        <button class="btn" id="downloadApprovedSetsBtn" style="background: #2b6cff; color: #fff; border: 1px solid #1a4bbf; font-weight: bold;">Download Sets (ZIP)</button>
      </div>

      <div class="grid" id="generateGrid"></div>
      <div class="grid" id="reviewGrid" style="display: none;"></div>
      
      <div class="grid" id="charmGrid" style="display: none;"></div>
      <div class="grid" id="approvedCharmGrid" style="display: none;"></div>
      
      <div id="charmPagination" class="row" style="display: none; justify-content: space-between; align-items: center; margin-top: 14px; padding: 10px; background: #0e1220; border-radius: 12px; border: 1px solid var(--line);">
          <button class="btn btnSmall" id="charmPrevPage" style="width: 80px;">Previous</button>
          <div id="charmPageInfo" class="muted">Page 1</div>
          <button class="btn btnSmall" id="charmNextPage" style="width: 80px;">Next</button>
      </div>

      <div id="approvedCharmPagination" class="row" style="display: none; justify-content: space-between; align-items: center; margin-top: 14px; padding: 10px; background: #0e1220; border-radius: 12px; border: 1px solid var(--line);">
          <button class="btn btnSmall" id="approvedPrevPage" style="width: 80px;">Previous</button>
          <div id="approvedPageInfo" class="muted">Page 1</div>
          <button class="btn btnSmall" id="approvedNextPage" style="width: 80px;">Next</button>
      </div>
    </div>
  </div> 

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, getBytes, listAll, getMetadata, deleteObject } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    let originStr = window.location.origin;
    if (!originStr || originStr === "null" || window.location.protocol === "file:") {
      originStr = "https://listing-generator-1.goldenspike.app"; 
    }
    const functionsBaseUrl = `${originStr}/.netlify/functions`;

    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "Charm_Maker/New_Charms",           // UPDATED
      "Charm_Maker/New_Charms_Earrings",  // UPDATED
      "Charm_Maker/Generated_Charm_Sets", 
    ];

    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Product_Shots_2",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],

      Hoop_Earrings: [
        "Hoop_Earring_Models","Hoop_Earring_Sec_Models","Hoop_Charm_Dimensions","Hoop_Metal_Options","Hoop_Size_Options","Hoop_Model_Size_Guide","Hoop_Earring_Care_Guide","Hoop_Primary_Product","Ready_To_List","Completed_&_Listed_Sets" 
      ],

      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      "Charm_Maker/New_Charms": [],          // UPDATED
      "Charm_Maker/New_Charms_Earrings": [], // UPDATED
      "Charm_Maker/Generated_Charm_Sets": [], 
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots_2" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Hoop_Earring_Models" },       // Slot 1
        { type:"gen", folder:"Hoop_Primary_Product" },      // Slot 2
        { type:"gen", folder:"Hoop_Size_Options" },         // Slot 3
        { type:"gen", folder:"Hoop_Earring_Sec_Models" },   // Slot 4       
        { type:"gen", folder:"Hoop_Charm_Dimensions" },     // Slot 5
        { type:"copy", folder:"Hoop_Model_Size_Guide" },    // Slot 6
        { type:"gen", folder:"Hoop_Metal_Options" },        // Slot 7 
        { type:"copy", folder:"Hoop_Earring_Care_Guide" },  // Slot 8
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Care_Metal_Guide" },
      ],
    };

    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth ✔", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth ❌", e);
    }

    window.db = firebase.firestore();

    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

// Updated sleep to support AbortSignal
    function sleep(ms, signal) { 
      return new Promise((resolve, reject) => {
        if (signal && signal.aborted) return reject(new Error("AbortError"));
        const timeout = setTimeout(resolve, ms);
        if (signal) {
          signal.addEventListener('abort', () => {
            clearTimeout(timeout);
            reject(new Error("AbortError"));
          }, { once: true });
        }
      }); 
    }
    
    function attachPreviewBoxListeners(box) {
      function clampAndApply(img, scale, offX, offY) {
        const viewportW = box.clientWidth || 120;
        const viewportH = box.clientHeight || 120;
        const baseW = img.clientWidth || 120;   
        const baseH = img.clientHeight || 120;
        const scaledW = baseW * scale;
        const scaledH = baseH * scale;

        const maxX = Math.max(0, (scaledW - viewportW) / 2 / scale);
        const maxY = Math.max(0, (scaledH - viewportH) / 2 / scale);

        offX = Math.max(-maxX, Math.min(maxX, offX));
        offY = Math.max(-maxY, Math.min(maxY, offY));

        img.dataset.scale = scale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY; 
        img.style.transform = `scale(${scale}) translate(${offX}px, ${offY}px)`;
      }

      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0, dragStartY = 0;
      let lastX = 0, lastY = 0;
      const dragThreshold = 3;
      const MAX_SCALE = 8;
      
      if (typeof ResizeObserver !== "undefined") {
        const ro = new ResizeObserver(() => {
          const img = box.querySelector("img");
          if (!img) return;
          const s = parseFloat(img.dataset.scale) || 1;
          let offX = parseFloat(img.dataset.offsetX) || 0;
          let offY = parseFloat(img.dataset.offsetY) || 0; 
          clampAndApply(img, s, offX, offY);
        });
        ro.observe(box);
      }

      box.addEventListener("wheel", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;

        if (ev.deltaY < 0) {
          currentScale *= 1.1;            // zoom in
        } else {
          currentScale /= 1.1;            // zoom out
          if (currentScale <= 1) {        // snap back
            currentScale = 1;
            offX = 0; offY = 0;
          }
        }
        if (currentScale > MAX_SCALE) currentScale = MAX_SCALE;
        clampAndApply(img, currentScale, offX, offY);
      });

      box.addEventListener("mousedown", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;        
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX; dragStartY = ev.clientY;
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mousemove", function (ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;

        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = (ev.clientX - lastX) * 0.5;
        const dy = (ev.clientY - lastY) * 0.5;
        offX += dx; offY += dy;
        clampAndApply(img, scaleNow, offX, offY);
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mouseup",   () => { isMouseDown = false; });
      box.addEventListener("mouseleave",() => { isMouseDown = false; });

      box.addEventListener("click", function (ev) {
        if (isDragging) { isDragging = false; return; }
        const img = box.querySelector("img");
        if (!img) return;

        const s0    = parseFloat(img.dataset.scale)   || 1;
        const offX0 = parseFloat(img.dataset.offsetX) || 0;
        const offY0 = parseFloat(img.dataset.offsetY) || 0;

        const rect = box.getBoundingClientRect();
        const cx = rect.left + box.clientWidth  / 2;
        const cy = rect.top  + box.clientHeight / 2;
        const dx_screen = ev.clientX - cx;
        const dy_screen = ev.clientY - cy;

        const px = dx_screen / s0 - offX0;
        const py = dy_screen / s0 - offY0;

        let targetOffX = -px;
        let targetOffY = -py;

        const halfW = (img.clientWidth  || 120) / 2;
        const halfH = (img.clientHeight || 120) / 2;
        function requiredScaleFor(delta, half) {
          const ratio = Math.abs(delta) / half;     
          if (ratio >= 1) return Infinity;          
          return 1 / (1 - ratio);                   
        }
        const needX = requiredScaleFor(targetOffX, halfW);
        const needY = requiredScaleFor(targetOffY, halfH);

        const DESIRED = 1.33;                          
        let s1 = Math.max(DESIRED, s0 * 1.5, needX, needY);
        if (!Number.isFinite(s1)) s1 = MAX_SCALE;
        if (s1 > MAX_SCALE) s1 = MAX_SCALE;
        
        if (s0 > 1.2 && Math.abs(s1 - s0) < 0.5) s1 = 1; 

        clampAndApply(img, s1, targetOffX, targetOffY);
      });
    }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 1200000); 
      const intervalMs = Number(opts.intervalMs ?? 5000);   
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);
      const signal = opts.signal; // Capture the abort signal

      // Check if already aborted before starting
      if (signal && signal.aborted) throw new Error("AbortError");

      await sleep(Math.random() * 3000, signal); 

      const t0 = Date.now();
      while (true) {
        // Exit loop if cancellation is requested
        if (signal && signal.aborted) throw new Error("AbortError");

        await ensureStorageSignedIn();

        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (!String(e2?.message || e2).includes("slot_not_updated_yet")) {
                   // keep waiting
                }
                throw e2;
              }
            }

            try {
              const url = await getDownloadURL(hit);
              return { storagePath: hit.fullPath, url };
            } catch (eUrl) {
              const msg = String(eUrl?.message || eUrl);
              const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");

              if (looksUnauthorized) {
                throw new Error(`Cannot download ${hit.fullPath} (permission/token issue).`);
              }
              throw eUrl;
            }
          }
        } catch (e) {
          const msg = String(e?.message || e);
          if (msg.includes("500") || msg.includes("internal")) {
             console.warn("Storage 500 error, retrying with backoff...", outputBasePath);
             await sleep(5000, signal); 
          } else {
             const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");
             if (looksUnauthorized) {
                throw new Error(`Storage rules block LIST on: ${outputBasePath}`);
             }
          }
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs, signal);
      }
    }

// --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const generateGrid = document.getElementById("generateGrid");
    const reviewGrid = document.getElementById("reviewGrid");
    const charmGrid = document.getElementById("charmGrid");
    const approvedCharmGrid = document.getElementById("approvedCharmGrid"); // NEW
    const statusEl = document.getElementById("status");
    const charmPaginationEl = document.getElementById("charmPagination");
    const approvedCharmPaginationEl = document.getElementById("approvedCharmPagination"); // NEW

    let approvedSetsHistory = []; // NEW
    let approvedCurrentPage = 1;  // NEW

    // --- UI Helper Functions for Spinners and Button Locks ---
    window.getSpinnerHTML = function(msg) {
        return `<div class="spinner-container"><div class="spinner"></div><div style="margin-top: 8px;">${msg}</div></div>`;
    };

    window.setQuadButtonsState = function(folderId, disabled) {
        const cardObj = document.getElementById(`card_${folderId}`);
        if (!cardObj) return;
        
        // Target the action row at the bottom of the card
        const actionRow = cardObj.querySelector('.row:last-child');
        if (actionRow) {
            const btns = actionRow.querySelectorAll('button');
            btns.forEach(btn => {
                btn.disabled = disabled;
                if (disabled) {
                    btn.classList.add('disabled-action');
                } else {
                    btn.classList.remove('disabled-action');
                }
            });
        }
    };

    window.updateQuadActionButtons = function(folderId) {
        let isBusy = false;
        if (window.ACTIVE_CHARM_JOBS) {
            for (let i = 0; i < 4; i++) {
                if (window.ACTIVE_CHARM_JOBS.has(`${folderId}_${i}`)) {
                    isBusy = true;
                    break;
                }
            }
        }
        window.setQuadButtonsState(folderId, isBusy);
    };

    // --- Mode Variables ---
    const toggleGenerateBtn = document.getElementById("toggleGenerate");
    const toggleReviewBtn = document.getElementById("toggleReview");
    const toggleCharmMakerBtn = document.getElementById("toggleCharmMaker");
    const toggleApprovedCharmsBtn = document.getElementById("toggleApprovedCharms");
    const generateSection = document.getElementById("generateSection");
    const reviewSection = document.getElementById("reviewSection");
    const charmMakerSection = document.getElementById("charmMakerSection");
    const reviewSetSelect = document.getElementById("reviewSetSelect");
    const approveSetBtn = document.getElementById("approveSetBtn"); 
    const deleteSetBtn = document.getElementById("deleteSetBtn"); // <--- ADD THIS
    const backgroundQueueStatus = document.getElementById("backgroundQueueStatus"); 
    let appMode = "generate"; 

    function setStatus(msg){ statusEl.textContent = msg; }

    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
    }

    let CURRENT_SET = null; 
    const REDO_STATE = {}; 

    function setAllRedoEnabled(enabled){
      document.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex, prefix = 'gen'){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet.");
      }

      const ctxSetPath = CURRENT_SET.outputBasePath;
      const ctxCategory = CURRENT_SET.category;
      const ctxSetN = CURRENT_SET.setN;
      
      const slotPlan = SLOT_MAP[ctxCategory];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex}`);
      
      const redoKey = `${ctxSetPath}::${slotIndex}`;

      REDO_STATE[redoKey] = { status: 'running' };
      updateDropdownLabels(); 
      updateApproveButtonState(); 

      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${ctxSetPath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {}

      const isViewing = (CURRENT_SET?.outputBasePath === ctxSetPath);
      
      if (isViewing) {
          const targetGrid = prefix === 'gen' ? generateGrid : reviewGrid;
          const slotCard = targetGrid.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
          const prevBox  = document.getElementById(`${prefix}_slotPrev_${slotIndex}`);
          const redoBtn  = document.getElementById(`${prefix}_redo_${slotIndex}`);
          
          if (redoBtn) redoBtn.disabled = true;
          if (prevBox) {
              prevBox.innerHTML = `<div class="slotRefEmpty">Working…</div>`;
              prevBox.classList.remove("success-border"); 
          }
          setStatus(`Redo Slot ${slotIndex + 1}…`);
      }

      const srcFolder = slotRefFolder(ctxCategory, spec.folder);
      const srcRandom = await listRandomFile(srcFolder); 
      if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);

      const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(ctxCategory);
      const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
      const charmLatest = await listLatestFile(charmFolderPath); 
      if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);
      
      let waitedResult = null; 

      try {
          if (spec.type === "copy") {
            const r = await postJson(GEMINI_FN, {
              kind: "copy_to_slot",
              activeCategory: ctxCategory,
              source_storage_path: srcRandom.fullPath, 
              output_base_path: ctxSetPath,
              slotIndex,
            });

            waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          } else {
            await postJson(GEMINI_BG_FN, {
              kind: "edits",
              activeCategory: ctxCategory,
              input_storage_path: srcRandom.fullPath, 
              input_charm_storage_path: charmLatest.fullPath,
              output_base_path: ctxSetPath,
              slotIndex,
              model: "gemini-3.1-flash-image-preview",
              prompt: buildSlotPrompt(ctxCategory, spec.folder, slotIndex + 1),
            });

              waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          }
          
      const finalUrl = cacheBust(waitedResult.url);
          REDO_STATE[redoKey] = { status: 'completed', url: finalUrl };
          updateDropdownLabels(); 
          updateApproveButtonState();

          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
              const targetGrid = prefix === 'gen' ? generateGrid : reviewGrid;
              const slotCard = targetGrid.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
              const prevBox  = document.getElementById(`${prefix}_slotPrev_${slotIndex}`);
              const metaEl   = document.getElementById(`${prefix}_slotMeta_${slotIndex}`);
              const redoBtn  = document.getElementById(`${prefix}_redo_${slotIndex}`);
              
              if (prevBox) {
                  // Instant Cache Write
                  const newBlob = await fetchAndCacheBlob(waitedResult.url, waitedResult.storagePath, Date.now());
                  setBoxImage(prevBox, newBlob ? URL.createObjectURL(newBlob) : finalUrl);
                  prevBox.classList.add("success-border"); 
              }
              if (metaEl) metaEl.textContent = `Source: ${srcRandom.fullPath}`;
              if (redoBtn) redoBtn.disabled = false;
              setStatus(`Ready (Set_${ctxSetN})`);
          }

      } catch(err) {
          console.error("Redo failed", err);
          delete REDO_STATE[redoKey];
          updateDropdownLabels();
          updateApproveButtonState(); 
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
             const prevBox = document.getElementById(`${prefix}_slotPrev_${slotIndex}`);
             if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Error</div>`;
             setStatus("Redo failed: " + err.message);
          }
      }

      try {
        const manifestRef = ref(storage, `${ctxSetPath}/manifest.json`);
        const buffer = await getBytes(manifestRef);
        const text = new TextDecoder().decode(buffer);
        const manifestJson = JSON.parse(text);

        const slotNum = slotIndex + 1;
        const idx = manifestJson.slots.findIndex(s => s.slot === slotNum);
        
        const newEntry = {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcRandom.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waitedResult?.storagePath || "",
            updatedAt: new Date().toISOString()
        };

        if (idx > -1) {
            manifestJson.slots[idx] = { ...manifestJson.slots[idx], ...newEntry };
        } else {
            manifestJson.slots.push(newEntry);
            manifestJson.slots.sort((a,b) => a.slot - b.slot);
        }

            await postJson("geminiImageProxy", {
                kind: "write_manifest",
                activeCategory: ctxCategory, // <--- CHANGED FROM "Charm_Maker"
                output_base_path: ctxSetPath, // <--- CHANGED FROM outputBasePath
                manifest: manifestJson, // <--- CHANGED FROM manifest
            });
      } catch (e) {
        console.warn("Manifest update failed (non-fatal):", e);
      }
    }
    
    window.redoSlot = redoSlot;

    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/Charm_Maker/New_Charms`; // UPDATED
    }

    function newCharmsEarringsPath() {
      return `${ROOT}/Charm_Maker/New_Charms_Earrings`; // UPDATED
    }
    async function listRandomFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      
      if (!res.items?.length) return null;

      const randomIndex = Math.floor(Math.random() * res.items.length);
      const randomItem = res.items[randomIndex];
      const url = await getDownloadURL(randomItem);
      return { fullPath: randomItem.fullPath, name: randomItem.name, url };
    }

    async function listLatestFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    // Function to retrieve top N latest files from storage
    async function listTopNFiles(fullFolderPath, n) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return [];

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
          itemRef: it
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const topN = metas.slice(-n);
      const results = [];
      for (const item of topN) {
          const url = await getDownloadURL(item.itemRef);
          results.push({ fullPath: item.fullPath, name: item.name, url: url });
      }
      return results;
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loading…</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          console.warn("[Storage:listAll] failed", { targetFullPath, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading → ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      if (["Stud_Earrings", "Hoop_Earrings"].includes(category)) {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsEarringsPath(), "New_Charms_Earrings (Earrings Only)"));
      } else {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms (Necklaces/Other)"));
      }

      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);

    // --- Sync Review Category Dropdown ---
    const reviewCategoryEl = document.getElementById("reviewCategory");
    if (reviewCategoryEl) {
      reviewCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
      reviewCategoryEl.value = activeCategoryEl.value;

      reviewCategoryEl.addEventListener("change", () => {
        activeCategoryEl.value = reviewCategoryEl.value; // Sync back to main
        loadReviewSets();
        reviewGrid.innerHTML = "";
      });
    }

    // --- Tab Switching Logic ---

    // --- Tab Switching Logic ---

    // -------------------------------------------------------------------------
    // LOCAL BROWSER CACHING SYSTEM (IndexedDB)
    // -------------------------------------------------------------------------
    const CACHE_DB_NAME = "CharmMakerCache";
    const CACHE_STORE_NAME = "images";

    function openCacheDB() {
        return new Promise((resolve, reject) => {
            const req = indexedDB.open(CACHE_DB_NAME, 1);
            req.onupgradeneeded = (e) => {
                e.target.result.createObjectStore(CACHE_STORE_NAME, { keyPath: "path" });
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    }

    async function getCachedBlob(path) {
        try {
            const db = await openCacheDB();
            return new Promise((resolve) => {
                const tx = db.transaction(CACHE_STORE_NAME, "readonly");
                const req = tx.objectStore(CACHE_STORE_NAME).get(path);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve(null);
            });
        } catch(e) {
            console.warn("IndexedDB read error", e);
            return null;
        }
    }

    async function setCachedBlob(path, blob, updatedMs) {
        try {
            const db = await openCacheDB();
            return new Promise((resolve) => {
                const tx = db.transaction(CACHE_STORE_NAME, "readwrite");
                tx.objectStore(CACHE_STORE_NAME).put({ path, blob, updatedMs });
                tx.oncomplete = () => resolve();
                tx.onerror = () => resolve();
            });
        } catch(e) {
            console.warn("IndexedDB write error", e);
        }
    }

    async function removeCachedFolder(folderId) {
        try {
            const db = await openCacheDB();
            return new Promise((resolve) => {
                const tx = db.transaction(CACHE_STORE_NAME, "readwrite");
                const store = tx.objectStore(CACHE_STORE_NAME);
                const req = store.openCursor();
                req.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        if (cursor.value.path.includes(folderId)) cursor.delete();
                        cursor.continue();
                    } else {
                        resolve();
                    }
                };
            });
        } catch(e) {}
    }

    async function fetchAndCacheBlob(url, storagePath, updatedMs) {
        try {
            const res = await fetch(cacheBust(url), { mode: 'cors' });
            if (!res.ok) throw new Error("Network response not ok");
            const blob = await res.blob();
            await setCachedBlob(storagePath, blob, updatedMs);
            return blob;
        } catch (e) {
            console.error("Failed to fetch/cache blob:", e);
            return null;
        }
    }

// Helper to prevent memory leaks by revoking old blob URLs
    function setBoxImage(box, srcUrl) {
        if (!box) return;
        const oldImg = box.querySelector("img");
        if (oldImg && oldImg.src.startsWith("blob:")) {
            URL.revokeObjectURL(oldImg.src);
        }
        box.innerHTML = `<img src="${srcUrl}" />`;
        attachPreviewBoxListeners(box);
    }

    let currentCharmViewFolder = "Charm_Maker/Generated_Charm_Sets";

    function setAppMode(mode) {
      appMode = mode;
      
      toggleGenerateBtn.style.background = "transparent";
      toggleGenerateBtn.style.color = "var(--muted)";
      toggleReviewBtn.style.background = "transparent";
      toggleReviewBtn.style.color = "var(--muted)";
      toggleCharmMakerBtn.style.background = "transparent";
      toggleCharmMakerBtn.style.color = "var(--muted)";
      toggleApprovedCharmsBtn.style.background = "transparent";
      toggleApprovedCharmsBtn.style.color = "var(--muted)";
      
      generateSection.style.display = "none";
      reviewSection.style.display = "none";
      charmMakerSection.style.display = "none";
      charmPaginationEl.style.display = "none"; 
      
      // Hide all grids, don't clear them
      generateGrid.style.display = "none";
      reviewGrid.style.display = "none";
      charmGrid.style.display = "none";
      if (approvedCharmGrid) approvedCharmGrid.style.display = "none";
      if (approvedCharmPaginationEl) approvedCharmPaginationEl.style.display = "none";
      
      const mainGridTitle = document.getElementById("mainGridTitle");
      const approvedSetsHeader = document.getElementById("approvedSetsHeader");
      if (approvedSetsHeader) approvedSetsHeader.style.display = "none";

      if (mode === "generate") {
        mainGridTitle.textContent = "Generated set";
        toggleGenerateBtn.style.background = "var(--line)";
        toggleGenerateBtn.style.color = "var(--text)";
        generateSection.style.display = "block";
        generateGrid.style.display = "grid";
        renderCategoryUI(activeCategoryEl.value);
        setStatus("Ready");
      } else if (mode === "review") {
        mainGridTitle.textContent = "Review Queue";
        toggleReviewBtn.style.background = "var(--line)";
        toggleReviewBtn.style.color = "var(--text)";
        reviewSection.style.display = "block";
        reviewGrid.style.display = "grid";
        updateCompletedSetsCounter(); // <--- ADD THIS LINE HERE
        updateTotalAllTimeCounter();
        
        // Only load if empty to prevent wiping existing review state
        // Only load if empty to prevent wiping existing review state
        if (reviewSetSelect.options.length === 0 || reviewSetSelect.innerHTML.includes("Loading...")) {
            loadReviewSets();
        } else {
            setStatus("Review Queue");
        }
      } else if (mode === "charmMaker") {
        mainGridTitle.textContent = "Charm Maker Database";
        toggleCharmMakerBtn.style.background = "var(--line)";
        toggleCharmMakerBtn.style.color = "var(--text)";
        charmMakerSection.style.display = "block";
        charmGrid.style.display = "grid";
        setStatus("Charm Maker Database");
        
        loadCharmMakerPreviews(); // Always update the preview queue

        // ALWAYS fetch the latest list to auto-detect new generations
        loadCharmHistoryList("Charm_Maker/Generated_Charm_Sets"); 
      } else if (mode === "approvedCharms") {
        mainGridTitle.textContent = "Approved Charm Sets";
        if (approvedSetsHeader) approvedSetsHeader.style.display = "flex";
        toggleApprovedCharmsBtn.style.background = "var(--line)";
        toggleApprovedCharmsBtn.style.color = "var(--text)";
        charmMakerSection.style.display = "none"; 
        approvedCharmGrid.style.display = "grid"; // Target new grid
        setStatus("Approved Charm Sets");
        
        // ALWAYS fetch the latest list to auto-detect newly approved sets
        loadCharmHistoryList("Charm_Maker/Completed_Approved_Charm_Sets"); 
      }
    } 

    toggleGenerateBtn.addEventListener("click", () => setAppMode("generate"));
    toggleReviewBtn.addEventListener("click", () => setAppMode("review"));
    toggleCharmMakerBtn.addEventListener("click", () => setAppMode("charmMaker"));
    toggleApprovedCharmsBtn.addEventListener("click", () => setAppMode("approvedCharms"));

    activeCategoryEl.addEventListener("change", () => {
      if (reviewCategoryEl) reviewCategoryEl.value = activeCategoryEl.value; // Keep Review dropdown synced
      
      if (appMode === "generate") {
        renderCategoryUI(activeCategoryEl.value);
      } else if (appMode === "review") {
        loadReviewSets();
        reviewGrid.innerHTML = "";
      }
    });

    async function loadReviewSets() {
      const category = activeCategoryEl.value;
      setStatus("Loading sets...");
      reviewSetSelect.innerHTML = `<option>Loading...</option>`;
      try {
        await ensureStorageSignedIn();
        const readyToListRef = ref(storage, `${ROOT}/${category}/Ready_To_List`);
        const res = await listAll(readyToListRef);
        const sets = res.prefixes.map(p => p.name).filter(n => n.startsWith('Set_'));
        sets.sort((a, b) => {
          const numA = parseInt(a.replace('Set_', '')) || 0;
          const numB = parseInt(b.replace('Set_', '')) || 0;
          return numB - numA;
        });

        if (sets.length > 0) {
          reviewSetSelect.innerHTML = sets.map(s => `<option value="${s}">${s}</option>`).join("");
          setStatus(`Found ${sets.length} sets.`);
          updateDropdownLabels();
          if (reviewSetSelect.value) {
              loadSetImages(reviewSetSelect.value);
          }
        } else {
          reviewSetSelect.innerHTML = `<option value="">No sets found</option>`;
          setStatus("No sets found.");
          reviewGrid.innerHTML = "";
        }
      } catch (e) {
        console.error("Error loading sets:", e);
        setStatus("Error loading sets");
        reviewSetSelect.innerHTML = `<option value="">Error loading</option>`;
      }
    }

    async function updateCompletedSetsCounter() {
        const counterSpan = document.querySelector("#completedSetsCounter span");
        if (!counterSpan) return;
        try {
            await ensureStorageSignedIn();
            const folderPath = `${ROOT}/Generated_Listing_Sets/Completed_Listing_Sets`;
            const baseRef = ref(storage, folderPath);
            const res = await listAll(baseRef);
            counterSpan.textContent = res.prefixes.length; // Counting folders
        } catch (e) {
            console.warn("Failed to get completed sets count:", e);
            counterSpan.textContent = "Error";
        }
    }

async function updateTotalAllTimeCounter() {
        const totalCounterSpan = document.querySelector("#totalAllTimeCounter span");
        if (!totalCounterSpan) return;
        try {
            await ensureStorageSignedIn();
            
            // Get permanently stored approved sets ONLY
            const approvedFolder = `${ROOT}/Generated_Listing_Sets/Approved_Listing_Sets`;
            let approvedCount = 0;
            try {
                const approvedRes = await listAll(ref(storage, approvedFolder));
                approvedCount = approvedRes.prefixes.length;
            } catch(e) {
                console.warn("Could not read Approved folder:", e);
            }

            totalCounterSpan.textContent = approvedCount;
        } catch (e) {
            console.warn("Failed to get total all time sets count:", e);
            totalCounterSpan.textContent = "Error";
        }
    }
    
    function updateDropdownLabels() {
        if(appMode !== "review") return;
        const category = activeCategoryEl.value;
        const options = Array.from(reviewSetSelect.options);
        
        options.forEach(opt => {
            const setName = opt.value;
            if (!setName) return;
            const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
            const statuses = [];
            Object.keys(REDO_STATE).forEach(key => {
                if (key.startsWith(setPath)) {
                    const slotIdx = key.split('::')[1];
                    const slotNum = parseInt(slotIdx) + 1;
                    const state = REDO_STATE[key];
                    if (state.status === 'running') {
                        statuses.push(`Slot ${slotNum}: ⏳`);
                    } else if (state.status === 'completed') {
                        statuses.push(`Slot ${slotNum}: 🟢`);
                    }
                }
            });
            if (statuses.length > 0) {
                opt.text = `${setName} (${statuses.join(', ')})`;
            } else {
                opt.text = setName;
            }
        });
    }

function updateApproveButtonState() {
      if (!approveSetBtn) return;
      
      const setGreen = () => {
        approveSetBtn.disabled = false;
        approveSetBtn.style.background = "#1f4026";
        approveSetBtn.style.color = "#7fdb96";
        approveSetBtn.style.border = "1px solid #2f5e3a";
        approveSetBtn.textContent = "Approve Set (Move to Completed)";
        approveSetBtn.style.cursor = "pointer";
        approveSetBtn.style.opacity = "1";

        if (deleteSetBtn) {
            deleteSetBtn.disabled = false;
            deleteSetBtn.style.background = "#3d1c1c";
            deleteSetBtn.style.color = "#fca5a5";
            deleteSetBtn.style.border = "1px solid #7a3838";
            deleteSetBtn.textContent = "Delete Set";
            deleteSetBtn.style.cursor = "pointer";
            deleteSetBtn.style.opacity = "1";
        }
      };

      const setOrange = () => {
        approveSetBtn.disabled = true;
        approveSetBtn.style.background = "#7c2d12"; 
        approveSetBtn.style.color = "#fdba74"; 
        approveSetBtn.style.border = "1px solid #ea580c";
        approveSetBtn.textContent = "Waiting for Redo...";
        approveSetBtn.style.cursor = "not-allowed";
        approveSetBtn.style.opacity = "0.8";

        if (deleteSetBtn) {
            deleteSetBtn.disabled = true;
            deleteSetBtn.style.background = "#2a1515"; 
            deleteSetBtn.style.color = "#8b5a5a"; 
            deleteSetBtn.style.border = "1px solid #4a2222";
            deleteSetBtn.textContent = "Waiting for Redo...";
            deleteSetBtn.style.cursor = "not-allowed";
            deleteSetBtn.style.opacity = "0.8";
        }
      };

      if (!CURRENT_SET || appMode !== 'review') return; 

      const setPath = CURRENT_SET.outputBasePath;
      let hasRunning = false;
      
      Object.keys(REDO_STATE).forEach(k => {
        if (k.startsWith(setPath) && REDO_STATE[k].status === 'running') {
          hasRunning = true;
        }
      });

      if (hasRunning) {
        setOrange();
      } else {
        setGreen();
      }
    }

    async function loadSetImages(setName) {
      if (!setName) return;

      const category = activeCategoryEl.value;
      setBusy(true);
      setStatus(`Loading ${setName}...`);
      reviewGrid.innerHTML = "";

      try {
        await ensureStorageSignedIn();
        const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const setRef = ref(storage, setPath);
        const res = await listAll(setRef);

        let parsedSetN = parseInt(setName.replace('Set_', '')) || 0;
        CURRENT_SET = { category, outputBasePath: setPath, setN: parsedSetN };

        let manifestData = null;
        try {
            const manifestRef = ref(storage, `${setPath}/manifest.json`);
            const buffer = await getBytes(manifestRef);
            const text = new TextDecoder().decode(buffer);
            manifestData = JSON.parse(text);
        } catch(err) {}

        const slotPlan = SLOT_MAP[category] || [];
        
        slotPlan.forEach((spec, i) => {
          const slotNum = i + 1;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i;

          let sourceStr = "Unknown";
          if (manifestData && manifestData.slots) {
              const slotMeta = manifestData.slots.find(s => s.slot === slotNum);
              if (slotMeta && slotMeta.source) sourceStr = slotMeta.source;
          }

          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">Review: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="rev_slotPrev_${i}"><div class="slotRefEmpty">Loading…</div></div>
            <div class="small" id="rev_slotMeta_${i}">Source: ${sourceStr}</div>
            <button class="btn btnSmall redoBtn" id="rev_redo_${i}" style="margin-top:8px; width:100%;" onclick="redoSlot(${i}, 'rev')">Redo Slot ${slotNum}</button>
          `;
          reviewGrid.appendChild(slotCard);
        });

        slotPlan.forEach((_, i) => {
             const key = `${setPath}::${i}`;
             const state = REDO_STATE[key];
             const prevBox = document.getElementById(`rev_slotPrev_${i}`);
             const redoBtn = document.getElementById(`rev_redo_${i}`);

             if (state && state.status === 'running') {
                 if (prevBox) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Working…</div>`;
                    prevBox.classList.remove("success-border");
                 }
                 if (redoBtn) redoBtn.disabled = true;
             } 
             else if (state && state.status === 'completed') {
                 if (prevBox) prevBox.classList.add("success-border");
             }
        });

    const slotFiles = res.items.filter(item => item.name.startsWith("Slot_") && item.name.endsWith(".png"));
        
        await Promise.all(slotFiles.map(async (fileRef) => {
          const match = fileRef.name.match(/Slot_(\d+)\.png/);
          if (match) {
            const slotIndex = parseInt(match[1]) - 1;
            
            const key = `${setPath}::${slotIndex}`;
            if (REDO_STATE[key]?.status === 'running') return;

            const prevBox = document.getElementById(`rev_slotPrev_${slotIndex}`);
            if (!prevBox) return;

            try {
              // 1. Instant load from local IndexedDB Cache
              let cached = await getCachedBlob(fileRef.fullPath);
              if (cached && cached.blob) {
                  setBoxImage(prevBox, URL.createObjectURL(cached.blob));
              }

              // 2. Background verification with Firebase
              const meta = await getMetadata(fileRef);
              const cloudUpdatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;

              // Only fetch if no cache exists or cloud is newer
              if (!cached || cloudUpdatedMs > cached.updatedMs) {
                  const url = await getDownloadURL(fileRef);
                  const newBlob = await fetchAndCacheBlob(url, fileRef.fullPath, cloudUpdatedMs);
                  
                  // Ensure we don't overwrite if a user clicked Redo in the meantime
                  if (REDO_STATE[key]?.status !== 'running') {
                      setBoxImage(prevBox, newBlob ? URL.createObjectURL(newBlob) : cacheBust(url));
                  }
              }
            } catch (err) {
              // If it fails but we don't have a cache, mark as not found
              if (!await getCachedBlob(fileRef.fullPath)) {
                prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
              }
            }
          }
        }));

        setStatus(`Viewing ${category} / ${setName}`);
      } catch (e) {
        if (e.code === 'storage/object-not-found') {
             reviewGrid.innerHTML = `<div class='slotRefEmpty'>Set '${setName}' not found (might be deleted/moved).</div>`;
        } else {
             console.error(e);
             setStatus(`Error: ${e.message}`);
        }
      } finally {
        setBusy(false);
        updateApproveButtonState(); 
      }
    }
    
    reviewSetSelect.addEventListener("change", (e) => {
        loadSetImages(e.target.value);
    });

    function approveSet() {
      const category = activeCategoryEl.value;
      const setName = reviewSetSelect.value;
      if (!setName) return;

      const optionToRemove = reviewSetSelect.querySelector(`option[value="${setName}"]`);
      if (optionToRemove) optionToRemove.remove();

      if (reviewSetSelect.options.length > 0) {
          reviewSetSelect.selectedIndex = 0; 
          loadSetImages(reviewSetSelect.value);
      } else {
          reviewGrid.innerHTML = "<div class='slotRefEmpty'>No more sets to review!</div>";
          setStatus("Queue clear.");
      }

      runBackgroundApproval(category, setName);
    }
    async function runBackgroundApproval(category, setName) {
        const queueId = `${category}/${setName}`;
        backgroundQueueStatus.textContent = `Queued: ${setName}...`;
        console.log(`[Queue] Starting background move for ${setName}`);

        const srcFolder = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const destFolderName = `${category}_${setName}`; 
        const destFolder = `${ROOT}/Generated_Listing_Sets/Completed_Listing_Sets/${destFolderName}`; // UPDATED

        try {
            await ensureStorageSignedIn();
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const itemRef of res.items) {
               const buffer = await getBytes(itemRef);
               const newRef = ref(storage, `${destFolder}/${itemRef.name}`);
               await uploadBytesResumable(newRef, buffer); 
               await deleteObject(itemRef);
            }
            console.log(`[Queue] Finished moving ${setName}`);
            backgroundQueueStatus.textContent = `Completed: ${setName}`;
            
            setTimeout(() => {
                if (backgroundQueueStatus.textContent.includes(setName)) {
                    backgroundQueueStatus.textContent = "";
                }
                updateCompletedSetsCounter(); // <--- ADD THIS LINE HERE
                updateTotalAllTimeCounter();
            }, 3000);

        } catch (e) {
            console.error(`[Queue] Failed to move ${setName}`, e);
            backgroundQueueStatus.textContent = `Error moving ${setName}`;
        }
    }

    approveSetBtn.addEventListener("click", approveSet);

    function deleteSet() {
      const category = activeCategoryEl.value;
      const setName = reviewSetSelect.value;
      if (!setName) return;

      const confirmDelete = confirm(`Are you sure you want to permanently delete ${setName}?`);
      if (!confirmDelete) return;

      const optionToRemove = reviewSetSelect.querySelector(`option[value="${setName}"]`);
      if (optionToRemove) optionToRemove.remove();

      if (reviewSetSelect.options.length > 0) {
          reviewSetSelect.selectedIndex = 0; 
          loadSetImages(reviewSetSelect.value);
      } else {
          reviewGrid.innerHTML = "<div class='slotRefEmpty'>No more sets to review!</div>";
          setStatus("Queue clear.");
      }

      runBackgroundDelete(category, setName);
    }

    async function runBackgroundDelete(category, setName) {
        backgroundQueueStatus.textContent = `Deleting: ${setName}...`;
        console.log(`[Queue] Starting background delete for ${setName}`);

        const targetFolder = `${ROOT}/${category}/Ready_To_List/${setName}`;

        try {
            await ensureStorageSignedIn();
            const folderRef = ref(storage, targetFolder);
            const res = await listAll(folderRef);
            
            // Delete all files in the directory
            for (const itemRef of res.items) {
               await deleteObject(itemRef);
            }
            console.log(`[Queue] Finished deleting ${setName}`);
            backgroundQueueStatus.textContent = `Deleted: ${setName}`;
            
            setTimeout(() => {
                if (backgroundQueueStatus.textContent.includes(setName)) {
                    backgroundQueueStatus.textContent = "";
                }
            }, 3000);

        } catch (e) {
            console.error(`[Queue] Failed to delete ${setName}`, e);
            backgroundQueueStatus.textContent = `Error deleting ${setName}`;
        }
    }

    approveSetBtn.addEventListener("click", approveSet);
    if (deleteSetBtn) deleteSetBtn.addEventListener("click", deleteSet); // <--- ADD THIS
        
        // Updated postJson to accept a signal for cancellation
        async function postJson(path, body, signal) {
          const fetchOptions = {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          };

          // Attach the signal to the fetch request if provided
          if (signal) {
            fetchOptions.signal = signal;
          }

          const res = await fetch(`${functionsBaseUrl}/${path}`, fetchOptions);

          const raw = await res.text().catch(() => "");
          let j = null;
          try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

          if (!res.ok) {
            const msg = (j?.error?.message || j?.error) || (raw ? raw.slice(0, 300) : "") || `HTTP ${res.status}`;
            throw new Error(msg);
          }

          if (!j) {
            if (res.status === 202 && (!raw || !raw.trim())) {
              return { ok: true, accepted: true, status: 202 };
            }
            throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
          }
          return j;
        }

        const GEMINI_FN = "geminiImageProxy";
        const GEMINI_BG_FN = "geminiImageProxy-background";

        async function allocSet(category) {
        return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
      }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

        setStatus("Allocating Set…");
        const alloc = await allocSet(category);
        const outputBasePath = normalizeAllocOutputBasePath(alloc);
        if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

        let setN = alloc?.setN ?? alloc?.set_n;
        if (setN == null) {
          const m = outputBasePath.match(/\/Set_(\d+)\b/);
          if (m) setN = Number(m[1]);
        }

        CURRENT_SET = { category, outputBasePath, setN };

        const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(category);
        const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
        
        const charmLatest = await listLatestFile(charmFolderPath);
        if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);

        const manifest = {
          category,
          setN,
          outputBasePath,
          timestamp: new Date().toISOString(),
          slots: [],
          model: "gemini-3.1-flash-image-preview",
        };

        setStatus("Preparing slots (Randomizing)…");
        const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
          const srcFolder = slotRefFolder(category, spec.folder);
          const srcRandom = await listRandomFile(srcFolder);
          if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);
          return { spec, i, slotNum: i + 1, srcLatest: srcRandom };
        }));

        generateGrid.innerHTML = "";
        for (const r of slotResolved) {
          const { spec, i, slotNum, srcLatest } = r;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i; 
          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="gen_slotPrev_${i}"><div class="slotRefEmpty">Queued…</div></div>
            <div class="small" id="gen_slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
            <button class="btn btnSmall redoBtn" id="gen_redo_${i}" style="margin-top:8px; width:100%;" disabled onclick="redoSlot(${i}, 'gen')">Redo Slot ${slotNum}</button>
          `;
          generateGrid.appendChild(slotCard);
        }

        setStatus("Starting parallel staggered generation…");

        // Process slots in parallel, but stagger the API requests to prevent rate limiting
        const generationPromises = slotResolved.map(async (r, index) => {
          const { spec, i, slotNum, srcLatest } = r;
          
          // Delay each request by 2.5 seconds multiplied by its index (0s, 2.5s, 5s, 7.5s...)
          await sleep(index * 2500); 

          const prevBox = document.getElementById(`gen_slotPrev_${i}`);
          if (prevBox) {
             prevBox.innerHTML = `<div class="slotRefEmpty">Working…</div>`;
             prevBox.classList.add("working-box");
          }

          // Dispatch the individual API request
          if (spec.type === "copy") {
            await postJson(GEMINI_FN, {
              kind: "copy_to_slot",
              activeCategory: category,
              source_storage_path: srcLatest.fullPath,
              output_base_path: outputBasePath,
              slotIndex: i,
            });
          } else {
            await postJson(GEMINI_BG_FN, {
              kind: "edits",
              activeCategory: category,
              input_storage_path: srcLatest.fullPath,
              input_charm_storage_path: charmLatest.fullPath, 
              output_base_path: outputBasePath,
              slotIndex: i,
              prompt: buildSlotPrompt(category, spec.folder, slotNum),
              model: "gemini-3.1-flash-image-preview",
            });
          }

          // Explicitly pass the extended 20-min timeout and 5s interval to the call
          const waited = await waitForSlotPngUrl(outputBasePath, i, { timeoutMs: 1200000, intervalMs: 5000 });
          
          // Instant Cache Write and UI Update
          const newBlob = await fetchAndCacheBlob(waited.url, waited.storagePath, Date.now());
          if (prevBox) {
              prevBox.classList.remove("working-box");
              setBoxImage(prevBox, newBlob ? URL.createObjectURL(newBlob) : cacheBust(waited.url));
              prevBox.classList.add("success-border");
          }

          return {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcLatest.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waited.storagePath,
          };
        });

        setStatus("Generating… (Monitoring Storage)");

        // Wait for all staggered slots to finish
        const results = await Promise.all(generationPromises);
        results.sort((a, b) => a.slot - b.slot);
        manifest.slots = results;

        setStatus("Writing manifest…");
            await postJson("geminiImageProxy", {
                kind: "write_manifest",
                activeCategory: category, // <--- CHANGED FROM "Charm_Maker"
                output_base_path: outputBasePath,
                manifest: manifest,
            });

        setStatus(`Done → ${category}/Ready_To_List/Set_${setN}`);
        setAllRedoEnabled(true);
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      } finally {
        setBusy(false);
      }
    }

    // --- Charm Maker Logic ---
    let currentEarringRef = null;

    const previewNewCharms = document.getElementById("previewNewCharms");
    const executeCharmGenBtn = document.getElementById("executeCharmGenBtn");
    
    // --- Input UI variables ---
    const batchSelect = document.getElementById("batchProcessCount");
    const batchInput = document.getElementById("batchProcessCountInput");
    const derivSelect = document.getElementById("derivativesPerCharm");
    const derivInput = document.getElementById("derivativesPerCharmInput");

    // Sync input handlers
    if (batchSelect && batchInput) {
        batchSelect.addEventListener("change", () => batchInput.value = batchSelect.value);
        batchInput.addEventListener("input", () => batchSelect.value = batchInput.value);
    }
    if (derivSelect && derivInput) {
        derivSelect.addEventListener("change", () => derivInput.value = derivSelect.value);
        derivInput.addEventListener("input", () => derivSelect.value = derivInput.value);
    }

    // --- Charm Maker Pagination State ---
    let charmSetsHistory = [];
    let charmCurrentPage = 1;
    const CHARM_ITEMS_PER_PAGE = 50;

    // Base prompts hoisted for global access
    const promptStrCharm = `CRITICAL INITIAL ANALYSIS: Before generating, conceptually analyze the reference image to determine its exact genre and subject matter (e.g., "Genre: Animal, Subject Matter: Rabbit/Leporidae"). Use this specific analysis as the strict foundational concept for the new charm. DO NOT add additional jump rings, bails, or chains under ANY circumstances.

    TASK: Generate a highly realistic, 2D jewelry charm that functions as a thematic and aesthetic extension of the provided reference based on your analysis. Your goal is to keep the SAME genre and loosely similar subject matter and overall concept but adapt it to attract similar audiences.

    HARD PHYSICAL CONSTRAINTS (NON-NEGOTIABLE):
    • Use engravings very sparingly and very strategically. Do not cram too many pointless engravings onto the charm.
    • Leave a lot of white space between the engravings; do not bunch up engravings and cutouts closely together.
    • FLAT SHEET METAL: The charm must appear as a perfectly flat, thin sheet of high polish metal.
    • SHARP 2D CUTOUTS: Use laser-cut precision. Do NOT allow rounded edges, bevels, or 3D thickness.
    • VIEWPOINT: Always render the charm perfectly front-facing (orthographic) with 0% perspective tilt.
    • BACKGROUND COLOR (CRITICAL & ABSOLUTE): You MUST generate the charm on a 100% PURE SOLID BLACK (#000000) background. Absolutely NO white backgrounds, NO grey backgrounds, NO gradients, and NO transparency. If the background is not pure black, it is a failure.
    • NO TEXT: Never render letters, numbers, or words.

    THEMATIC & AESTHETIC EVOLUTION:
    • You may only introduce minor stylistic alterations to the outer contour (e.g., slightly sharper points, smoother curves, or stylistic edges) while preserving the exact overall recognizable footprint.
    • AESTHETIC ANCHORING: Maintain the exact gold tone, luminosity, and "luxe-minimalist" feel of the reference image. The "vibe" must remain cohesive.
    • ENGRAVING DEPTH: All internal details must be surface-level laser etchings. No embossing or 3D extrusion.

    NEGATIVE CONSTRAINTS (NEVER DO THESE - EXTREME PENALTY):
    • NEVER generate a white or light background. It MUST be pure solid black (#000000).
    • NEVER add additional jump rings, O-rings, bails, or chains of any kind.
    • NEVER introduce 3D volume, thickness, or side-profile views.
    • NEVER use matte or brushed textures if the reference is high-polish.
    • NEVER deviate from the established level of intricate detail seen in the reference.
    
    HOOP/BAIL REQUIREMENT (CRITICAL):
    • We must ensure that the integrated hoop already present in the reference image MUST ALWAYS be correctly and strategically positioned on the newly generated Charm. THIS IS A MUST AND ABSOLUTELY CRUCIAL!!!! DO NOT ADD EXTRA JUMP RINGS TO IT.`;

    const promptStrEarring = `CRITICAL INSTRUCTION: Analyze the provided reference image of a jewelry charm. 
    Your task is to generate an image that is 100% identical to this reference, keeping everything absolutely the same, with ONLY 1 EXCEPTION:
    
    Exception 1: Completely remove the hoop/bail from the top of the charm.

    HARD CONSTRAINTS (NON-NEGOTIABLE):
    • BACKGROUND COLOR (CRITICAL): Keep the exact same solid pure black (#000000) background. ABSOLUTELY NO white, grey, or transparent backgrounds.
    • JUMP RINGS: NEVER add jump rings, O-rings, bails, or chains.
    • Keep all engravings, cutouts, overall shape, proportions, and gold tone 100% identical to the reference.
    • Do not introduce any new elements, 3D thickness, or styling changes.
    • The final output MUST be the exact same charm, just missing the top hoop, on a PURE BLACK background.`;

const promptStrBW = `CRITICAL INSTRUCTION: You are performing a 1:1 structural replication of the FIRST image, converting it into a specific Black & White line art style. 

    The SECOND image is strictly a STYLE REFERENCE. You must NEVER copy, merge, or include the subject matter or object shown in the second image. 

    TASK: Generate a black and white outline image based STRICTLY on the object shown in the FIRST image. The final image must be the EXACT SAME object as the FIRST image.

    HARD CONSTRAINTS (NON-NEGOTIABLE):
    • 100% STRUCTURAL MATCH: Keep all outer perimeters, overall shape, and proportions 100% identical to the FIRST image.
    • IGNORE SECOND IMAGE SUBJECT: Do NOT add or draw the object from the SECOND image. Use the second image ONLY to understand the B&W aesthetic.
    • ENGRAVING FILL RULE (CRITICAL): You must NEVER draw "double lines" or outlines around thick engravings. 
        1. DARKENED/THICK ENGRAVINGS: If an engraving has noticeable thickness, width, or a dark patina in the FIRST image, you MUST fill that entire shape or line with SOLID BLACK. (e.g., if it is a dark etched snake or thick wing vein, color it completely solid black). Do NOT just outline it.
        2. THIN LINES: Only if an engraving is a razor-thin, lightly scratched line should it be a single thin black line.
        3. CUTOUTS/HOLES: Physical holes cut entirely through the metal must remain pure white inside.
    • OUTLINE: Ensure the Charm's outer perimeter black outline is only 2px thick.
    • BACKGROUND: Use a solid, pure WHITE (#FFFFFF) background. Absolutely no transparency.
    • NO 3D/SHADING: Do NOT add any shading, 3D extrusion, colours, or grey tones. Flat 2D vector style only.`;

    const promptStrBWEarring = `CRITICAL INSTRUCTION: Analyze the provided reference image, which is a Black & White line art drawing of a jewelry charm on a pure white background. 
    Your task is to generate an image that is 100% identical to this reference, keeping everything absolutely the same, with ONLY 1 EXCEPTION:
    
    Exception 1: Completely remove the hoop/bail from the top of the charm.

    HARD CONSTRAINTS (NON-NEGOTIABLE):
    • BACKGROUND COLOR (CRITICAL): Keep the exact same solid pure WHITE (#FFFFFF) background. ABSOLUTELY NO black, grey, or transparent backgrounds.
    • JUMP RINGS: NEVER add jump rings, O-rings, bails, or chains.
    • IDENTICAL REPLICATION: Keep all overall shapes, proportions, and line thickness 100% identical to the reference.
    • ENGRAVING FILL RULE (CRITICAL): Preserve the exact style of the reference features without adding new outlines:
        1. DARKENED/THICK ENGRAVINGS: Keep solid black fills exactly as they are.
        2. THIN LINES: Keep thin lines exactly as they are.
        3. CUTOUTS/HOLES: Keep physical holes completely white inside.
    • Do not introduce any new elements, 3D thickness, shading, colors, or styling changes. Flat 2D B&W vector style only.
    • The final output MUST be the exact same B&W line art charm, just missing the top hoop, on a PURE WHITE background.`;

    window.setPreviewNewCharmsFromRef = function(folderId) {
        const refBox = document.getElementById(`prevBox_${folderId}_ref`);
        if (refBox) {
            const img = refBox.querySelector('img');
            if (img && img.src) {
                const mainPrev = document.getElementById('previewNewCharms');
                if (mainPrev) {
                    setBoxImage(mainPrev, img.src);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                }
            }
        }
    };

    async function loadCharmMakerPreviews() {
      previewNewCharms.innerHTML = `<div class="slotRefEmpty">Fetching...</div>`;
      document.getElementById("newCharmsTotalCount").textContent = "Count: Loading...";
      try {
        await ensureStorageSignedIn();
        
        // ADDED: Fetch and display New_Charms total
        const newCharmsRef = ref(storage, newCharmsPath());
        const newCharmsRes = await listAll(newCharmsRef);
        document.getElementById("newCharmsTotalCount").textContent = `Count: ${newCharmsRes.items.length}`;
        
        const charmsLatest = await listLatestFile(newCharmsPath());
        if (charmsLatest) {
          setBoxImage(previewNewCharms, cacheBust(charmsLatest.url));
        } else {
          previewNewCharms.innerHTML = `<div class="slotRefEmpty">Queue Empty</div>`;
        }

        // Keep Earring silently loaded for logic integrity even though UI is gone
        const earringsLatest = await listLatestFile(newCharmsEarringsPath());
        currentEarringRef = earringsLatest;

      } catch (e) {
        console.error("Error fetching charm previews:", e);
        previewNewCharms.innerHTML = `<div class="slotRefEmpty">Error loading</div>`;
      }
    }

    async function loadCharmHistoryList(folderName) {
        setStatus("Loading history...");
        
        const isApproved = folderName === "Charm_Maker/Completed_Approved_Charm_Sets";
        if (isApproved) {
            approvedSetsHistory = [];
            approvedCurrentPage = 1;
        } else {
            charmSetsHistory = [];
            charmCurrentPage = 1;
        }

        try {
            await ensureStorageSignedIn();
            const completedCharmsRef = ref(storage, `${ROOT}/${folderName}`);
            const res = await listAll(completedCharmsRef);
            
            const prefixes = res.prefixes.map(p => p.name).filter(n => n.startsWith('Deriv_'));
            prefixes.sort((a, b) => {
                const tsA = parseInt(a.replace('Deriv_', '')) || 0;
                const tsB = parseInt(b.replace('Deriv_', '')) || 0;
                return tsB - tsA; // descending
            });
            
            // FIX: Ensure correct state assignment so arrays don't get mixed up between tabs
            if (isApproved) {
                approvedSetsHistory = prefixes;
                const countSpan = document.querySelector("#approvedSetsCounter span");
                if (countSpan) countSpan.textContent = approvedSetsHistory.length;
            } else {
                charmSetsHistory = prefixes;
            }
            
            renderCharmPage();
        } catch (e) {
            console.error("Failed to load Charm history:", e);
            setStatus("Error loading history");
        }
    }

function createCharmCardHTML(folderId, isApprovedView) {
        const redoHTML0 = isApprovedView ? '' : `<button class="btn btnSmall redoBtn" id="redo_${folderId}_0" onclick="redoCharmSlot('${folderId}', 0)">Redo</button>`;
        const redoHTML1 = isApprovedView ? '' : `<button class="btn btnSmall redoBtn" id="redo_${folderId}_1" onclick="redoCharmSlot('${folderId}', 1)">Redo</button>`;
        const redoHTML2 = isApprovedView ? '' : `<button class="btn btnSmall redoBtn" id="redo_${folderId}_2" onclick="redoCharmSlot('${folderId}', 2)">Redo</button>`;
        const redoHTML3 = isApprovedView ? '' : `<button class="btn btnSmall redoBtn" id="redo_${folderId}_3" onclick="redoCharmSlot('${folderId}', 3)">Redo</button>`;

        const folderArg = isApprovedView ? 'true' : 'false';
        
        // --- UPDATED ACTION BUTTONS ---
        const actionButtons = isApprovedView ? 
            `<div class="row" style="grid-column: span 2; gap: 8px; margin-top: 4px;">
                <button class="btn btnSmall redoBtn" style="flex:1; background: #3d1c1c; border-color: #7a3838; color: #fca5a5;" onclick="deleteCharmQuad('${folderId}', ${folderArg})">Delete</button>
            </div>` 
            : 
            `<div class="row" style="grid-column: span 2; gap: 8px; margin-top: 4px;">
                <button class="btn btnSmall redoBtn" style="flex:1;" onclick="regenCharmQuad('${folderId}')">Regen Quad</button>
                <button class="btn btnSmall redoBtn" style="flex:1; background: #b45309; border-color: #d97706; color: #fde68a; display: none;" id="continue_${folderId}" onclick="continueCharmQuad('${folderId}')">Approve Base & Continue</button>
                <button class="btn btnSmall redoBtn" style="flex:1; background: #3d1c1c; border-color: #7a3838; color: #fca5a5;" onclick="deleteCharmQuad('${folderId}', ${folderArg})">Delete</button>
                <button class="btn btnSmall redoBtn" style="flex:1; background: #1f4026; border-color: #2f5e3a; color: #7fdb96;" onclick="approveCharmQuad('${folderId}')">Approve Set</button>
            </div>`;

        return `
            <div class="charm-card" id="card_${folderId}">
                <div class="charm-card-title">Generated Derivatives Previews <span class="muted" style="font-size:11px;">${folderId}</span></div>
                
                <div style="grid-column: span 2; display: flex; align-items: center; gap: 10px; padding-bottom: 10px; border-bottom: 1px solid var(--line);">
                    <div class="muted" style="font-size: 11px;">Source Ref:</div>
                    <div class="slotPrev" id="prevBox_${folderId}_ref" style="width: 66px; height: 66px; border-radius: 6px; cursor: pointer; border: 1px dashed var(--muted);" onclick="setPreviewNewCharmsFromRef('${folderId}')" title="Click to load in New_Charms preview">
                        <div class="slotRefEmpty" style="font-size: 9px;">...</div>
                    </div>
                </div>

                <div class="charm-col">
                    <div class="muted">New_Charms Derivative</div>
                    <div class="slotPrev" id="prevBox_${folderId}_0"><div class="slotRefEmpty">Loading...</div></div>
                    ${redoHTML0}
                </div>
                
                <div class="charm-col">
                    <div class="muted">New_Charms_Earrings Derivative</div>
                    <div class="slotPrev" id="prevBox_${folderId}_1"><div class="slotRefEmpty">Loading...</div></div>
                    ${redoHTML1}
                </div>
                
                <div class="charm-col">
                    <div class="muted">B&W Line Art (Standard)</div>
                    <div class="slotPrev" id="prevBox_${folderId}_2"><div class="slotRefEmpty">Loading...</div></div>
                    ${redoHTML2}
                </div>
                
                <div class="charm-col">
                    <div class="muted">B&W Line Art (Earrings)</div>
                    <div class="slotPrev" id="prevBox_${folderId}_3"><div class="slotRefEmpty">Loading...</div></div>
                    ${redoHTML3}
                </div>

                ${actionButtons}
            </div>
        `;
    }

function renderCharmPage(isApprovedView) {
        if (typeof isApprovedView !== "boolean") {
            isApprovedView = (appMode === "approvedCharms");
        }

        const targetGrid = isApprovedView ? approvedCharmGrid : charmGrid;
        const targetHistory = isApprovedView ? approvedSetsHistory : charmSetsHistory;
        const targetPage = isApprovedView ? approvedCurrentPage : charmCurrentPage;
        const targetPagination = isApprovedView ? approvedCharmPaginationEl : charmPaginationEl;
        
        targetGrid.innerHTML = "";
        
        if (targetHistory.length === 0) {
            targetGrid.innerHTML = `<div class="slotRefEmpty" style="grid-column:span 4;">No historical sets found.</div>`;
            if (targetPagination) targetPagination.style.display = "none";
            setStatus("Ready");
            return;
        }

        const totalPages = Math.ceil(targetHistory.length / CHARM_ITEMS_PER_PAGE);
        
        if (isApprovedView) {
            document.getElementById("approvedPageInfo").textContent = `Page ${targetPage} of ${totalPages}`;
            document.getElementById("approvedPrevPage").disabled = (targetPage === 1);
            document.getElementById("approvedNextPage").disabled = (targetPage === totalPages);
        } else {
            document.getElementById("charmPageInfo").textContent = `Page ${targetPage} of ${totalPages}`;
            document.getElementById("charmPrevPage").disabled = (targetPage === 1);
            document.getElementById("charmNextPage").disabled = (targetPage === totalPages);
        }
        
        if (targetPagination) targetPagination.style.display = totalPages > 1 ? "flex" : "none";

        const startIndex = (targetPage - 1) * CHARM_ITEMS_PER_PAGE;
        const pageItems = targetHistory.slice(startIndex, startIndex + CHARM_ITEMS_PER_PAGE);

        pageItems.forEach(folderId => {
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = createCharmCardHTML(folderId, isApprovedView);
            const cardNode = tempDiv.firstElementChild;
            targetGrid.appendChild(cardNode);
            loadSetImagesForCharm(folderId, isApprovedView ? "Charm_Maker/Completed_Approved_Charm_Sets" : "Charm_Maker/Generated_Charm_Sets");
        });
        
        setStatus(`Viewing Page ${targetPage}`);
    }

async function loadSetImagesForCharm(folderId, folderName) {
        const folderPath = `${ROOT}/${folderName}/${folderId}`;
        const isApprovedView = folderName === "Charm_Maker/Completed_Approved_Charm_Sets";
        
        try {
            const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
            const manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
            if (manifest.sourceCharm) {
                const refBox = document.getElementById(`prevBox_${folderId}_ref`);
                if (refBox) {
                    const srcRef = ref(storage, manifest.sourceCharm);
                    try {
                        const url = await getDownloadURL(srcRef);
                        setBoxImage(refBox, cacheBust(url));
                    } catch (urlErr) {
                        refBox.innerHTML = `<div class="slotRefEmpty" style="font-size: 9px; color: #fca5a5;">Ref Missing</div>`;
                    }
                }
            }
        } catch(e) {
            console.warn("Could not load manifest/ref for", folderId);
        }

        // PREVENT 404 CONSOLE ERRORS BY LISTING AVAILABLE FILES FIRST
        const existingFiles = new Set();
        try {
            const folderRef = ref(storage, folderPath);
            const res = await listAll(folderRef);
            res.items.forEach(item => existingFiles.add(item.name));
        } catch (e) {
            console.warn("Could not list folder contents", folderPath);
        }

        window.ACTIVE_CHARM_JOBS = window.ACTIVE_CHARM_JOBS || new Set();

        for (let i = 0; i < 4; i++) {
            const fileName = `Slot_${i+1}.png`;
            const storagePath = `${folderPath}/${fileName}`;
            const fileRef = ref(storage, storagePath);
            const prevBox = document.getElementById(`prevBox_${folderId}_${i}`);
            if (!prevBox) continue;
            
            // --- Check if this specific slot is actively generating ---
            if (window.ACTIVE_CHARM_JOBS.has(`${folderId}_${i}`)) {
                prevBox.innerHTML = window.getSpinnerHTML("Working...");
                prevBox.classList.add("working-box");
                prevBox.classList.remove("success-border");
                
                const btn = document.getElementById(`redo_${folderId}_${i}`);
                if (btn) btn.disabled = true;
                continue; // Skip the cache/firebase check, let the background job handle it
            }
            // ---------------------------------------------------------------

            // 1. Instant load from local IndexedDB Cache
            let cached = await getCachedBlob(storagePath);
            if (cached && cached.blob) {
                setBoxImage(prevBox, URL.createObjectURL(cached.blob));
            }

            // Skip Firebase network requests if the file doesn't exist (eliminates 404s)
            if (!existingFiles.has(fileName)) {
                if (!cached) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
                }
                continue; 
            }

            // 2. Background verification with Firebase
            try {
                const meta = await getMetadata(fileRef);
                const cloudUpdatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;

                // Only fetch new if we didn't have a cache, or the cloud version is newer
                if (!cached || cloudUpdatedMs > cached.updatedMs) {
                    const url = await getDownloadURL(fileRef);
                    const newBlob = await fetchAndCacheBlob(url, storagePath, cloudUpdatedMs);
                    
                    // Prevent overwriting if user clicked "Redo/Regen" while we were downloading
                    const currentBox = document.getElementById(`prevBox_${folderId}_${i}`);
                    if (currentBox && !currentBox.classList.contains("working-box")) {
                        const finalSrc = newBlob ? URL.createObjectURL(newBlob) : cacheBust(url);
                        setBoxImage(currentBox, finalSrc);
                    }
                }
            } catch (e) {
                if (!cached) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
                }
            }
        }

        // --- Detect if the workflow is paused and visually restore the state ---
        if (!existingFiles.has("Slot_2.png") && existingFiles.has("Slot_1.png") && !isApprovedView) {
            const continueBtn = document.getElementById(`continue_${folderId}`);
            if (continueBtn) continueBtn.style.display = "block";

            [1, 2, 3].forEach(i => {
                const p = document.getElementById(`prevBox_${folderId}_${i}`);
                if (p && !window.ACTIVE_CHARM_JOBS.has(`${folderId}_${i}`)) {
                    p.innerHTML = `<div class="slotRefEmpty" style="color: #fde68a;">Waiting for Base Approval...</div>`;
                }
            });
        }
    }

    document.getElementById("charmPrevPage").addEventListener("click", () => {
        if (charmCurrentPage > 1) {
            charmCurrentPage--;
            renderCharmPage();
        }
    });

    document.getElementById("charmNextPage").addEventListener("click", () => {
        const totalPages = Math.ceil(charmSetsHistory.length / CHARM_ITEMS_PER_PAGE);
        if (charmCurrentPage < totalPages) {
            charmCurrentPage++;
            renderCharmPage();
        }
    });

window.redoCharmSlot = async function(folderId, slotIndex) {
        const folderPath = `${ROOT}/${currentCharmViewFolder}/${folderId}`;
        const redoBtn = document.getElementById(`redo_${folderId}_${slotIndex}`);
        let prevBox = document.getElementById(`prevBox_${folderId}_${slotIndex}`);
        
        const jobKey = `${folderId}_${slotIndex}`;
        window.ACTIVE_CHARM_JOBS = window.ACTIVE_CHARM_JOBS || new Set();
        window.CHARM_ABORT_CONTROLLERS = window.CHARM_ABORT_CONTROLLERS || new Map();
        
        // 1. Cancel previous job if it exists on this slot
        if (window.CHARM_ABORT_CONTROLLERS.has(jobKey)) {
            window.CHARM_ABORT_CONTROLLERS.get(jobKey).abort();
        }
        
        // 2. Register new abort controller
        const abortController = new AbortController();
        window.CHARM_ABORT_CONTROLLERS.set(jobKey, abortController);
        const signal = abortController.signal;

        window.ACTIVE_CHARM_JOBS.add(jobKey);
        window.updateQuadActionButtons(folderId);
        
        if (redoBtn) redoBtn.disabled = true;
        if (prevBox) {
            prevBox.innerHTML = window.getSpinnerHTML("Working...");
            prevBox.classList.remove("success-border");
            prevBox.classList.add("working-box");
        }
        
        try {
            const slotFileName = `Slot_${slotIndex + 1}.png`;
            const slotStoragePath = `${folderPath}/${slotFileName}`;
            let beforeUpdatedMs = 0, beforeGeneration = 0;
            try {
                const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
                beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
                beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
            } catch(e) {}

            let manifest = {};
            try {
                const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
                manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
            } catch(e) {
                console.warn("No manifest found for", folderId, "falling back to runtime refs if possible");
            }

            let inputPath = "";
            let inputCharmPath = "";
            let promptStr = "";
            let category = "Charms"; 

            if (slotIndex === 0) {
                inputPath = manifest.sourceCharm || (await listLatestFile(newCharmsPath()))?.fullPath; 
                if (!inputPath) throw new Error("Missing source reference for base charm.");
                inputCharmPath = inputPath;
                promptStr = promptStrCharm;
            } else if (slotIndex === 1) {
                inputPath = `${folderPath}/Slot_1.png`;
                inputCharmPath = inputPath;
                promptStr = promptStrEarring;
            } else if (slotIndex === 2) {
                inputPath = `${folderPath}/Slot_1.png`;
                inputCharmPath = manifest.lineArtRef || inputPath;
                promptStr = promptStrBW;
            } else if (slotIndex === 3) {
                inputPath = `${folderPath}/Slot_3.png`; 
                inputCharmPath = inputPath; 
                promptStr = promptStrBWEarring; 
            }

            // PASS SIGNAL TO REQUEST
            await postJson(GEMINI_BG_FN, {
                kind: "edits",
                activeCategory: category,
                input_storage_path: inputPath,
                input_charm_storage_path: inputCharmPath,
                output_base_path: folderPath,
                slotIndex: slotIndex,
                model: "gemini-3.1-flash-image-preview",
                prompt: promptStr
            }, signal);

            // PASS SIGNAL TO POLLER
            const waitedRes = await waitForSlotPngUrl(folderPath, slotIndex, {
                afterUpdatedMs: beforeUpdatedMs,
                afterGeneration: beforeGeneration,
                timeoutMs: 600000, intervalMs: 5000,
                signal: signal 
            });

            const newBlob = await fetchAndCacheBlob(waitedRes.url, waitedRes.storagePath, Date.now());
            
            prevBox = document.getElementById(`prevBox_${folderId}_${slotIndex}`);
            if (prevBox) {
                prevBox.classList.remove("working-box");
                setBoxImage(prevBox, newBlob ? URL.createObjectURL(newBlob) : cacheBust(waitedRes.url));
                prevBox.classList.add("success-border");
            }
        } catch (err) {
            if (err.name === "AbortError" || err.message === "AbortError") {
                console.log(`Redo for ${jobKey} gracefully aborted.`);
                return; // Suppress error, Regen is taking over
            }
            console.error("Charm Redo failed", err);
            prevBox = document.getElementById(`prevBox_${folderId}_${slotIndex}`);
            if (prevBox) {
                prevBox.classList.remove("working-box");
                prevBox.innerHTML = `<div class="slotRefEmpty">Error: ${err.message}</div>`;
            }
        } finally {
            // ONLY clean up UI if we haven't been overwritten by Regen
            if (window.CHARM_ABORT_CONTROLLERS.get(jobKey) === abortController) {
                window.ACTIVE_CHARM_JOBS.delete(jobKey);
                window.CHARM_ABORT_CONTROLLERS.delete(jobKey);
                const updatedBtn = document.getElementById(`redo_${folderId}_${slotIndex}`);
                if (updatedBtn) updatedBtn.disabled = false;
            }
            window.updateQuadActionButtons(folderId);
        }
    };

window.regenCharmQuad = async function(folderId) {
        const folderPath = `${ROOT}/${currentCharmViewFolder}/${folderId}`;
        const cardObj = document.getElementById(`card_${folderId}`);
        
        setBusy(true);
        setStatus(`Regenerating Quad ${folderId}...`);

        if (cardObj) cardObj.classList.add("working-card");
        window.setQuadButtonsState(folderId, true);
        
        window.ACTIVE_CHARM_JOBS = window.ACTIVE_CHARM_JOBS || new Set();
        window.CHARM_ABORT_CONTROLLERS = window.CHARM_ABORT_CONTROLLERS || new Map();
        
        const myControllers = [];
        
        // 1. Interrupt any actively running redos on this quad
        [0, 1, 2, 3].forEach(i => {
            const jobKey = `${folderId}_${i}`;
            if (window.CHARM_ABORT_CONTROLLERS.has(jobKey)) {
                window.CHARM_ABORT_CONTROLLERS.get(jobKey).abort();
            }
            
            // Register fresh controllers for this batch process
            const controller = new AbortController();
            window.CHARM_ABORT_CONTROLLERS.set(jobKey, controller);
            myControllers[i] = controller;
            
            window.ACTIVE_CHARM_JOBS.add(jobKey);
            const p = document.getElementById(`prevBox_${folderId}_${i}`);
            if(p) {
                p.innerHTML = window.getSpinnerHTML("Working...");
                p.classList.remove("success-border");
                p.classList.add("working-box");
            }
            const btn = document.getElementById(`redo_${folderId}_${i}`);
            if(btn) btn.disabled = true;
        });

        try {
            await ensureStorageSignedIn();
            let manifest = {};
            try {
                const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
                manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
            } catch(e) {
                console.warn("No manifest found for", folderId, "falling back to runtime refs if possible");
            }
            
            const sourceCharmPath = manifest.sourceCharm || (await listLatestFile(newCharmsPath()))?.fullPath;
            if (!sourceCharmPath) throw new Error("No source charm reference found.");
            
            let lineArtRefPath = manifest.lineArtRef;
            if (!lineArtRefPath) {
                try {
                    const lat = await listLatestFile(`${ROOT}/Charm_Maker/Reference_Line_Art_Image`);
                    if(lat) lineArtRefPath = lat.fullPath;
                } catch(e) {}
            }

            const beforeMeta = {};
            for (let i = 0; i < 4; i++) {
                try {
                    const m = await getMetadata(ref(storage, `${folderPath}/Slot_${i+1}.png`));
                    beforeMeta[i] = {
                        updatedMs: Date.parse(m?.updated || m?.timeCreated || "") || 0,
                        generation: Number(m?.generation || 0) || 0
                    };
                } catch(e) {
                    beforeMeta[i] = { updatedMs: 0, generation: 0 };
                }
            }



            // STEP 1
            const sig0 = myControllers[0].signal;
            let prev0 = document.getElementById(`prevBox_${folderId}_0`);
            if(prev0) prev0.innerHTML = window.getSpinnerHTML("Generating Base...");
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms",
                input_storage_path: sourceCharmPath, input_charm_storage_path: sourceCharmPath,
                output_base_path: folderPath, slotIndex: 0,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrCharm
            }, sig0);
            
            const charmRes = await waitForSlotPngUrl(folderPath, 0, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[0].updatedMs, afterGeneration: beforeMeta[0].generation,
                signal: sig0
            });
            const newBlob0 = await fetchAndCacheBlob(charmRes.url, charmRes.storagePath, Date.now());
            
            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_0`);
            prev0 = document.getElementById(`prevBox_${folderId}_0`);
            if(prev0) {
                prev0.classList.remove("working-box");
                setBoxImage(prev0, newBlob0 ? URL.createObjectURL(newBlob0) : cacheBust(charmRes.url));
                prev0.classList.add("success-border");
            }
            const btn0 = document.getElementById(`redo_${folderId}_0`);
            if(btn0) btn0.disabled = false;

            // STEP 2
            const sig1 = myControllers[1].signal;
            setStatus("Generating Earring Twin (Removing Hoop)...");
            let prev1 = document.getElementById(`prevBox_${folderId}_1`);
            if(prev1) prev1.innerHTML = window.getSpinnerHTML("Removing Hoop...");
            await sleep(2000, sig1); 
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms",
                input_storage_path: charmRes.storagePath, input_charm_storage_path: charmRes.storagePath,
                output_base_path: folderPath, slotIndex: 1,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrEarring
            }, sig1);
            
            const earringRes = await waitForSlotPngUrl(folderPath, 1, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[1].updatedMs, afterGeneration: beforeMeta[1].generation,
                signal: sig1
            });
            const newBlob1 = await fetchAndCacheBlob(earringRes.url, earringRes.storagePath, Date.now());
            
            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_1`);
            prev1 = document.getElementById(`prevBox_${folderId}_1`);
            if(prev1) {
                prev1.classList.remove("working-box");
                setBoxImage(prev1, newBlob1 ? URL.createObjectURL(newBlob1) : cacheBust(earringRes.url));
                prev1.classList.add("success-border");
            }
            const btn1 = document.getElementById(`redo_${folderId}_1`);
            if(btn1) btn1.disabled = false;

            // STEP 3
            const sig2 = myControllers[2].signal;
            setStatus("Generating B&W Line Art (Standard)...");
            let prev2 = document.getElementById(`prevBox_${folderId}_2`);
            if(prev2) prev2.innerHTML = window.getSpinnerHTML("Generating Line Art...");
            await sleep(2000, sig2);
            const refPathForBaseBW = lineArtRefPath || charmRes.storagePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms",
                input_storage_path: charmRes.storagePath, input_charm_storage_path: refPathForBaseBW,
                output_base_path: folderPath, slotIndex: 2,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrBW
            }, sig2);
            
            const charmBWRes = await waitForSlotPngUrl(folderPath, 2, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[2].updatedMs, afterGeneration: beforeMeta[2].generation,
                signal: sig2
            });
            const newBlob2 = await fetchAndCacheBlob(charmBWRes.url, charmBWRes.storagePath, Date.now());
            
            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_2`);
            prev2 = document.getElementById(`prevBox_${folderId}_2`);
            if(prev2) {
                prev2.classList.remove("working-box");
                setBoxImage(prev2, newBlob2 ? URL.createObjectURL(newBlob2) : cacheBust(charmBWRes.url));
                prev2.classList.add("success-border");
            }
            const btn2 = document.getElementById(`redo_${folderId}_2`);
            if(btn2) btn2.disabled = false;

            // STEP 4
            const sig3 = myControllers[3].signal;
            setStatus("Generating B&W Line Art (Earrings)...");
            let prev3 = document.getElementById(`prevBox_${folderId}_3`);
            if(prev3) prev3.innerHTML = window.getSpinnerHTML("Removing Hoop...");
            await sleep(2000, sig3);
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms",
                input_storage_path: charmBWRes.storagePath, input_charm_storage_path: charmBWRes.storagePath,
                output_base_path: folderPath, slotIndex: 3,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrBWEarring
            }, sig3);
            
            const earringBWRes = await waitForSlotPngUrl(folderPath, 3, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[3].updatedMs, afterGeneration: beforeMeta[3].generation,
                signal: sig3 
            });
            const newBlob3 = await fetchAndCacheBlob(earringBWRes.url, earringBWRes.storagePath, Date.now());
            
            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_3`);
            prev3 = document.getElementById(`prevBox_${folderId}_3`);
            if(prev3) {
                prev3.classList.remove("working-box");
                setBoxImage(prev3, newBlob3 ? URL.createObjectURL(newBlob3) : cacheBust(earringBWRes.url));
                prev3.classList.add("success-border");
            }
            const btn3 = document.getElementById(`redo_${folderId}_3`);
            if(btn3) btn3.disabled = false;

            setStatus("Quad Regeneration Complete.");
        } catch(err) {
            if (err.name === "AbortError" || err.message === "AbortError") {
                console.log(`Regen Quad ${folderId} gracefully aborted.`);
                return;
            }
            console.error("Regen Quad failed:", err);
            setStatus(`Error: ${err.message}`);
            [0, 1, 2, 3].forEach(i => {
                if (window.CHARM_ABORT_CONTROLLERS.get(`${folderId}_${i}`) === myControllers[i]) {
                    window.ACTIVE_CHARM_JOBS.delete(`${folderId}_${i}`);
                    const p = document.getElementById(`prevBox_${folderId}_${i}`);
                    if(p) {
                        p.classList.remove("working-box");
                        if (p.innerHTML.includes("Queued") || p.innerHTML.includes("Generating") || p.innerHTML.includes("Removing") || p.innerHTML.includes("Working")) {
                            p.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
                        }
                    }
                }
            });
        } finally {
            if (cardObj) cardObj.classList.remove("working-card");
            [0, 1, 2, 3].forEach(i => {
                const jobKey = `${folderId}_${i}`;
                if (window.CHARM_ABORT_CONTROLLERS.get(jobKey) === myControllers[i]) {
                    window.ACTIVE_CHARM_JOBS.delete(jobKey);
                    window.CHARM_ABORT_CONTROLLERS.delete(jobKey);
                    const p = document.getElementById(`prevBox_${folderId}_${i}`);
                    if (p) p.classList.remove("working-box");
                    const btn = document.getElementById(`redo_${folderId}_${i}`);
                    if(btn) btn.disabled = false;
                }
            });
            setBusy(false);
            window.updateQuadActionButtons(folderId);
        }
    };

    window.continueCharmQuad = async function(folderId) {
        const folderPath = `${ROOT}/${currentCharmViewFolder}/${folderId}`;
        const cardObj = document.getElementById(`card_${folderId}`);

        if (cardObj) cardObj.classList.add("working-card");
        const continueBtn = document.getElementById(`continue_${folderId}`);
        if (continueBtn) continueBtn.style.display = "none"; // Hide once clicked

        window.setQuadButtonsState(folderId, true);

        window.ACTIVE_CHARM_JOBS = window.ACTIVE_CHARM_JOBS || new Set();
        [1, 2, 3].forEach(i => {
            window.ACTIVE_CHARM_JOBS.add(`${folderId}_${i}`);
            const p = document.getElementById(`prevBox_${folderId}_${i}`);
            if(p) {
                p.innerHTML = window.getSpinnerHTML("Queued...");
                p.classList.add("working-box");
            }
            const btn = document.getElementById(`redo_${folderId}_${i}`);
            if(btn) btn.disabled = true;
        });

        try {
            const baseCharmStoragePath = `${folderPath}/Slot_1.png`;

            let lineArtRefPath = null;
            try {
                const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
                const manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
                lineArtRefPath = manifest.lineArtRef;
            } catch(e) {}

            if (!lineArtRefPath) {
                try {
                    const lat = await listLatestFile(`${ROOT}/Charm_Maker/Reference_Line_Art_Image`);
                    if(lat) lineArtRefPath = lat.fullPath;
                } catch(e) {}
            }

            // STEP 2
            setStatus("Generating Earring Twin (Removing Hoop)...");
            let prev1 = document.getElementById(`prevBox_${folderId}_1`);
            if(prev1) prev1.innerHTML = window.getSpinnerHTML("Removing Hoop...");
            await sleep(2000);
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings",
                input_storage_path: baseCharmStoragePath, input_charm_storage_path: baseCharmStoragePath,
                output_base_path: folderPath, slotIndex: 1,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrEarring
            });
            const earringRes = await waitForSlotPngUrl(folderPath, 1, { timeoutMs: 600000, intervalMs: 5000 });
            const newBlob1 = await fetchAndCacheBlob(earringRes.url, earringRes.storagePath, Date.now());

            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_1`);
            prev1 = document.getElementById(`prevBox_${folderId}_1`);
            if(prev1) {
                prev1.classList.remove("working-box");
                setBoxImage(prev1, newBlob1 ? URL.createObjectURL(newBlob1) : cacheBust(earringRes.url));
                prev1.classList.add("success-border");
            }
            const btn1 = document.getElementById(`redo_${folderId}_1`);
            if(btn1) btn1.disabled = false;

            // STEP 3
            setStatus("Generating B&W Line Art (Standard)...");
            let prev2 = document.getElementById(`prevBox_${folderId}_2`);
            if(prev2) prev2.innerHTML = window.getSpinnerHTML("Generating Line Art...");
            await sleep(2000);
            const refPathForBaseBW = lineArtRefPath || baseCharmStoragePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms",
                input_storage_path: baseCharmStoragePath, input_charm_storage_path: refPathForBaseBW,
                output_base_path: folderPath, slotIndex: 2,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrBW
            });
            const charmBWRes = await waitForSlotPngUrl(folderPath, 2, { timeoutMs: 600000, intervalMs: 5000 });
            const newBlob2 = await fetchAndCacheBlob(charmBWRes.url, charmBWRes.storagePath, Date.now());

            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_2`);
            prev2 = document.getElementById(`prevBox_${folderId}_2`);
            if(prev2) {
                prev2.classList.remove("working-box");
                setBoxImage(prev2, newBlob2 ? URL.createObjectURL(newBlob2) : cacheBust(charmBWRes.url));
                prev2.classList.add("success-border");
            }
            const btn2 = document.getElementById(`redo_${folderId}_2`);
            if(btn2) btn2.disabled = false;

            // STEP 4
            setStatus("Generating B&W Line Art (Earrings)...");
            let prev3 = document.getElementById(`prevBox_${folderId}_3`);
            if(prev3) prev3.innerHTML = window.getSpinnerHTML("Removing Hoop...");
            await sleep(2000);
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings",
                input_storage_path: charmBWRes.storagePath, input_charm_storage_path: charmBWRes.storagePath,
                output_base_path: folderPath, slotIndex: 3,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrBWEarring
            });
            const earringBWRes = await waitForSlotPngUrl(folderPath, 3, { timeoutMs: 600000, intervalMs: 5000 });
            const newBlob3 = await fetchAndCacheBlob(earringBWRes.url, earringBWRes.storagePath, Date.now());

            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_3`);
            prev3 = document.getElementById(`prevBox_${folderId}_3`);
            if(prev3) {
                prev3.classList.remove("working-box");
                setBoxImage(prev3, newBlob3 ? URL.createObjectURL(newBlob3) : cacheBust(earringBWRes.url));
                prev3.classList.add("success-border");
            }
            const btn3 = document.getElementById(`redo_${folderId}_3`);
            if(btn3) btn3.disabled = false;

            setStatus("Derivatives & Line Art Loop Complete.");
        } catch (err) {
            console.error("Master Generation Catch (Continue):", err);
            setStatus(`Error: ${err.message}`);

            [1, 2, 3].forEach(i => {
                window.ACTIVE_CHARM_JOBS.delete(`${folderId}_${i}`);
                const p = document.getElementById(`prevBox_${folderId}_${i}`);
                if(p) {
                    p.classList.remove("working-box");
                    if (p.innerHTML.includes("Queued") || p.innerHTML.includes("Generating") || p.innerHTML.includes("Removing") || p.innerHTML.includes("Working")) {
                        p.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
                    }
                }
                const btn = document.getElementById(`redo_${folderId}_${i}`);
                if(btn) btn.disabled = false;
            });
            if (continueBtn) continueBtn.style.display = "block"; 
        } finally {
            if (cardObj) cardObj.classList.remove("working-card");
            window.updateQuadActionButtons(folderId);
        }
    };

window.approveCharmQuad = async function(folderId) {
        await removeCachedFolder(folderId); // <-- Add this here

        const cardObj = document.getElementById(`card_${folderId}`);
        if (cardObj) cardObj.classList.add("working-card");
        setStatus(`Approving ${folderId}...`);
        window.setQuadButtonsState(folderId, true);
        
        [0, 1, 2, 3].forEach(i => {
            const p = document.getElementById(`prevBox_${folderId}_${i}`);
            if (p) p.innerHTML = window.getSpinnerHTML("Approving...");
        });
        
        try {
            await ensureStorageSignedIn();
            const srcFolder = `${ROOT}/Charm_Maker/Generated_Charm_Sets/${folderId}`; // UPDATED
            const destFolder = `${ROOT}/Charm_Maker/Completed_Approved_Charm_Sets/${folderId}`; // UPDATED
            
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const item of res.items) {
                const buffer = await getBytes(item);
                const newRef = ref(storage, `${destFolder}/${item.name}`);
                await uploadBytesResumable(newRef, buffer);
                await deleteObject(item);
            }
            
            charmSetsHistory = charmSetsHistory.filter(id => id !== folderId);
            if (cardObj) cardObj.remove();
            
            setStatus(`Approved and moved ${folderId}.`);
        } catch (err) {
            console.error("Approve Quad failed:", err);
            setStatus(`Error approving: ${err.message}`);
            if (cardObj) cardObj.classList.remove("working-card");
            window.setQuadButtonsState(folderId, false);
        }
    };

      window.deleteCharmQuad = async function(folderId, isApproved = false) {
        await removeCachedFolder(folderId);

        const cardObj = document.getElementById(`card_${folderId}`);
        if (cardObj) cardObj.classList.add("working-card");
        setStatus(`Deleting ${folderId}...`);
        window.setQuadButtonsState(folderId, true);
        
        [0, 1, 2, 3].forEach(i => {
            const p = document.getElementById(`prevBox_${folderId}_${i}`);
            if (p) p.innerHTML = window.getSpinnerHTML("Deleting...");
        });
        
        try {
            await ensureStorageSignedIn();
            
            // 1. Target the correct Firebase Storage path
            const parentFolder = isApproved 
                ? "Charm_Maker/Completed_Approved_Charm_Sets" 
                : "Charm_Maker/Generated_Charm_Sets";
            
            const folderPath = `${ROOT}/${parentFolder}/${folderId}`;
            const folderRef = ref(storage, folderPath);
            const res = await listAll(folderRef);
            
            // 2. Delete all files inside the targeted folder
            for (const item of res.items) {
                await deleteObject(item);
            }
            
            // 3. Update the correct state array and UI counters
            if (isApproved) {
                approvedSetsHistory = approvedSetsHistory.filter(id => id !== folderId);
                const countSpan = document.querySelector("#approvedSetsCounter span");
                if (countSpan) countSpan.textContent = approvedSetsHistory.length;
            } else {
                charmSetsHistory = charmSetsHistory.filter(id => id !== folderId);
            }
            
            if (cardObj) cardObj.remove();
            
            setStatus(`Deleted ${folderId}.`);
        } catch (err) {
            console.error("Delete Quad failed:", err);
            setStatus(`Error deleting: ${err.message}`);
            if (cardObj) cardObj.classList.remove("working-card");
            window.setQuadButtonsState(folderId, false);
        }
      };

    // Internal helper function for single iteration runs
async function generateCharmQuad(targetCharmRef, targetEarringRef) {
        const timestamp = Date.now() + Math.floor(Math.random() * 10000);
        const folderId = `Deriv_${timestamp}`;
        const outputBasePath = `${ROOT}/Charm_Maker/Generated_Charm_Sets/${folderId}`;

        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = createCharmCardHTML(folderId, false);
        const cardNode = tempDiv.firstElementChild;
        charmGrid.insertBefore(cardNode, charmGrid.firstChild);
        
        window.setQuadButtonsState(folderId, true);
        
        const refBoxNode = document.getElementById(`prevBox_${folderId}_ref`);
        if (refBoxNode) {
            try {
                const url = await getDownloadURL(targetCharmRef.itemRef || ref(storage, targetCharmRef.fullPath));
                setBoxImage(refBoxNode, cacheBust(url));
            } catch(e) { console.warn("Could not preload target ref"); }
        }
        
        if (charmSetsHistory.indexOf(folderId) === -1) {
            charmSetsHistory.unshift(folderId);
        }

        cardNode.classList.add("working-card");
        
        window.ACTIVE_CHARM_JOBS = window.ACTIVE_CHARM_JOBS || new Set();
        [0, 1, 2, 3].forEach(i => {
            window.ACTIVE_CHARM_JOBS.add(`${folderId}_${i}`);
            const p = document.getElementById(`prevBox_${folderId}_${i}`);
            if(p) {
                p.innerHTML = window.getSpinnerHTML("Queued...");
                p.classList.add("working-box");
            }
            const btn = document.getElementById(`redo_${folderId}_${i}`);
            if(btn) btn.disabled = true;
        });
        
        try {
            let lineArtRef = null;
            try {
                lineArtRef = await listLatestFile(`${ROOT}/Charm_Maker/Reference_Line_Art_Image`);
            } catch (e) {
                console.warn("No line art reference found. Will fallback to charm itself.", e);
            }

            const manifest = {
                sourceCharm: targetCharmRef.fullPath,
                sourceEarring: targetEarringRef?.fullPath || null,
                lineArtRef: lineArtRef?.fullPath || null,
                timestamp: new Date().toISOString()
            };

            await postJson("geminiImageProxy", {
                kind: "write_manifest",
                activeCategory: "Charms",
                output_base_path: outputBasePath,
                manifest: manifest,
            });

            // STEP 1 - ONLY GENERATE THE BASE CHARM
            let prev0 = document.getElementById(`prevBox_${folderId}_0`);
            if(prev0) prev0.innerHTML = window.getSpinnerHTML("Generating Base...");
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms", 
                input_storage_path: targetCharmRef.fullPath, input_charm_storage_path: targetCharmRef.fullPath,
                output_base_path: outputBasePath, slotIndex: 0,
                model: "gemini-3.1-flash-image-preview", prompt: promptStrCharm
            });
            const charmRes = await waitForSlotPngUrl(outputBasePath, 0, { timeoutMs: 600000, intervalMs: 5000 });
            const newBlob0 = await fetchAndCacheBlob(charmRes.url, charmRes.storagePath, Date.now());
            
            window.ACTIVE_CHARM_JOBS.delete(`${folderId}_0`);
            prev0 = document.getElementById(`prevBox_${folderId}_0`);
            if(prev0) {
                prev0.classList.remove("working-box");
                setBoxImage(prev0, newBlob0 ? URL.createObjectURL(newBlob0) : cacheBust(charmRes.url));
                prev0.classList.add("success-border");
            }
            const btn0 = document.getElementById(`redo_${folderId}_0`);
            if(btn0) btn0.disabled = false;

            // --- PAUSE WORKFLOW FOR INTERSTITIAL APPROVAL ---
            [1, 2, 3].forEach(i => {
                window.ACTIVE_CHARM_JOBS.delete(`${folderId}_${i}`);
                const p = document.getElementById(`prevBox_${folderId}_${i}`);
                if(p) {
                    p.classList.remove("working-box");
                    p.innerHTML = `<div class="slotRefEmpty" style="color: #fde68a;">Waiting for Base Approval...</div>`;
                }
            });

            const continueBtn = document.getElementById(`continue_${folderId}`);
            if (continueBtn) continueBtn.style.display = "block";

            setStatus("Base Charm generated. Awaiting approval to continue.");

        } catch (err) {
            console.error("Master Generation Catch:", err);
            setStatus(`Error: ${err.message}`);
            
            [0, 1, 2, 3].forEach(i => {
                window.ACTIVE_CHARM_JOBS.delete(`${folderId}_${i}`);
                const p = document.getElementById(`prevBox_${folderId}_${i}`);
                if(p) {
                    p.classList.remove("working-box");
                    if (p.innerHTML.includes("Queued") || p.innerHTML.includes("Generating") || p.innerHTML.includes("Removing") || p.innerHTML.includes("Working")) {
                        p.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
                    }
                }
                const btn = document.getElementById(`redo_${folderId}_${i}`);
                if(btn) btn.disabled = false;
            });
        } finally {
            cardNode.classList.remove("working-card");
            window.updateQuadActionButtons(folderId);
        }
    }

    executeCharmGenBtn.addEventListener("click", async () => {
        const batchCount = parseInt(document.getElementById("batchProcessCountInput").value) || 1;
        const derivCount = parseInt(document.getElementById("derivativesPerCharmInput").value) || 1;

        setBusy(true);
        setStatus("Starting Batch Generation...");
        executeCharmGenBtn.disabled = true;

        if (charmCurrentPage !== 1) {
            charmCurrentPage = 1;
            renderCharmPage();
        }
        
        try {
            const charmsToProcess = await listTopNFiles(newCharmsPath(), batchCount);
            if (charmsToProcess.length === 0) {
                alert("No reference charms loaded in the New_Charms queue. Please upload to New_Charms.");
                return;
            }

            // Ensure we at least have currentEarringRef setup properly behind the scenes
            if (!currentEarringRef) {
                currentEarringRef = await listLatestFile(newCharmsEarringsPath());
            }

            const promises = [];
            for (const charmData of charmsToProcess) {
                for (let d = 0; d < derivCount; d++) {
                    promises.push(generateCharmQuad(charmData, currentEarringRef));
                    await sleep(300); // Small stagger to mitigate rate limiting on bulk request startup
                }
            }

            // Await all background loops in this batch job
            await Promise.allSettled(promises);
            setStatus("Batch Processing Complete.");
        } catch (e) {
            console.error(e);
            setStatus(`Error: ${e.message}`);
        } finally {
            setBusy(false);
            executeCharmGenBtn.disabled = false;
        }
    });

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1–8)
    // ------------------------------------------------------------
    
    // =========================================================================
    // 0. BEADY_NECKLACE
    // =========================================================================

    const SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).

    • Critical: Never Cut out darkened areas of the Charm/Pendant. Darkened portions of the Charm/Pendant are typically hatched engravings.

    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task.

    PROCESS ORDER (NON-NEGOTIABLE)
    • Single pass only.
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY — MAKE IT BARELY VISIBLE)
    • Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    • Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;


    // =========================================================================
    // 1. // REGULAR NECKLACE
    // =========================================================================
    const REGULAR_SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE 
    • Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    Do noy cutout any engravings, preserve ALL Charm/Pendant engravings in great detail.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const REGULAR_SLOT3_SIZING_GUIDE_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT add any necklace chain, jump ring, or jewelry.
    • Do NOT move, resize, restyle, blur, or alter any text.
    • The text “~12mm x 12mm” MUST remain visible, crisp, and identical.
    • The short black pointer line MUST remain visible and MUST point to the charm exactly.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The new charm must sit in the EXACT same position as the original charm in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    • The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    • The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    • HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE 
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    • When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    • Slightly vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    • Use reference image as the base sizing-guide graphic.
    • Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    • Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    • Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    • Do NOT move, resize, restyle, blur, or alter any text.
    • Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    • The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    • Both new charms must sit in the EXACT same position as the original charms in the reference image.
    • The new charm must match the original charm’s on-image size EXACTLY.
    • This is a strict size match — no scaling up or down.

    CHARM FIDELITY
    • Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    • Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    • Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE
    • Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    • The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    • When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    • Vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the model’s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT7_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE 
    • Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    • The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    • The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

  



    // =========================================================================
    // 2. // BRACELET PROMPTS
    // =========================================================================
    const BRACELET_MODEL_PROMPT =
    `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_CREATIVE_PROMPT =
   `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SIZE_GUIDE_PROMPT =
   `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;

    const BRACELET_ENGRAVING_PROMPT =
   `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SEC_MODEL_PROMPT =
   `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    const BRACELET_PRODUCT_PROMPT =
   `  TASK:
        • Generate a photorealistic hoop earring model image based on the attached reference. 
        • Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        • Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        • Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        • Maintain zoom level and frame.
        • The Huggie/Hoop earring must be Yellow 14K gold colour 
        • DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        • Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;





    // =========================================================================
    // 3. // STUD EARRINGS PROMPTS
    // =========================================================================
    const STUD_MODEL_PROMPT =
    `TASK (Force the Charm to be EXTREMELY SMALL)
        • Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        • The new Charm must be the same or smaller size then the Reference Image. 
        • Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and thin sheet of metal, always render the Charm/Pendant completely flat
        • DO NOT allow any rounded/radius on the cutout edges.
        • The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        • Match the subject identity from reference image; Enhance the models skin realism. `;

    const STUD_CREATIVE_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • Ensure to always show the earring stud as it appears in the reference image
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SIZE_GUIDE_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure to always show the earring stud as it appears in the reference image
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be VERY SMALL)
        • Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        • The new Charm must be the same or smaller size then the Reference Image. 
        • Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        • Match the subject identity from reference image; Enhance the models skin realism. 
        • Do NOT allow engraving colour to be dark, brown, or black, ensure all engraving colours are a light shade of copper colour`;

    const STUD_PRODUCT_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • Ensure to always show the earring stud as it appears in the reference image
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin.  
        • DO NOT allow any rounded/radius on the cutout edges.
        • DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_PRODUCT_2_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • Ensure to always show the earring stud as it appears in the reference image
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    // =========================================================================
    // 4. // HOOP EARRINGS PROMPTS
    // =========================================================================

    const HOOP_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
    • Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
    • The new Charm must be the same or smaller size then the Reference Image. 
    • Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
    • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
    • HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    • DO NOT allow any rounded/radius on the cutout edges.
    • The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
    • You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
    • Match the subject identity from reference image; Enhance the models skin realism. 
    • Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.
    • Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;

    const HOOP_METAL_OPTIONS_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all 4 charm (2 Yellow Gold & 2 Silver) using the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth. `;

    const HOOP_SIZE_PROMPT =
    `  TASK:
        • Duplicate the Reference product image exactly and update all 4 charm from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;

    const HOOP_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
        • Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
        • The new Charm must be the same or smaller size then the Reference Image. 
        • Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
          HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
        • The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        • You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
        • Match the subject identity from reference image; Enhance the models skin realism. 
        • Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.`;

    const HOOP_DIMENSION_PROMPT =
    `TASK
        • Duplicate the Reference product image exactly and only update the 1 charm from the Charm Reference image.
        • Preserve all engravings as they appear in the Charm Reference image.
        • Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;

    const HOOP_PRIMARY_PRODUCT_PROMPT = 
    `  TASK:
        • Duplicate the Reference product image exactly and only update the 2 charms from the Charm Reference image.
        • Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        • Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
        • Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;

    // =========================================================================
    // 5. // CHARM ONLY PROMPTS 
    // =========================================================================
    const CHARM_TEMPLATE_PROMPT = 
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.`;

    const CHARM_TYPES_PROMPT = 
    `TASK (Force the Charm to be EXTREMELY SMALL)
        • Duplicate the reference image exactly, only replace the 3 charms (2 smaller huggie Charms and 1 necklace Charm) with the Charm Refernce image.
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • You must output any visible text exactly like in the reference image.
        • Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const CHARM_MODEL_PROMPT = 
    `TASK: (Force the Charm to be EXTREMELY SMALL)
        •Generate a high-end photorealistic commercial jewelry image based on the attached reference image, use soft studio lighting and sharp focus on the necklace chain and charm/pendant details.
        • Critically: Keep necklace chain details, chainlink spacing, size, Yellow 14K gold colour, and fidelity just like in the reference image. 
        • Maintain zoom level and frame.
        • Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • The chain must be bright realistic Yellow 14K gold colour and light reflections.
        • If you cannot measure pixels, choose the smallest size that is still legible on the chain.
        • Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
        • The chain must remain exactly the same size and detail as in the reference image.`;

    const CHARM_ENGRAVING_PROMPT = 
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • You must output any visible text exactly like in the reference image.

      HARD FAIL CONDITIONS
        • Any weak or disconnected hoop connection.`;


    const CHARM_HOOP_GUIDE_PROMPT = 
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • You must output any visible text exactly like in the reference image.`;


    const CHARM_SIZE_GUIDE_PROMPT = 
    `  TASK:
        • Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        • Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        • All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        • Ensure all engravings are a light shade of copper colour.
        • The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        • DO NOT allow any rounded/radius on the cutout edges.
        • You must output any visible text exactly like in the reference image.`;


    // =========================================================================
    // 3. MASTER MAPPING
    // =========================================================================

    const PROMPT_MAPS = {
      // 1. Regular_Necklace (Uses identical prompts to Beady)
      "Regular_Necklace": {
        1: REGULAR_DEFAULT_PROMPT,
        2: REGULAR_SLOT2_DUPLICATE_PROMPT,
        3: REGULAR_SLOT3_SIZING_GUIDE_PROMPT,
        4: REGULAR_SLOT4_PROMPT,
        5: REGULAR_SLOT5_PROMPT,
        7: REGULAR_SLOT7_PROMPT
      },
      // 2. Beady_Necklace (Original)
      "Beady_Necklace": {
        1: DEFAULT_PROMPT,
        2: SLOT2_DUPLICATE_PROMPT,
        3: SLOT3_SIZING_GUIDE_PROMPT,
        4: SLOT4_PROMPT,
        5: SLOT5_PROMPT,
        7: SLOT7_PROMPT
      },
      // 3. Stud_Earrings
      "Stud_Earrings": {
        1: STUD_MODEL_PROMPT,
        2: STUD_CREATIVE_PROMPT,
        3: STUD_SIZE_GUIDE_PROMPT,
        4: STUD_PRODUCT_PROMPT,
        5: STUD_SEC_MODEL_PROMPT,
        6: STUD_PRODUCT_2_PROMPT 
      },
      // 4. Hoop_Earrings
      "Hoop_Earrings": {
        1: HOOP_MODEL_PROMPT,
        2: HOOP_PRIMARY_PRODUCT_PROMPT,
        3: HOOP_SIZE_PROMPT,
        4: HOOP_SEC_MODEL_PROMPT,
        5: HOOP_DIMENSION_PROMPT,
        7: HOOP_METAL_OPTIONS_PROMPT
      }, 
      // 5. Charms
      "Charms": {
        1: CHARM_TEMPLATE_PROMPT, 
        2: CHARM_TYPES_PROMPT, 
        3: CHARM_MODEL_PROMPT, 
        4: CHARM_ENGRAVING_PROMPT, 
        5: CHARM_HOOP_GUIDE_PROMPT, 
        7: CHARM_SIZE_GUIDE_PROMPT 
      },
      // 6. Bracelets
      "Bracelets": {
        1: BRACELET_MODEL_PROMPT,
        2: BRACELET_CREATIVE_PROMPT,
        3: BRACELET_SIZE_GUIDE_PROMPT,
        4: BRACELET_ENGRAVING_PROMPT,
        5: BRACELET_SEC_MODEL_PROMPT,
        6: BRACELET_PRODUCT_PROMPT
      }
    };

    function buildSlotPrompt(category, folderName, slotNum) {
      const map = PROMPT_MAPS[category];
      if (map && map[slotNum]) {
        return map[slotNum];
      }
      const DEFAULT_MAP = PROMPT_MAPS["Beady_Necklace"];
      return DEFAULT_MAP[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
    // --- 1. Download Completed Listing Sets Logic (Downloads & Moves to Permanent) ---
    const downloadCompletedSetsBtn = document.getElementById("downloadCompletedSetsBtn");

    if (downloadCompletedSetsBtn) {
        downloadCompletedSetsBtn.addEventListener("click", async () => {
            if (!window.JSZip) {
                alert("JSZip library not loaded. Check your internet connection.");
                return;
            }

            const originalText = downloadCompletedSetsBtn.textContent;
            downloadCompletedSetsBtn.disabled = true;
            downloadCompletedSetsBtn.style.opacity = "0.7";
            downloadCompletedSetsBtn.textContent = "Fetching list...";

            try {
                await ensureStorageSignedIn();
                
                // Target the Completed_Listing_Sets folder
                const folderPath = `${ROOT}/Generated_Listing_Sets/Completed_Listing_Sets`;
                const baseRef = ref(storage, folderPath);
                const res = await listAll(baseRef);
                
                const prefixes = res.prefixes;
                if (prefixes.length === 0) {
                    alert("No completed sets found to download.");
                    throw new Error("Empty Directory");
                }

                const zip = new JSZip();
                let processedFolders = 0;

                // Process sequentially to keep browser memory stable
                for (const folderRef of prefixes) {
                    downloadCompletedSetsBtn.textContent = `Zipping folder ${processedFolders + 1} of ${prefixes.length}...`;
                    const folderName = folderRef.name;
                    const folderItems = await listAll(folderRef);

                    // Fetch files within the folder in parallel
                    await Promise.all(folderItems.items.map(async (itemRef) => {
                        const fileData = await getBytes(itemRef);
                        zip.file(`${folderName}/${itemRef.name}`, fileData);
                    }));
                    processedFolders++;
                }

                downloadCompletedSetsBtn.textContent = "Generating ZIP file...";
                const zipBlob = await zip.generateAsync({ type: "blob" });

                // Trigger the local browser download
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `Completed_Listing_Sets_${dateStr}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                // --- Move Sets to Permanent Storage ---
                downloadCompletedSetsBtn.textContent = "Moving to storage...";
                const destBaseFolderPath = `${ROOT}/Generated_Listing_Sets/Approved_Listing_Sets`;
                
                let movedCount = 0;
                for (const folderRef of prefixes) {
                    downloadCompletedSetsBtn.textContent = `Moving folder ${movedCount + 1} of ${prefixes.length}...`;
                    const folderName = folderRef.name;
                    const folderItems = await listAll(folderRef);
                    
                    // Copy each file to the Approved folder, then delete the original
                    for (const itemRef of folderItems.items) {
                        const fileData = await getBytes(itemRef);
                        const newFileRef = ref(storage, `${destBaseFolderPath}/${folderName}/${itemRef.name}`);
                        await uploadBytesResumable(newFileRef, fileData);
                        await deleteObject(itemRef); // Remove from Completed queue
                    }
                    movedCount++;
                }

                // Refresh UI Counters
                updateCompletedSetsCounter();
                updateTotalAllTimeCounter();

                downloadCompletedSetsBtn.textContent = "Download & Move Complete!";
                setTimeout(() => {
                    downloadCompletedSetsBtn.textContent = originalText;
                    downloadCompletedSetsBtn.disabled = false;
                    downloadCompletedSetsBtn.style.opacity = "1";
                }, 3000);

            } catch (error) {
                if (error.message !== "Empty Directory") {
                    console.error("Error downloading sets:", error);
                    alert(`Failed to download sets: ${error.message}`);
                }
                downloadCompletedSetsBtn.textContent = originalText;
                downloadCompletedSetsBtn.disabled = false;
                downloadCompletedSetsBtn.style.opacity = "1";
            }
        });
    }

    // --- 2. Download Approved Charm Sets Logic (Downloads only) ---
    const downloadApprovedSetsBtn = document.getElementById("downloadApprovedSetsBtn");

    if (downloadApprovedSetsBtn) {
        downloadApprovedSetsBtn.addEventListener("click", async () => {
            if (!window.JSZip) {
                alert("JSZip library not loaded. Check your internet connection.");
                return;
            }

            const originalText = downloadApprovedSetsBtn.textContent;
            downloadApprovedSetsBtn.disabled = true;
            downloadApprovedSetsBtn.style.opacity = "0.7";
            downloadApprovedSetsBtn.textContent = "Fetching list...";

            try {
                await ensureStorageSignedIn();
                
                // Target the correct Charm_Maker subfolder path
                const folderPath = `${ROOT}/Charm_Maker/Completed_Approved_Charm_Sets`;
                const baseRef = ref(storage, folderPath);
                const res = await listAll(baseRef);
                
                const prefixes = res.prefixes;
                if (prefixes.length === 0) {
                    alert("No approved charm sets found to download.");
                    throw new Error("Empty Directory");
                }

                const zip = new JSZip();
                let processedFolders = 0;

                for (const folderRef of prefixes) {
                    downloadApprovedSetsBtn.textContent = `Zipping folder ${processedFolders + 1} of ${prefixes.length}...`;
                    const folderName = folderRef.name; 
                    const folderItems = await listAll(folderRef);

                    await Promise.all(folderItems.items.map(async (itemRef) => {
                        const fileData = await getBytes(itemRef);
                        zip.file(`${folderName}/${itemRef.name}`, fileData);
                    }));
                    processedFolders++;
                }

                downloadApprovedSetsBtn.textContent = "Generating ZIP file...";
                const zipBlob = await zip.generateAsync({ type: "blob" });

                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `Approved_Charm_Sets_${dateStr}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                downloadApprovedSetsBtn.textContent = "Download Complete!";
                setTimeout(() => {
                    downloadApprovedSetsBtn.textContent = originalText;
                    downloadApprovedSetsBtn.disabled = false;
                    downloadApprovedSetsBtn.style.opacity = "1";
                }, 3000);

            } catch (error) {
                if (error.message !== "Empty Directory") {
                    console.error("Error downloading charm sets:", error);
                    alert(`Failed to download sets: ${error.message}`);
                }
                downloadApprovedSetsBtn.textContent = originalText;
                downloadApprovedSetsBtn.disabled = false;
                downloadApprovedSetsBtn.style.opacity = "1";
            }
        });
    }

    // --- 3. Download Permanent Storage Listing Sets Logic (Downloads only) ---
    const downloadPermanentSetsBtn = document.getElementById("downloadPermanentSetsBtn");

    if (downloadPermanentSetsBtn) {
        downloadPermanentSetsBtn.addEventListener("click", async () => {
            if (!window.JSZip) {
                alert("JSZip library not loaded. Check your internet connection.");
                return;
            }

            const originalText = downloadPermanentSetsBtn.textContent;
            downloadPermanentSetsBtn.disabled = true;
            downloadPermanentSetsBtn.style.opacity = "0.7";
            downloadPermanentSetsBtn.textContent = "Fetching list...";

            try {
                await ensureStorageSignedIn();
                
                // Target the permanent Approved_Listing_Sets folder
                const folderPath = `${ROOT}/Generated_Listing_Sets/Approved_Listing_Sets`;
                const baseRef = ref(storage, folderPath);
                const res = await listAll(baseRef);
                
                const prefixes = res.prefixes;
                if (prefixes.length === 0) {
                    alert("No permanent sets found to download.");
                    throw new Error("Empty Directory");
                }

                const zip = new JSZip();
                let processedFolders = 0;

                // Process sequentially to keep browser memory stable
                for (const folderRef of prefixes) {
                    downloadPermanentSetsBtn.textContent = `Zipping folder ${processedFolders + 1} of ${prefixes.length}...`;
                    const folderName = folderRef.name; 
                    const folderItems = await listAll(folderRef);

                    // Fetch files within the folder in parallel
                    await Promise.all(folderItems.items.map(async (itemRef) => {
                        const fileData = await getBytes(itemRef);
                        zip.file(`${folderName}/${itemRef.name}`, fileData);
                    }));
                    processedFolders++;
                }

                downloadPermanentSetsBtn.textContent = "Generating ZIP file...";
                const zipBlob = await zip.generateAsync({ type: "blob" });

                // Trigger the local browser download
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement("a");
                a.href = url;
                const dateStr = new Date().toISOString().split('T')[0];
                a.download = `All_Time_Approved_Sets_${dateStr}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                downloadPermanentSetsBtn.textContent = "Download Complete!";
                setTimeout(() => {
                    downloadPermanentSetsBtn.textContent = originalText;
                    downloadPermanentSetsBtn.disabled = false;
                    downloadPermanentSetsBtn.style.opacity = "1";
                }, 3000);

            } catch (error) {
                if (error.message !== "Empty Directory") {
                    console.error("Error downloading permanent sets:", error);
                    alert(`Failed to download permanent sets: ${error.message}`);
                }
                downloadPermanentSetsBtn.textContent = originalText;
                downloadPermanentSetsBtn.disabled = false;
                downloadPermanentSetsBtn.style.opacity = "1";
            }
        });
    }



  </script>
</body>
</html>