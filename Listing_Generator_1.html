<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
      text-align:center;
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    
    /* === UPDATED SLOT PREVIEW STYLES (Zoom/Grid support) === */
    .slotPrev {
      width:100%; 
      height:190px; 
      border-radius:12px; 
      border:1px solid var(--line); 
      background:#0b0d12; 
      overflow:hidden; /* Critical for cropping zoom */
      position: relative; /* Anchor for grid overlay */
    }
    
    .slotPrev img { 
      width:100%; 
      height:100%; 
      object-fit:contain; 
      transform-origin:center center; 
      transition: transform 0.3s ease; /* Smooth zoom transition */
      display: block;
      cursor: grab;
    }
    
    .slotPrev img:active {
      cursor: grabbing;
    }

    /* Rule-of-thirds overlay (from Index.html) */
    .slotPrev::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 700; 

      /* four thin lines at 1/3 and 2/3 */
      background-image:
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25));
      background-size: 1px 100%, 1px 100%, 100% 1px, 100% 1px;
      background-position: 33.333% 0, 66.666% 0, 0 33.333%, 0 66.666%;
      background-repeat: no-repeat;
    }

    /* Success border style */
    .slotPrev.success-border {
      border: 3px solid lightgreen !important;
    }

    /* === CHARM MAKER QUAD LAYOUT === */
    .charm-card {
      background: #0e1220; 
      border: 1px solid var(--line); 
      border-radius: 14px; 
      padding: 14px;
      grid-column: span 2; /* takes 2 columns out of 4 */
      display: grid; 
      grid-template-columns: 1fr 1fr; 
      gap: 14px;
    }
    .charm-card-title { 
      grid-column: span 2; 
      font-size: 14px; 
      color: #7fdb96; 
      border-bottom: 1px solid var(--line); 
      padding-bottom: 8px; 
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .charm-col { 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
    }
    .charm-col .muted { margin-bottom: 0; }

    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Listing-Generator-1</h1>

      <div class="row" style="margin-bottom: 14px; background: #0e1220; padding: 4px; border-radius: 12px; border: 1px solid var(--line);">
        <button class="btn" id="toggleGenerate" style="flex:1; background: var(--line); border:none; color: var(--text);">Generate</button>
        <button class="btn" id="toggleReview" style="flex:1; background: transparent; border:none; color: var(--muted);">Review</button>
        <button class="btn" id="toggleCharmMaker" style="flex:1; background: transparent; border:none; color: var(--muted);">Charm Maker</button>
      </div>
      
      <div id="generateSection">
        <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>

        <label>Category (Storage source of truth)</label>
        <select id="activeCategory"></select>
        <div class="muted" style="margin-top:6px;">
          Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
          <br>
          <strong>Note:</strong> Stud/Hoop Earrings use <code>New_Charms_Earrings</code>. Others use <code>New_Charms</code>.
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="generateSet">Generate Set (Randomized Refs)</button>
        </div>

        <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
        <div id="panels"></div>

        <label style="margin-top:12px;">Shared Pool (Autoselected based on category)</label>
        <div id="panelNewCharms"></div>
      </div>

      <div id="reviewSection" style="display: none;">
        <label style="margin-top:12px;">Select Set to Review</label>
        <div class="row">
          <select id="reviewSetSelect"></select>
        </div>
        <div class="row" style="margin-top:10px;">
           <button class="btn" id="approveSetBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Approve Set (Move to Completed)</button>
        </div>
        <div style="margin-top: 8px; font-size: 11px; color: var(--muted);" id="backgroundQueueStatus"></div>
      </div>

      <div id="charmMakerSection" style="display: none;">
        <div class="row" style="margin-top:12px; gap: 14px;">
          <div style="flex:1;">
            <label>New_Charms (Next Available)</label>
            <div class="slotPrev" id="previewNewCharms"><div class="slotRefEmpty">Loading...</div></div>
          </div>
          <div style="flex:1;">
            <label>New_Charms_Earrings (Next Available)</label>
            <div class="slotPrev" id="previewNewCharmsEarrings"><div class="slotRefEmpty">Loading...</div></div>
          </div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn" id="executeCharmGenBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Generate Charms</button>
        </div>
      </div> 
    </div> 
    
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
      
      <div id="charmPagination" class="row" style="display: none; justify-content: space-between; align-items: center; margin-top: 14px; padding: 10px; background: #0e1220; border-radius: 12px; border: 1px solid var(--line);">
          <button class="btn btnSmall" id="charmPrevPage" style="width: 80px;">Previous</button>
          <div id="charmPageInfo" class="muted">Page 1</div>
          <button class="btn btnSmall" id="charmNextPage" style="width: 80px;">Next</button>
      </div>
    </div>
  </div> 

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, getBytes, listAll, getMetadata, deleteObject } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    // --- Netlify functions base (Safely handle file:// fallback) ---
    let originStr = window.location.origin;
    if (!originStr || originStr === "null" || window.location.protocol === "file:") {
      originStr = "https://listing-generator-1.goldenspike.app"; // Fallback if opened locally
    }
    const functionsBaseUrl = `${originStr}/.netlify/functions`;

    // -------------------------
    // Per-slot folder layout (Firebase Storage)
    // -------------------------
    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "New_Charms",
      "New_Charms_Earrings", // Added for clarity, though it's a shared folder
      "Completed_Charm",
    ];

    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Product_Shots_2",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],

      Hoop_Earrings: [
        "Hoop_Earring_Models","Hoop_Earring_Sec_Models","Hoop_Charm_Dimensions","Hoop_Metal_Options","Hoop_Size_Options","Hoop_Model_Size_Guide","Hoop_Earring_Care_Guide","Hoop_Primary_Product","Ready_To_List","Completed_&_Listed_Sets" 
      ],

      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      New_Charms: [],
      New_Charms_Earrings: [],
      Completed_Charm: [],
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots_2" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Hoop_Earring_Models" },       // Slot 1
        { type:"gen", folder:"Hoop_Primary_Product" },      // Slot 2
        { type:"gen", folder:"Hoop_Size_Options" },         // Slot 3
        { type:"gen", folder:"Hoop_Earring_Sec_Models" },   // Slot 4       
        { type:"gen", folder:"Hoop_Charm_Dimensions" },     // Slot 5
        { type:"copy", folder:"Hoop_Model_Size_Guide" },    // Slot 6
        { type:"gen", folder:"Hoop_Metal_Options" },        // Slot 7 
        { type:"copy", folder:"Hoop_Earring_Care_Guide" },  // Slot 8
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Care_Metal_Guide" },
      ],
    };

    // --- Firebase config (matches shipping-1 patterns) ---
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    // âœ… IMPORTANT: use COMPAT auth so COMPAT firestore (window.db) has permissions
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth âœ”", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth âŒ", e);
    }

    window.db = firebase.firestore();

    // Firestore transport hardening
    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    // modular twin (same approach as shipping-1 resumable uploader)
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    
    // -------------------------------------------------------------------------
    // NEW: Zoom & Pan Logic (Ported from Index.html)
    // -------------------------------------------------------------------------
    function attachPreviewBoxListeners(box) {
      function clampAndApply(img, scale, offX, offY) {
        const viewportW = box.clientWidth || 120;
        const viewportH = box.clientHeight || 120;
        const baseW = img.clientWidth || 120;   
        const baseH = img.clientHeight || 120;
        const scaledW = baseW * scale;
        const scaledH = baseH * scale;

        const maxX = Math.max(0, (scaledW - viewportW) / 2 / scale);
        const maxY = Math.max(0, (scaledH - viewportH) / 2 / scale);

        offX = Math.max(-maxX, Math.min(maxX, offX));
        offY = Math.max(-maxY, Math.min(maxY, offY));

        img.dataset.scale = scale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `scale(${scale}) translate(${offX}px, ${offY}px)`;
      }

      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0, dragStartY = 0;
      let lastX = 0, lastY = 0;
      const dragThreshold = 3;
      const MAX_SCALE = 8;
      
      if (typeof ResizeObserver !== "undefined") {
        const ro = new ResizeObserver(() => {
          const img = box.querySelector("img");
          if (!img) return;
          const s = parseFloat(img.dataset.scale) || 1;
          let offX = parseFloat(img.dataset.offsetX) || 0;
          let offY = parseFloat(img.dataset.offsetY) || 0; 
          clampAndApply(img, s, offX, offY);
        });
        ro.observe(box);
      }

      box.addEventListener("wheel", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;

        if (ev.deltaY < 0) {
          currentScale *= 1.1;            // zoom in
        } else {
          currentScale /= 1.1;            // zoom out
          if (currentScale <= 1) {        // snap back
            currentScale = 1;
            offX = 0; offY = 0;
          }
        }
        if (currentScale > MAX_SCALE) currentScale = MAX_SCALE;
        clampAndApply(img, currentScale, offX, offY);
      });

      box.addEventListener("mousedown", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;        
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX; dragStartY = ev.clientY;
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mousemove", function (ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;

        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = (ev.clientX - lastX) * 0.5;
        const dy = (ev.clientY - lastY) * 0.5;
        offX += dx; offY += dy;
        clampAndApply(img, scaleNow, offX, offY);
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mouseup",   () => { isMouseDown = false; });
      box.addEventListener("mouseleave",() => { isMouseDown = false; });

      box.addEventListener("click", function (ev) {
        if (isDragging) { isDragging = false; return; }
        const img = box.querySelector("img");
        if (!img) return;

        const s0    = parseFloat(img.dataset.scale)   || 1;
        const offX0 = parseFloat(img.dataset.offsetX) || 0;
        const offY0 = parseFloat(img.dataset.offsetY) || 0;

        const rect = box.getBoundingClientRect();
        const cx = rect.left + box.clientWidth  / 2;
        const cy = rect.top  + box.clientHeight / 2;
        const dx_screen = ev.clientX - cx;
        const dy_screen = ev.clientY - cy;

        const px = dx_screen / s0 - offX0;
        const py = dy_screen / s0 - offY0;

        let targetOffX = -px;
        let targetOffY = -py;

        const halfW = (img.clientWidth  || 120) / 2;
        const halfH = (img.clientHeight || 120) / 2;
        function requiredScaleFor(delta, half) {
          const ratio = Math.abs(delta) / half;     
          if (ratio >= 1) return Infinity;          
          return 1 / (1 - ratio);                   
        }
        const needX = requiredScaleFor(targetOffX, halfW);
        const needY = requiredScaleFor(targetOffY, halfH);

        const DESIRED = 1.33;                          
        let s1 = Math.max(DESIRED, s0 * 1.5, needX, needY);
        if (!Number.isFinite(s1)) s1 = MAX_SCALE;
        if (s1 > MAX_SCALE) s1 = MAX_SCALE;
        
        if (s0 > 1.2 && Math.abs(s1 - s0) < 0.5) s1 = 1; 

        clampAndApply(img, s1, targetOffX, targetOffY);
      });
    }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 600000);  
      const intervalMs = Number(opts.intervalMs ?? 3000);   
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);

      await sleep(Math.random() * 3000); 

      const t0 = Date.now();
      while (true) {
        await ensureStorageSignedIn();

        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (!String(e2?.message || e2).includes("slot_not_updated_yet")) {
                   // keep waiting
                }
                throw e2;
              }
            }

            try {
              const url = await getDownloadURL(hit);
              return { storagePath: hit.fullPath, url };
            } catch (eUrl) {
              const msg = String(eUrl?.message || eUrl);
              const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");

              if (looksUnauthorized) {
                throw new Error(`Cannot download ${hit.fullPath} (permission/token issue).`);
              }
              throw eUrl;
            }
          }
        } catch (e) {
          const msg = String(e?.message || e);
          if (msg.includes("500") || msg.includes("internal")) {
             console.warn("Storage 500 error, retrying with backoff...", outputBasePath);
             await sleep(5000); 
          } else {
             const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");
             if (looksUnauthorized) {
                throw new Error(`Storage rules block LIST on: ${outputBasePath}`);
             }
          }
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs);
      }
    }

    // --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const charmPaginationEl = document.getElementById("charmPagination");

    // --- Mode Variables ---
    const toggleGenerateBtn = document.getElementById("toggleGenerate");
    const toggleReviewBtn = document.getElementById("toggleReview");
    const toggleCharmMakerBtn = document.getElementById("toggleCharmMaker");
    const generateSection = document.getElementById("generateSection");
    const reviewSection = document.getElementById("reviewSection");
    const charmMakerSection = document.getElementById("charmMakerSection");
    const reviewSetSelect = document.getElementById("reviewSetSelect");
    const approveSetBtn = document.getElementById("approveSetBtn"); 
    const backgroundQueueStatus = document.getElementById("backgroundQueueStatus"); 
    let appMode = "generate"; 

    function setStatus(msg){ statusEl.textContent = msg; }

    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
    }

    let CURRENT_SET = null; 
    const REDO_STATE = {}; 

    function setAllRedoEnabled(enabled){
      gridEl.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet.");
      }

      const ctxSetPath = CURRENT_SET.outputBasePath;
      const ctxCategory = CURRENT_SET.category;
      const ctxSetN = CURRENT_SET.setN;
      
      const slotPlan = SLOT_MAP[ctxCategory];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex}`);
      
      const redoKey = `${ctxSetPath}::${slotIndex}`;

      REDO_STATE[redoKey] = { status: 'running' };
      updateDropdownLabels(); 
      updateApproveButtonState(); 

      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${ctxSetPath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {}

      const isViewing = (CURRENT_SET?.outputBasePath === ctxSetPath);
      
      if (isViewing) {
          const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
          const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
          const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
          
          if (redoBtn) redoBtn.disabled = true;
          if (prevBox) {
              prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
              prevBox.classList.remove("success-border"); 
          }
          setStatus(`Redo Slot ${slotIndex + 1}â€¦`);
      }

      const srcFolder = slotRefFolder(ctxCategory, spec.folder);
      const srcRandom = await listRandomFile(srcFolder); 
      if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);

      const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(ctxCategory);
      const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
      const charmLatest = await listLatestFile(charmFolderPath); 
      if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);
      
      let waitedResult = null; 

      try {
          if (spec.type === "copy") {
            const r = await postJson(GEMINI_FN, {
              kind: "copy_to_slot",
              activeCategory: ctxCategory,
              source_storage_path: srcRandom.fullPath, 
              output_base_path: ctxSetPath,
              slotIndex,
            });

            waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          } else {
            await postJson(GEMINI_BG_FN, {
              kind: "edits",
              activeCategory: ctxCategory,
              input_storage_path: srcRandom.fullPath, 
              input_charm_storage_path: charmLatest.fullPath,
              output_base_path: ctxSetPath,
              slotIndex,
              model: "gemini-3-pro-image-preview",
              prompt: buildSlotPrompt(ctxCategory, spec.folder, slotIndex + 1),
            });

              waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          }
          
          const finalUrl = cacheBust(waitedResult.url);
          REDO_STATE[redoKey] = { status: 'completed', url: finalUrl };
          updateDropdownLabels(); 
          updateApproveButtonState();

          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
              const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
              const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
              const metaEl   = slotCard?.querySelector(`#slotMeta_${slotIndex}`);
              const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
              
              if (prevBox) {
                  prevBox.innerHTML = `<img src="${finalUrl}" />`;
                  attachPreviewBoxListeners(prevBox);
                  prevBox.classList.add("success-border"); 
              }
              if (metaEl) metaEl.textContent = `Source: ${srcRandom.fullPath}`;
              if (redoBtn) redoBtn.disabled = false;
              setStatus(`Ready (Set_${ctxSetN})`);
          }

      } catch(err) {
          console.error("Redo failed", err);
          delete REDO_STATE[redoKey];
          updateDropdownLabels();
          updateApproveButtonState(); 
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
             const prevBox = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"] #slotPrev_${slotIndex}`);
             if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Error</div>`;
             setStatus("Redo failed: " + err.message);
          }
      }

      try {
        const manifestRef = ref(storage, `${ctxSetPath}/manifest.json`);
        const buffer = await getBytes(manifestRef);
        const text = new TextDecoder().decode(buffer);
        const manifestJson = JSON.parse(text);

        const slotNum = slotIndex + 1;
        const idx = manifestJson.slots.findIndex(s => s.slot === slotNum);
        
        const newEntry = {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcRandom.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waitedResult?.storagePath || "",
            updatedAt: new Date().toISOString()
        };

        if (idx > -1) {
            manifestJson.slots[idx] = { ...manifestJson.slots[idx], ...newEntry };
        } else {
            manifestJson.slots.push(newEntry);
            manifestJson.slots.sort((a,b) => a.slot - b.slot);
        }

        await postJson("geminiImageProxy", {
            kind: "write_manifest",
            activeCategory: ctxCategory,
            output_base_path: ctxSetPath,
            manifest: manifestJson,
        });
      } catch (e) {
        console.warn("Manifest update failed (non-fatal):", e);
      }
    }
    
    window.redoSlot = redoSlot;

    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/New_Charms`;
    }

    function newCharmsEarringsPath() {
      return `${ROOT}/New_Charms_Earrings`;
    }

    async function listRandomFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      
      if (!res.items?.length) return null;

      const randomIndex = Math.floor(Math.random() * res.items.length);
      const randomItem = res.items[randomIndex];
      const url = await getDownloadURL(randomItem);
      return { fullPath: randomItem.fullPath, name: randomItem.name, url };
    }

    async function listLatestFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loadingâ€¦</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          console.warn("[Storage:listAll] failed", { targetFullPath, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading â†’ ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      if (["Stud_Earrings", "Hoop_Earrings"].includes(category)) {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsEarringsPath(), "New_Charms_Earrings (Earrings Only)"));
      } else {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms (Necklaces/Other)"));
      }

      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);

    // --- Tab Switching Logic ---
    function setAppMode(mode) {
      appMode = mode;
      
      toggleGenerateBtn.style.background = "transparent";
      toggleGenerateBtn.style.color = "var(--muted)";
      toggleReviewBtn.style.background = "transparent";
      toggleReviewBtn.style.color = "var(--muted)";
      toggleCharmMakerBtn.style.background = "transparent";
      toggleCharmMakerBtn.style.color = "var(--muted)";
      
      generateSection.style.display = "none";
      reviewSection.style.display = "none";
      charmMakerSection.style.display = "none";
      charmPaginationEl.style.display = "none"; 
      
      gridEl.innerHTML = "";

      if (mode === "generate") {
        toggleGenerateBtn.style.background = "var(--line)";
        toggleGenerateBtn.style.color = "var(--text)";
        generateSection.style.display = "block";
        renderCategoryUI(activeCategoryEl.value);
        setStatus("Ready");
      } else if (mode === "review") {
        toggleReviewBtn.style.background = "var(--line)";
        toggleReviewBtn.style.color = "var(--text)";
        reviewSection.style.display = "block";
        loadReviewSets();
      } else if (mode === "charmMaker") {
        toggleCharmMakerBtn.style.background = "var(--line)";
        toggleCharmMakerBtn.style.color = "var(--text)";
        charmMakerSection.style.display = "block";
        setStatus("Charm Maker Database");
        loadCharmMakerPreviews();
        loadCharmMakerHistory(); // Initialize the custom grid
      }
    }

    toggleGenerateBtn.addEventListener("click", () => setAppMode("generate"));
    toggleReviewBtn.addEventListener("click", () => setAppMode("review"));
    toggleCharmMakerBtn.addEventListener("click", () => setAppMode("charmMaker"));


    activeCategoryEl.addEventListener("change", () => {
      if (appMode === "generate") {
        renderCategoryUI(activeCategoryEl.value);
      } else if (appMode === "review") {
        loadReviewSets();
        gridEl.innerHTML = "";
      }
    });

    async function loadReviewSets() {
      const category = activeCategoryEl.value;
      setStatus("Loading sets...");
      reviewSetSelect.innerHTML = `<option>Loading...</option>`;
      try {
        await ensureStorageSignedIn();
        const readyToListRef = ref(storage, `${ROOT}/${category}/Ready_To_List`);
        const res = await listAll(readyToListRef);
        const sets = res.prefixes.map(p => p.name).filter(n => n.startsWith('Set_'));
        sets.sort((a, b) => {
          const numA = parseInt(a.replace('Set_', '')) || 0;
          const numB = parseInt(b.replace('Set_', '')) || 0;
          return numB - numA;
        });

        if (sets.length > 0) {
          reviewSetSelect.innerHTML = sets.map(s => `<option value="${s}">${s}</option>`).join("");
          setStatus(`Found ${sets.length} sets.`);
          updateDropdownLabels();
          if (reviewSetSelect.value) {
              loadSetImages(reviewSetSelect.value);
          }
        } else {
          reviewSetSelect.innerHTML = `<option value="">No sets found</option>`;
          setStatus("No sets found.");
          gridEl.innerHTML = "";
        }
      } catch (e) {
        console.error("Error loading sets:", e);
        setStatus("Error loading sets");
        reviewSetSelect.innerHTML = `<option value="">Error loading</option>`;
      }
    }
    
    function updateDropdownLabels() {
        if(appMode !== "review") return;
        const category = activeCategoryEl.value;
        const options = Array.from(reviewSetSelect.options);
        
        options.forEach(opt => {
            const setName = opt.value;
            if (!setName) return;
            const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
            const statuses = [];
            Object.keys(REDO_STATE).forEach(key => {
                if (key.startsWith(setPath)) {
                    const slotIdx = key.split('::')[1];
                    const slotNum = parseInt(slotIdx) + 1;
                    const state = REDO_STATE[key];
                    if (state.status === 'running') {
                        statuses.push(`Slot ${slotNum}: â³`);
                    } else if (state.status === 'completed') {
                        statuses.push(`Slot ${slotNum}: ðŸŸ¢`);
                    }
                }
            });
            if (statuses.length > 0) {
                opt.text = `${setName} (${statuses.join(', ')})`;
            } else {
                opt.text = setName;
            }
        });
    }

    function updateApproveButtonState() {
      if (!approveSetBtn) return;
      
      const setGreen = () => {
        approveSetBtn.disabled = false;
        approveSetBtn.style.background = "#1f4026";
        approveSetBtn.style.color = "#7fdb96";
        approveSetBtn.style.border = "1px solid #2f5e3a";
        approveSetBtn.textContent = "Approve Set (Move to Completed)";
        approveSetBtn.style.cursor = "pointer";
        approveSetBtn.style.opacity = "1";
      };

      const setOrange = () => {
        approveSetBtn.disabled = true;
        approveSetBtn.style.background = "#7c2d12"; 
        approveSetBtn.style.color = "#fdba74"; 
        approveSetBtn.style.border = "1px solid #ea580c";
        approveSetBtn.textContent = "Waiting for Redo...";
        approveSetBtn.style.cursor = "not-allowed";
        approveSetBtn.style.opacity = "0.8";
      };

      if (!CURRENT_SET || appMode !== 'review') return; 

      const setPath = CURRENT_SET.outputBasePath;
      let hasRunning = false;
      
      Object.keys(REDO_STATE).forEach(k => {
        if (k.startsWith(setPath) && REDO_STATE[k].status === 'running') {
          hasRunning = true;
        }
      });

      if (hasRunning) {
        setOrange();
      } else {
        setGreen();
      }
    }

    async function loadSetImages(setName) {
      if (!setName) return;

      const category = activeCategoryEl.value;
      setBusy(true);
      setStatus(`Loading ${setName}...`);
      gridEl.innerHTML = "";

      try {
        await ensureStorageSignedIn();
        const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const setRef = ref(storage, setPath);
        const res = await listAll(setRef);

        let parsedSetN = parseInt(setName.replace('Set_', '')) || 0;
        CURRENT_SET = { category, outputBasePath: setPath, setN: parsedSetN };

        let manifestData = null;
        try {
            const manifestRef = ref(storage, `${setPath}/manifest.json`);
            const buffer = await getBytes(manifestRef);
            const text = new TextDecoder().decode(buffer);
            manifestData = JSON.parse(text);
        } catch(err) {}

        const slotPlan = SLOT_MAP[category] || [];
        
        slotPlan.forEach((spec, i) => {
          const slotNum = i + 1;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i;

          let sourceStr = "Unknown";
          if (manifestData && manifestData.slots) {
              const slotMeta = manifestData.slots.find(s => s.slot === slotNum);
              if (slotMeta && slotMeta.source) sourceStr = slotMeta.source;
          }

          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">Review: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Loadingâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${sourceStr}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        });

        slotPlan.forEach((_, i) => {
             const key = `${setPath}::${i}`;
             const state = REDO_STATE[key];
             const prevBox = document.getElementById(`slotPrev_${i}`);
             const redoBtn = document.getElementById(`redo_${i}`);

             if (state && state.status === 'running') {
                 if (prevBox) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
                    prevBox.classList.remove("success-border");
                 }
                 if (redoBtn) redoBtn.disabled = true;
             } 
             else if (state && state.status === 'completed') {
                 if (prevBox) prevBox.classList.add("success-border");
             }
        });

        const slotFiles = res.items.filter(item => item.name.startsWith("Slot_") && item.name.endsWith(".png"));
        
        await Promise.all(slotFiles.map(async (fileRef) => {
          const match = fileRef.name.match(/Slot_(\d+)\.png/);
          if (match) {
            const slotIndex = parseInt(match[1]) - 1;
            
            const key = `${setPath}::${slotIndex}`;
            if (REDO_STATE[key]?.status === 'running') return;

            try {
              const url = await getDownloadURL(fileRef);
              const prevBox = document.getElementById(`slotPrev_${slotIndex}`);
              if (prevBox) {
                const finalUrl = cacheBust(url);
                prevBox.innerHTML = `<img src="${finalUrl}" />`;
                attachPreviewBoxListeners(prevBox);
              }
            } catch (err) {}
          }
        }));

        slotPlan.forEach((spec, i) => {
          const prevBox = document.getElementById(`slotPrev_${i}`);
          if (prevBox && prevBox.innerHTML.includes("Loadingâ€¦")) {
            prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
          }
        });

        setStatus(`Viewing ${category} / ${setName}`);
      } catch (e) {
        if (e.code === 'storage/object-not-found') {
             gridEl.innerHTML = `<div class='slotRefEmpty'>Set '${setName}' not found (might be deleted/moved).</div>`;
        } else {
             console.error(e);
             setStatus(`Error: ${e.message}`);
        }
      } finally {
        setBusy(false);
        updateApproveButtonState(); 
      }
    }
    
    reviewSetSelect.addEventListener("change", (e) => {
        loadSetImages(e.target.value);
    });

    function approveSet() {
      const category = activeCategoryEl.value;
      const setName = reviewSetSelect.value;
      if (!setName) return;

      if (!confirm(`Approve ${setName}? (Instant Queue)`)) return;

      const optionToRemove = reviewSetSelect.querySelector(`option[value="${setName}"]`);
      if (optionToRemove) optionToRemove.remove();

      if (reviewSetSelect.options.length > 0) {
          reviewSetSelect.selectedIndex = 0; 
          loadSetImages(reviewSetSelect.value);
      } else {
          gridEl.innerHTML = "<div class='slotRefEmpty'>No more sets to review!</div>";
          setStatus("Queue clear.");
      }

      runBackgroundApproval(category, setName);
    }

    async function runBackgroundApproval(category, setName) {
        const queueId = `${category}/${setName}`;
        backgroundQueueStatus.textContent = `Queued: ${setName}...`;
        console.log(`[Queue] Starting background move for ${setName}`);

        const srcFolder = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const destFolderName = `${category}_${setName}`; 
        const destFolder = `${ROOT}/Completed_Sets/${destFolderName}`;

        try {
            await ensureStorageSignedIn();
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const itemRef of res.items) {
               const buffer = await getBytes(itemRef);
               const newRef = ref(storage, `${destFolder}/${itemRef.name}`);
               await uploadBytesResumable(newRef, buffer); 
               await deleteObject(itemRef);
            }
            console.log(`[Queue] Finished moving ${setName}`);
            backgroundQueueStatus.textContent = `Completed: ${setName}`;
            
            setTimeout(() => {
                if (backgroundQueueStatus.textContent.includes(setName)) {
                    backgroundQueueStatus.textContent = "";
                }
            }, 3000);

        } catch (e) {
            console.error(`[Queue] Failed to move ${setName}`, e);
            backgroundQueueStatus.textContent = `Error moving ${setName}`;
        }
    }

    approveSetBtn.addEventListener("click", approveSet);
    
    async function postJson(path, body) {
      const res = await fetch(`${functionsBaseUrl}/${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      const raw = await res.text().catch(() => "");
      let j = null;
      try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

      if (!res.ok) {
        const msg = (j?.error?.message || j?.error) || (raw ? raw.slice(0, 300) : "") || `HTTP ${res.status}`;
        throw new Error(msg);
      }

      if (!j) {
        if (res.status === 202 && (!raw || !raw.trim())) {
          return { ok: true, accepted: true, status: 202 };
        }
        throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
      }
      return j;
    }

    const GEMINI_FN = "geminiImageProxy";
    const GEMINI_BG_FN = "geminiImageProxy-background";

    async function allocSet(category) {
      return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
    }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

        setStatus("Allocating Setâ€¦");
        const alloc = await allocSet(category);
        const outputBasePath = normalizeAllocOutputBasePath(alloc);
        if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

        let setN = alloc?.setN ?? alloc?.set_n;
        if (setN == null) {
          const m = outputBasePath.match(/\/Set_(\d+)\b/);
          if (m) setN = Number(m[1]);
        }

        CURRENT_SET = { category, outputBasePath, setN };

        const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(category);
        const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
        
        const charmLatest = await listLatestFile(charmFolderPath);
        if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);

        const manifest = {
          category,
          setN,
          outputBasePath,
          timestamp: new Date().toISOString(),
          slots: [],
          model: "gemini-3-pro-image-preview",
        };

        setStatus("Preparing slots (Randomizing)â€¦");
        const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
          const srcFolder = slotRefFolder(category, spec.folder);
          const srcRandom = await listRandomFile(srcFolder);
          if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);
          return { spec, i, slotNum: i + 1, srcLatest: srcRandom };
        }));

        gridEl.innerHTML = "";
        for (const r of slotResolved) {
          const { spec, i, slotNum, srcLatest } = r;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i; 
          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Queuedâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" disabled onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        }

        setStatus("Starting background runâ€¦");

        const tasks = slotResolved.map((r) => {
          const { spec, i, slotNum, srcLatest } = r;
          if (spec.type === "copy") {
            return {
              type: "copy",
              slotIndex: i,
              source_storage_path: srcLatest.fullPath,
            };
          }
          return {
            type: "edits",
            slotIndex: i,
            input_storage_path: srcLatest.fullPath,
            input_charm_storage_path: charmLatest.fullPath, 
            prompt: buildSlotPrompt(category, spec.folder, slotNum),
            model: "gemini-3-pro-image-preview",
          };
        });

        const pollingPromise = Promise.all(slotResolved.map(async (r) => {
          const { spec, i, slotNum, srcLatest } = r;
          const prevBox = document.getElementById(`slotPrev_${i}`);
          const setImg = (url) => { 
            if (prevBox) {
                prevBox.innerHTML = `<img src="${url}" />`;
                attachPreviewBoxListeners(prevBox);
            } 
          };

          const waited = await waitForSlotPngUrl(outputBasePath, i);
          const finalUrl = `${waited.url}${waited.url.includes("?") ? "&" : "?"}cb=${Date.now()}`;
          setImg(finalUrl);

          return {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcLatest.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waited.storagePath,
          };
        }));

        try {
            await postJson(GEMINI_BG_FN, {
              kind: "run_set_async",
              activeCategory: category,
              output_base_path: outputBasePath,
              delayMs: 20000, 
              tasks,
            });
            console.log("Background run triggered successfully");
        } catch (err) {
            throw new Error(`Failed to start generation on server: ${err.message}`);
        }

        setStatus("Generatingâ€¦ (Monitoring Storage)");

        const results = await pollingPromise;
        results.sort((a, b) => a.slot - b.slot);
        manifest.slots = results;

        setStatus("Writing manifestâ€¦");
        await postJson("geminiImageProxy", {
          kind: "write_manifest",
          activeCategory: category,
          output_base_path: outputBasePath,
          manifest,
        });

        setStatus(`Done â†’ ${category}/Ready_To_List/Set_${setN}`);
        setAllRedoEnabled(true);
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      } finally {
        setBusy(false);
      }
    }

    // --- Charm Maker Logic ---
    let currentCharmRef = null;
    let currentEarringRef = null;

    const previewNewCharms = document.getElementById("previewNewCharms");
    const previewNewCharmsEarrings = document.getElementById("previewNewCharmsEarrings");
    const executeCharmGenBtn = document.getElementById("executeCharmGenBtn");

    // --- Charm Maker Pagination State ---
    let charmSetsHistory = [];
    let charmCurrentPage = 1;
    const CHARM_ITEMS_PER_PAGE = 50;

    // Base prompts hoisted for global access
    const promptStrCharm = `CRITICAL INITIAL ANALYSIS: Before generating, conceptually analyze the reference image to determine its exact genre and subject matter (e.g., "Genre: Animal, Subject Matter: Rabbit/Leporidae"). Use this specific analysis as the strict foundational concept for the new charm. DO NOT add additional jump rings, bails, or chains under ANY circumstances.

    TASK: Generate a highly realistic, 2D jewelry charm that functions as a thematic and aesthetic extension of the provided reference based on your analysis. Your goal is to keep the SAME genre and loosely similar subject matter and overall concept but adapt it to attract similar audiences.

    HARD PHYSICAL CONSTRAINTS (NON-NEGOTIABLE):
    â€¢ Use engravings very sparingly and very strategically. Do not cram too many pointless engravings onto the charm.
    â€¢ Leave a lot of white space between the engravings; do not bunch up engravings and cutouts closely together.
    â€¢ FLAT SHEET METAL: The charm must appear as a perfectly flat, thin sheet of high-polish metal.
    â€¢ SHARP 2D CUTOUTS: Use laser-cut precision. Do NOT allow rounded edges, bevels, or 3D thickness.
    â€¢ VIEWPOINT: Always render the charm perfectly front-facing (orthographic) with 0% perspective tilt.
    â€¢ BACKGROUND COLOR (CRITICAL & ABSOLUTE): You MUST generate the charm on a 100% PURE SOLID BLACK (#000000) background. Absolutely NO white backgrounds, NO grey backgrounds, NO gradients, and NO transparency. If the background is not pure black, it is a failure.
    â€¢ NO TEXT: Never render letters, numbers, or words.

    THEMATIC & AESTHETIC EVOLUTION:
    â€¢ You may only introduce minor stylistic alterations to the outer contour (e.g., slightly sharper points, smoother curves, or stylistic edges) while preserving the exact overall recognizable footprint.
    â€¢ AESTHETIC ANCHORING: Maintain the exact gold tone, luminosity, and "luxe-minimalist" feel of the reference image. The "vibe" must remain cohesive.
    â€¢ ENGRAVING DEPTH: All internal details must be surface-level laser etchings. No embossing or 3D extrusion.

    NEGATIVE CONSTRAINTS (NEVER DO THESE - EXTREME PENALTY):
    â€¢ NEVER generate a white or light background. It MUST be pure solid black (#000000).
    â€¢ NEVER add additional jump rings, O-rings, bails, or chains of any kind.
    â€¢ NEVER introduce 3D volume, thickness, or side-profile views.
    â€¢ NEVER use matte or brushed textures if the reference is high-polish.
    â€¢ NEVER deviate from the established level of intricate detail seen in the reference.
    
    HOOP/BAIL REQUIREMENT (CRITICAL):
    â€¢ We must ensure that the integrated hoop already present in the reference image MUST ALWAYS be correctly and strategically positioned on the newly generated Charm. THIS IS A MUST AND ABSOLUTELY CRUCIAL!!!! DO NOT ADD EXTRA JUMP RINGS TO IT.`;

    const promptStrEarring = `CRITICAL INSTRUCTION: Analyze the provided reference image of a jewelry charm. 
    Your task is to generate an image that is 100% identical to this reference, keeping everything absolutely the same, with ONLY 1 EXCEPTION:
    
    Exception 1: Completely remove the hoop/bail from the top of the charm.

    HARD CONSTRAINTS (NON-NEGOTIABLE):
    â€¢ BACKGROUND COLOR (CRITICAL): Keep the exact same solid pure black (#000000) background. ABSOLUTELY NO white, grey, or transparent backgrounds.
    â€¢ JUMP RINGS: NEVER add jump rings, O-rings, bails, or chains.
    â€¢ Keep all engravings, cutouts, overall shape, proportions, and gold tone 100% identical to the reference.
    â€¢ Do not introduce any new elements, 3D thickness, or styling changes.
    â€¢ The final output MUST be the exact same charm, just missing the top hoop, on a PURE BLACK background.`;

    const promptStrBW = `TASK: Generate a black and white outline image based strictly on the newly generated charm shown in the FIRST image. 
    Use the SECOND image strictly as a stylistic sample output to better understand the desired line art style outcome.

    HARD CONSTRAINTS (NON-NEGOTIABLE):
    â€¢ Create a black and white outline image using the newly generated charm.
    â€¢ Pay very close attention to the engraving details and follow the lines exactly.
    â€¢ Fill in all engravings with solid black colour.
    â€¢ Be very accurate as to the size, position, and exact details of the charm engravings.
    â€¢ Ensure the Charm outer perimeter black outline line is only 2px thick.
    â€¢ Use a solid, pure WHITE (#FFFFFF) background. Absolutely no transparency.
    â€¢ Do NOT add any shading, 3D extrusion, colours, or grey tones. Flat 2D vector style only.`;

    async function loadCharmMakerPreviews() {
      previewNewCharms.innerHTML = `<div class="slotRefEmpty">Fetching...</div>`;
      previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Fetching...</div>`;
      try {
        await ensureStorageSignedIn();
        const charmsLatest = await listLatestFile(newCharmsPath());
        currentCharmRef = charmsLatest;
        if (charmsLatest) {
          previewNewCharms.innerHTML = `<img src="${cacheBust(charmsLatest.url)}" />`;
        } else {
          previewNewCharms.innerHTML = `<div class="slotRefEmpty">Queue Empty</div>`;
        }

        const earringsLatest = await listLatestFile(newCharmsEarringsPath());
        currentEarringRef = earringsLatest;
        if (earringsLatest) {
          previewNewCharmsEarrings.innerHTML = `<img src="${cacheBust(earringsLatest.url)}" />`;
        } else {
          previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Queue Empty</div>`;
        }
      } catch (e) {
        console.error("Error fetching charm previews:", e);
        previewNewCharms.innerHTML = `<div class="slotRefEmpty">Error loading</div>`;
        previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Error loading</div>`;
      }
    }

    async function loadCharmMakerHistory() {
        setStatus("Loading history...");
        charmSetsHistory = [];
        charmCurrentPage = 1;
        try {
            await ensureStorageSignedIn();
            const completedCharmsRef = ref(storage, `${ROOT}/Completed_Charm`);
            const res = await listAll(completedCharmsRef);
            
            const prefixes = res.prefixes.map(p => p.name).filter(n => n.startsWith('Deriv_'));
            prefixes.sort((a, b) => {
                const tsA = parseInt(a.replace('Deriv_', '')) || 0;
                const tsB = parseInt(b.replace('Deriv_', '')) || 0;
                return tsB - tsA; // descending
            });
            charmSetsHistory = prefixes;
            renderCharmPage();
        } catch (e) {
            console.error("Failed to load Charm Maker history:", e);
            setStatus("Error loading history");
        }
    }

    function createCharmCardHTML(folderId) {
        return `
            <div class="charm-card" id="card_${folderId}">
                <div class="charm-card-title">Generated Derivatives Previews <span class="muted" style="font-size:11px;">${folderId}</span></div>
                
                <div class="charm-col">
                    <div class="muted">New_Charms Derivative</div>
                    <div class="slotPrev" id="prevBox_${folderId}_0"><div class="slotRefEmpty">Loading...</div></div>
                    <button class="btn btnSmall redoBtn" id="redo_${folderId}_0" onclick="redoCharmSlot('${folderId}', 0)">Redo</button>
                </div>
                
                <div class="charm-col">
                    <div class="muted">New_Charms_Earrings Derivative</div>
                    <div class="slotPrev" id="prevBox_${folderId}_1"><div class="slotRefEmpty">Loading...</div></div>
                    <button class="btn btnSmall redoBtn" id="redo_${folderId}_1" onclick="redoCharmSlot('${folderId}', 1)">Redo</button>
                </div>
                
                <div class="charm-col">
                    <div class="muted">B&W Line Art (Standard)</div>
                    <div class="slotPrev" id="prevBox_${folderId}_2"><div class="slotRefEmpty">Loading...</div></div>
                    <button class="btn btnSmall redoBtn" id="redo_${folderId}_2" onclick="redoCharmSlot('${folderId}', 2)">Redo</button>
                </div>
                
                <div class="charm-col">
                    <div class="muted">B&W Line Art (Earrings)</div>
                    <div class="slotPrev" id="prevBox_${folderId}_3"><div class="slotRefEmpty">Loading...</div></div>
                    <button class="btn btnSmall redoBtn" id="redo_${folderId}_3" onclick="redoCharmSlot('${folderId}', 3)">Redo</button>
                </div>

                <div class="row" style="grid-column: span 2; gap: 8px; margin-top: 4px;">
                    <button class="btn btnSmall redoBtn" style="flex:1;" onclick="regenCharmQuad('${folderId}')">Regen Quad</button>
                    <button class="btn btnSmall redoBtn" style="flex:1; background: #3d1c1c; border-color: #7a3838; color: #fca5a5;" onclick="deleteCharmQuad('${folderId}')">Delete</button>
                    <button class="btn btnSmall redoBtn" style="flex:1; background: #1f4026; border-color: #2f5e3a; color: #7fdb96;" onclick="approveCharmQuad('${folderId}')">Approve</button>
                </div>
            </div>
        `;
    }

    function renderCharmPage() {
        gridEl.innerHTML = "";
        
        if (charmSetsHistory.length === 0) {
            gridEl.innerHTML = `<div class="slotRefEmpty" style="grid-column:span 4;">No historical sets found. Generate one!</div>`;
            charmPaginationEl.style.display = "none";
            setStatus("Ready");
            return;
        }

        const totalPages = Math.ceil(charmSetsHistory.length / CHARM_ITEMS_PER_PAGE);
        document.getElementById("charmPageInfo").textContent = `Page ${charmCurrentPage} of ${totalPages}`;
        
        document.getElementById("charmPrevPage").disabled = (charmCurrentPage === 1);
        document.getElementById("charmNextPage").disabled = (charmCurrentPage === totalPages);
        
        charmPaginationEl.style.display = totalPages > 1 ? "flex" : "none";

        const startIndex = (charmCurrentPage - 1) * CHARM_ITEMS_PER_PAGE;
        const pageItems = charmSetsHistory.slice(startIndex, startIndex + CHARM_ITEMS_PER_PAGE);

        pageItems.forEach(folderId => {
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = createCharmCardHTML(folderId);
            const cardNode = tempDiv.firstElementChild;
            gridEl.appendChild(cardNode);
            loadSetImagesForCharm(folderId);
        });
        
        setStatus(`Viewing Page ${charmCurrentPage}`);
    }

    async function loadSetImagesForCharm(folderId) {
        const folderPath = `${ROOT}/Completed_Charm/${folderId}`;
        for (let i = 0; i < 4; i++) {
            const fileName = `Slot_${i+1}.png`;
            const fileRef = ref(storage, `${folderPath}/${fileName}`);
            const prevBox = document.getElementById(`prevBox_${folderId}_${i}`);
            if (!prevBox) continue;
            
            getDownloadURL(fileRef).then(url => {
                prevBox.innerHTML = `<img src="${cacheBust(url)}" />`;
                attachPreviewBoxListeners(prevBox);
            }).catch(e => {
                prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
            });
        }
    }

    document.getElementById("charmPrevPage").addEventListener("click", () => {
        if (charmCurrentPage > 1) {
            charmCurrentPage--;
            renderCharmPage();
        }
    });

    document.getElementById("charmNextPage").addEventListener("click", () => {
        const totalPages = Math.ceil(charmSetsHistory.length / CHARM_ITEMS_PER_PAGE);
        if (charmCurrentPage < totalPages) {
            charmCurrentPage++;
            renderCharmPage();
        }
    });

    window.redoCharmSlot = async function(folderId, slotIndex) {
        const folderPath = `${ROOT}/Completed_Charm/${folderId}`;
        const redoBtn = document.getElementById(`redo_${folderId}_${slotIndex}`);
        const prevBox = document.getElementById(`prevBox_${folderId}_${slotIndex}`);
        
        redoBtn.disabled = true;
        prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
        prevBox.classList.remove("success-border");
        
        try {
            const slotFileName = `Slot_${slotIndex + 1}.png`;
            const slotStoragePath = `${folderPath}/${slotFileName}`;
            let beforeUpdatedMs = 0, beforeGeneration = 0;
            try {
                const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
                beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
                beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
            } catch(e) {}

            let manifest = {};
            try {
                const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
                manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
            } catch(e) {
                console.warn("No manifest found for", folderId, "falling back to runtime refs if possible");
            }

            let inputPath = "";
            let inputCharmPath = "";
            let promptStr = "";
            let category = "";

            if (slotIndex === 0) {
                inputPath = manifest.sourceCharm || currentCharmRef?.fullPath; 
                if (!inputPath) throw new Error("Missing source reference for base charm.");
                inputCharmPath = inputPath;
                promptStr = promptStrCharm;
                category = "Charms";
            } else if (slotIndex === 1) {
                inputPath = `${folderPath}/Slot_1.png`;
                inputCharmPath = inputPath;
                promptStr = promptStrEarring;
                category = "Stud_Earrings";
            } else if (slotIndex === 2) {
                inputPath = `${folderPath}/Slot_1.png`;
                inputCharmPath = manifest.lineArtRef || inputPath;
                promptStr = promptStrBW;
                category = "Charms";
            } else if (slotIndex === 3) {
                inputPath = `${folderPath}/Slot_2.png`;
                inputCharmPath = manifest.lineArtRef || inputPath;
                promptStr = promptStrBW;
                category = "Stud_Earrings";
            }

            await postJson(GEMINI_BG_FN, {
                kind: "edits",
                activeCategory: category,
                input_storage_path: inputPath,
                input_charm_storage_path: inputCharmPath,
                output_base_path: folderPath,
                slotIndex: slotIndex,
                model: "gemini-3-pro-image-preview",
                prompt: promptStr
            });

            const waitedRes = await waitForSlotPngUrl(folderPath, slotIndex, {
                afterUpdatedMs: beforeUpdatedMs,
                afterGeneration: beforeGeneration,
                timeoutMs: 600000, intervalMs: 5000
            });

            prevBox.innerHTML = `<img src="${cacheBust(waitedRes.url)}" />`;
            attachPreviewBoxListeners(prevBox);
            prevBox.classList.add("success-border");
        } catch (err) {
            console.error("Charm Redo failed", err);
            prevBox.innerHTML = `<div class="slotRefEmpty">Error: ${err.message}</div>`;
        } finally {
            redoBtn.disabled = false;
        }
    };

    window.regenCharmQuad = async function(folderId) {
        const folderPath = `${ROOT}/Completed_Charm/${folderId}`;
        
        const prev0 = document.getElementById(`prevBox_${folderId}_0`);
        const prev1 = document.getElementById(`prevBox_${folderId}_1`);
        const prev2 = document.getElementById(`prevBox_${folderId}_2`);
        const prev3 = document.getElementById(`prevBox_${folderId}_3`);
        
        if (!prev0) return;

        setBusy(true);
        setStatus(`Regenerating Quad ${folderId}...`);

        [prev0, prev1, prev2, prev3].forEach(p => p.innerHTML = `<div class="slotRefEmpty">Working...</div>`);
        [prev0, prev1, prev2, prev3].forEach(p => p.classList.remove("success-border"));
        [0, 1, 2, 3].forEach(i => document.getElementById(`redo_${folderId}_${i}`).disabled = true);

        try {
            await ensureStorageSignedIn();
            let manifest = {};
            try {
                const manifestBuffer = await getBytes(ref(storage, `${folderPath}/manifest.json`));
                manifest = JSON.parse(new TextDecoder().decode(manifestBuffer));
            } catch(e) {
                console.warn("No manifest found for", folderId, "falling back to runtime refs if possible");
            }
            
            const sourceCharmPath = manifest.sourceCharm || currentCharmRef?.fullPath;
            if (!sourceCharmPath) throw new Error("No source charm reference found.");
            
            let lineArtRefPath = manifest.lineArtRef;
            if (!lineArtRefPath) {
                try {
                    const lat = await listLatestFile(`${ROOT}/Reference_Line_Art_Image`);
                    if(lat) lineArtRefPath = lat.fullPath;
                } catch(e) {}
            }

            const beforeMeta = {};
            for (let i = 0; i < 4; i++) {
                try {
                    const m = await getMetadata(ref(storage, `${folderPath}/Slot_${i+1}.png`));
                    beforeMeta[i] = {
                        updatedMs: Date.parse(m?.updated || m?.timeCreated || "") || 0,
                        generation: Number(m?.generation || 0) || 0
                    };
                } catch(e) {
                    beforeMeta[i] = { updatedMs: 0, generation: 0 };
                }
            }

            // STEP 1
            prev0.innerHTML = `<div class="slotRefEmpty">Generating Base...</div>`;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms", 
                input_storage_path: sourceCharmPath, input_charm_storage_path: sourceCharmPath,
                output_base_path: folderPath, slotIndex: 0,
                model: "gemini-3-pro-image-preview", prompt: promptStrCharm
            });
            const charmRes = await waitForSlotPngUrl(folderPath, 0, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[0].updatedMs, afterGeneration: beforeMeta[0].generation 
            });
            prev0.innerHTML = `<img src="${cacheBust(charmRes.url)}" />`;
            attachPreviewBoxListeners(prev0);
            prev0.classList.add("success-border");
            document.getElementById(`redo_${folderId}_0`).disabled = false;

            // STEP 2
            setStatus("Generating Earring Twin (Removing Hoop)...");
            prev1.innerHTML = `<div class="slotRefEmpty">Removing Hoop...</div>`;
            await sleep(2000); 
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings", 
                input_storage_path: charmRes.storagePath, input_charm_storage_path: charmRes.storagePath,
                output_base_path: folderPath, slotIndex: 1,
                model: "gemini-3-pro-image-preview", prompt: promptStrEarring
            });
            const earringRes = await waitForSlotPngUrl(folderPath, 1, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[1].updatedMs, afterGeneration: beforeMeta[1].generation 
            });
            prev1.innerHTML = `<img src="${cacheBust(earringRes.url)}" />`;
            attachPreviewBoxListeners(prev1);
            prev1.classList.add("success-border");
            document.getElementById(`redo_${folderId}_1`).disabled = false;

            // STEP 3
            setStatus("Generating B&W Line Art (Standard)...");
            prev2.innerHTML = `<div class="slotRefEmpty">Generating Line Art...</div>`;
            await sleep(2000);
            const refPathForBaseBW = lineArtRefPath || charmRes.storagePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms", 
                input_storage_path: charmRes.storagePath, input_charm_storage_path: refPathForBaseBW,
                output_base_path: folderPath, slotIndex: 2,
                model: "gemini-3-pro-image-preview", prompt: promptStrBW
            });
            const charmBWRes = await waitForSlotPngUrl(folderPath, 2, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[2].updatedMs, afterGeneration: beforeMeta[2].generation 
            });
            prev2.innerHTML = `<img src="${cacheBust(charmBWRes.url)}" />`;
            attachPreviewBoxListeners(prev2);
            prev2.classList.add("success-border");
            document.getElementById(`redo_${folderId}_2`).disabled = false;

            // STEP 4
            setStatus("Generating B&W Line Art (Earrings)...");
            prev3.innerHTML = `<div class="slotRefEmpty">Generating Line Art...</div>`;
            await sleep(2000);
            const refPathForEarringBW = lineArtRefPath || earringRes.storagePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings", 
                input_storage_path: earringRes.storagePath, input_charm_storage_path: refPathForEarringBW,
                output_base_path: folderPath, slotIndex: 3,
                model: "gemini-3-pro-image-preview", prompt: promptStrBW
            });
            const earringBWRes = await waitForSlotPngUrl(folderPath, 3, { 
                timeoutMs: 600000, intervalMs: 5000,
                afterUpdatedMs: beforeMeta[3].updatedMs, afterGeneration: beforeMeta[3].generation 
            });
            prev3.innerHTML = `<img src="${cacheBust(earringBWRes.url)}" />`;
            attachPreviewBoxListeners(prev3);
            prev3.classList.add("success-border");
            document.getElementById(`redo_${folderId}_3`).disabled = false;

            setStatus("Quad Regeneration Complete.");
        } catch(err) {
            console.error("Regen Quad failed:", err);
            setStatus(`Error: ${err.message}`);
        } finally {
            [0, 1, 2, 3].forEach(i => {
                const btn = document.getElementById(`redo_${folderId}_${i}`);
                if(btn) btn.disabled = false;
            });
            setBusy(false);
        }
    };

    window.deleteCharmQuad = async function(folderId) {
        if (!confirm(`Are you sure you want to completely delete the quad '${folderId}'?`)) return;
        
        setStatus(`Deleting ${folderId}...`);
        try {
            await ensureStorageSignedIn();
            const folderPath = `${ROOT}/Completed_Charm/${folderId}`;
            const folderRef = ref(storage, folderPath);
            const res = await listAll(folderRef);
            
            for (const item of res.items) {
                await deleteObject(item);
            }
            
            charmSetsHistory = charmSetsHistory.filter(id => id !== folderId);
            
            const totalPages = Math.ceil(charmSetsHistory.length / CHARM_ITEMS_PER_PAGE);
            if (charmCurrentPage > totalPages) charmCurrentPage = Math.max(1, totalPages);
            
            renderCharmPage();
            setStatus(`Deleted ${folderId}.`);
        } catch (err) {
            console.error("Delete Quad failed:", err);
            setStatus(`Error deleting: ${err.message}`);
        }
    };

    window.approveCharmQuad = async function(folderId) {
        if (!confirm(`Approve '${folderId}' and move to Approved Sets?`)) return;
        
        setStatus(`Approving ${folderId}...`);
        try {
            await ensureStorageSignedIn();
            const srcFolder = `${ROOT}/Completed_Charm/${folderId}`;
            const destFolder = `${ROOT}/Completed_Approved_Charm_Sets/${folderId}`;
            
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const item of res.items) {
                const buffer = await getBytes(item);
                const newRef = ref(storage, `${destFolder}/${item.name}`);
                await uploadBytesResumable(newRef, buffer);
                await deleteObject(item);
            }
            
            charmSetsHistory = charmSetsHistory.filter(id => id !== folderId);
            
            const totalPages = Math.ceil(charmSetsHistory.length / CHARM_ITEMS_PER_PAGE);
            if (charmCurrentPage > totalPages) charmCurrentPage = Math.max(1, totalPages);
            
            renderCharmPage();
            setStatus(`Approved and moved ${folderId}.`);
        } catch (err) {
            console.error("Approve Quad failed:", err);
            setStatus(`Error approving: ${err.message}`);
        }
    };

    executeCharmGenBtn.addEventListener("click", async () => {
        if (!currentCharmRef) {
            alert("No reference charm loaded in the New_Charms queue. Please upload to New_Charms.");
            return;
        }

        setBusy(true);
        setStatus("Generating Base Charm Derivative...");
        executeCharmGenBtn.disabled = true;

        const timestamp = Date.now();
        const folderId = `Deriv_${timestamp}`;
        const outputBasePath = `${ROOT}/Completed_Charm/${folderId}`;

        if (charmCurrentPage !== 1) {
            charmCurrentPage = 1;
            renderCharmPage();
        }

        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = createCharmCardHTML(folderId);
        const cardNode = tempDiv.firstElementChild;
        gridEl.insertBefore(cardNode, gridEl.firstChild);
        
        if (charmSetsHistory.indexOf(folderId) === -1) {
            charmSetsHistory.unshift(folderId);
        }

        const prev0 = document.getElementById(`prevBox_${folderId}_0`);
        const prev1 = document.getElementById(`prevBox_${folderId}_1`);
        const prev2 = document.getElementById(`prevBox_${folderId}_2`);
        const prev3 = document.getElementById(`prevBox_${folderId}_3`);

        [prev0, prev1, prev2, prev3].forEach(p => p.innerHTML = `<div class="slotRefEmpty">Queued...</div>`);
        [0, 1, 2, 3].forEach(i => document.getElementById(`redo_${folderId}_${i}`).disabled = true);
        
        try {
            let lineArtRef = null;
            try {
                lineArtRef = await listLatestFile(`${ROOT}/Reference_Line_Art_Image`);
            } catch (e) {
                console.warn("No line art reference found. Will fallback to charm itself.", e);
            }

            const manifest = {
                sourceCharm: currentCharmRef.fullPath,
                sourceEarring: currentEarringRef?.fullPath || null,
                lineArtRef: lineArtRef?.fullPath || null,
                timestamp: new Date().toISOString()
            };

            await postJson("geminiImageProxy", {
                kind: "write_manifest",
                activeCategory: "Charms",
                output_base_path: outputBasePath,
                manifest: manifest,
            });

            // STEP 1
            prev0.innerHTML = `<div class="slotRefEmpty">Generating Base...</div>`;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms", 
                input_storage_path: currentCharmRef.fullPath, input_charm_storage_path: currentCharmRef.fullPath,
                output_base_path: outputBasePath, slotIndex: 0,
                model: "gemini-3-pro-image-preview", prompt: promptStrCharm
            });
            const charmRes = await waitForSlotPngUrl(outputBasePath, 0, { timeoutMs: 600000, intervalMs: 5000 });
            prev0.innerHTML = `<img src="${cacheBust(charmRes.url)}" />`;
            attachPreviewBoxListeners(prev0);
            prev0.classList.add("success-border");
            document.getElementById(`redo_${folderId}_0`).disabled = false;

            // STEP 2
            setStatus("Generating Earring Twin (Removing Hoop)...");
            prev1.innerHTML = `<div class="slotRefEmpty">Removing Hoop...</div>`;
            await sleep(2000); 
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings", 
                input_storage_path: charmRes.storagePath, input_charm_storage_path: charmRes.storagePath,
                output_base_path: outputBasePath, slotIndex: 1,
                model: "gemini-3-pro-image-preview", prompt: promptStrEarring
            });
            const earringRes = await waitForSlotPngUrl(outputBasePath, 1, { timeoutMs: 600000, intervalMs: 5000 });
            prev1.innerHTML = `<img src="${cacheBust(earringRes.url)}" />`;
            attachPreviewBoxListeners(prev1);
            prev1.classList.add("success-border");
            document.getElementById(`redo_${folderId}_1`).disabled = false;

            // STEP 3
            setStatus("Generating B&W Line Art (Standard)...");
            prev2.innerHTML = `<div class="slotRefEmpty">Generating Line Art...</div>`;
            await sleep(2000);
            const refPathForBaseBW = lineArtRef ? lineArtRef.fullPath : charmRes.storagePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Charms", 
                input_storage_path: charmRes.storagePath, input_charm_storage_path: refPathForBaseBW,
                output_base_path: outputBasePath, slotIndex: 2,
                model: "gemini-3-pro-image-preview", prompt: promptStrBW
            });
            const charmBWRes = await waitForSlotPngUrl(outputBasePath, 2, { timeoutMs: 600000, intervalMs: 5000 });
            prev2.innerHTML = `<img src="${cacheBust(charmBWRes.url)}" />`;
            attachPreviewBoxListeners(prev2);
            prev2.classList.add("success-border");
            document.getElementById(`redo_${folderId}_2`).disabled = false;

            // STEP 4
            setStatus("Generating B&W Line Art (Earrings)...");
            prev3.innerHTML = `<div class="slotRefEmpty">Generating Line Art...</div>`;
            await sleep(2000);
            const refPathForEarringBW = lineArtRef ? lineArtRef.fullPath : earringRes.storagePath;
            await postJson(GEMINI_BG_FN, {
                kind: "edits", activeCategory: "Stud_Earrings", 
                input_storage_path: earringRes.storagePath, input_charm_storage_path: refPathForEarringBW,
                output_base_path: outputBasePath, slotIndex: 3,
                model: "gemini-3-pro-image-preview", prompt: promptStrBW
            });
            const earringBWRes = await waitForSlotPngUrl(outputBasePath, 3, { timeoutMs: 600000, intervalMs: 5000 });
            prev3.innerHTML = `<img src="${cacheBust(earringBWRes.url)}" />`;
            attachPreviewBoxListeners(prev3);
            prev3.classList.add("success-border");
            document.getElementById(`redo_${folderId}_3`).disabled = false;

            setStatus("All Derivatives & Line Art Complete.");
            renderCharmPage();

        } catch (err) {
            console.error("Master Generation Catch:", err);
            setStatus(`Error: ${err.message}`);
            
            if (prev1.innerHTML.includes("Queued") || prev1.innerHTML.includes("Removing")) prev1.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
            if (prev2.innerHTML.includes("Queued") || prev2.innerHTML.includes("Generating")) prev2.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
            if (prev3.innerHTML.includes("Queued") || prev3.innerHTML.includes("Generating")) prev3.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
        } finally {
            setBusy(false);
            executeCharmGenBtn.disabled = false;
        }
    });

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1â€“8)
    // ------------------------------------------------------------
    
    // =========================================================================
    // 0. BEADY_NECKLACE
    // =========================================================================

    const SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).

    â€¢ Critical: Never Cut out darkened areas of the Charm/Pendant. Darkened portions of the Charm/Pendant are typically hatched engravings.

    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task.

    PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Single pass only.
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    â€¢ Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;


    // =========================================================================
    // 1. // REGULAR NECKLACE
    // =========================================================================
    const REGULAR_SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    Do noy cutout any engravings, preserve ALL Charm/Pendant engravings in great detail.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const REGULAR_SLOT3_SIZING_GUIDE_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Slightly vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT7_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

  



    // =========================================================================
    // 2. // BRACELET PROMPTS
    // =========================================================================
    const BRACELET_MODEL_PROMPT =
    `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_CREATIVE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SIZE_GUIDE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;

    const BRACELET_ENGRAVING_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SEC_MODEL_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    const BRACELET_PRODUCT_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;





    // =========================================================================
    // 3. // STUD EARRINGS PROMPTS
    // =========================================================================
    const STUD_MODEL_PROMPT =
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and thin sheet of metal, always render the Charm/Pendant completely flat
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. `;

    const STUD_CREATIVE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SIZE_GUIDE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be VERY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow engraving colour to be dark, brown, or black, ensure all engraving colours are a light shade of copper colour`;

    const STUD_PRODUCT_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin.  
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_PRODUCT_2_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;



















    // =========================================================================
    // 4. // HOOP EARRINGS PROMPTS
    // =========================================================================

    const HOOP_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
    â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
    â€¢ The new Charm must be the same or smaller size then the Reference Image. 
    â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
    â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
    â€¢ HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    â€¢ DO NOT allow any rounded/radius on the cutout edges.
    â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
    â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
    â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.
    â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;

    const HOOP_METAL_OPTIONS_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm (2 Yellow Gold & 2 Silver) using the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth. `;

    const HOOP_SIZE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;

    const HOOP_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
        â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
          HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.`;

    const HOOP_DIMENSION_PROMPT =
    `TASK
        â€¢ Duplicate the Reference product image exactly and only update the 1 charm from the Charm Reference image.
        â€¢ Preserve all engravings as they appear in the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;



    const HOOP_PRIMARY_PRODUCT_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and only update the 2 charms from the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
        â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;




















    // =========================================================================
    // 5. // CHARM ONLY PROMPTS 
    // =========================================================================
    const CHARM_TEMPLATE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.`;

    const CHARM_TYPES_PROMPT = 
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the reference image exactly, only replace the 3 charms (2 smaller huggie Charms and 1 necklace Charm) with the Charm Refernce image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.
        â€¢ Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const CHARM_MODEL_PROMPT = 
    `TASK: (Force the Charm to be EXTREMELY SMALL)
        â€¢Generate a high-end photorealistic commercial jewelry image based on the attached reference image, use soft studio lighting and sharp focus on the necklace chain and charm/pendant details.
        â€¢ Critically: Keep necklace chain details, chainlink spacing, size, Yellow 14K gold colour, and fidelity just like in the reference image. 
        â€¢ Maintain zoom level and frame.
        â€¢ Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ The chain must be bright realistic Yellow 14K gold colour and light reflections.
        â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
        â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
        â€¢ The chain must remain exactly the same size and detail as in the reference image.`;

    const CHARM_ENGRAVING_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.

      HARD FAIL CONDITIONS
        â€¢ Any weak or disconnected hoop connection.`;


    const CHARM_HOOP_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    const CHARM_SIZE_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    // =========================================================================
    // 3. MASTER MAPPING
    // =========================================================================

    const PROMPT_MAPS = {
      // 1. Regular_Necklace (Uses identical prompts to Beady)
      "Regular_Necklace": {
        1: REGULAR_DEFAULT_PROMPT,
        2: REGULAR_SLOT2_DUPLICATE_PROMPT,
        3: REGULAR_SLOT3_SIZING_GUIDE_PROMPT,
        4: REGULAR_SLOT4_PROMPT,
        5: REGULAR_SLOT5_PROMPT,
        7: REGULAR_SLOT7_PROMPT
      },
      // 2. Beady_Necklace (Original)
      "Beady_Necklace": {
        1: DEFAULT_PROMPT,
        2: SLOT2_DUPLICATE_PROMPT,
        3: SLOT3_SIZING_GUIDE_PROMPT,
        4: SLOT4_PROMPT,
        5: SLOT5_PROMPT,
        7: SLOT7_PROMPT
      },
      // 3. Stud_Earrings
      "Stud_Earrings": {
        1: STUD_MODEL_PROMPT,
        2: STUD_CREATIVE_PROMPT,
        3: STUD_SIZE_GUIDE_PROMPT,
        4: STUD_PRODUCT_PROMPT,
        5: STUD_SEC_MODEL_PROMPT,
        6: STUD_PRODUCT_2_PROMPT 
      },
      // 4. Hoop_Earrings
      "Hoop_Earrings": {
        1: HOOP_MODEL_PROMPT,
        2: HOOP_PRIMARY_PRODUCT_PROMPT,
        3: HOOP_SIZE_PROMPT,
        4: HOOP_SEC_MODEL_PROMPT,
        5: HOOP_DIMENSION_PROMPT,
        7: HOOP_METAL_OPTIONS_PROMPT
      }, 
      // 5. Charms
      "Charms": {
        1: CHARM_TEMPLATE_PROMPT, 
        2: CHARM_TYPES_PROMPT, 
        3: CHARM_MODEL_PROMPT, 
        4: CHARM_ENGRAVING_PROMPT, 
        5: CHARM_HOOP_GUIDE_PROMPT, 
        7: CHARM_SIZE_GUIDE_PROMPT 
      },
      // 6. Bracelets
      "Bracelets": {
        1: BRACELET_MODEL_PROMPT,
        2: BRACELET_CREATIVE_PROMPT,
        3: BRACELET_SIZE_GUIDE_PROMPT,
        4: BRACELET_ENGRAVING_PROMPT,
        5: BRACELET_SEC_MODEL_PROMPT,
        6: BRACELET_PRODUCT_PROMPT
      }
    };

    function buildSlotPrompt(category, folderName, slotNum) {
      const map = PROMPT_MAPS[category];
      if (map && map[slotNum]) {
        return map[slotNum];
      }
      const DEFAULT_MAP = PROMPT_MAPS["Beady_Necklace"];
      return DEFAULT_MAP[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
  </script>
</body>
</html>