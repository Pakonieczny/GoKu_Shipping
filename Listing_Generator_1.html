<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotPrev{ width:100%; height:190px; border-radius:12px; border:1px solid var(--line); background:#0b0d12; overflow:hidden; }
    .slotPrev img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <!-- LEFT -->
    <div class="card">
      <h1>Listing-Generator-1</h1>
      <div class="muted">Upload a reference image → tune prompt/traits → generate 8 variations → auto-upload to Firebase.</div>

      <label>Reference image (drag/drop or pick)</label>
      <div class="drop" id="drop">
        <div>
          <strong id="refName">No image selected</strong>
          <div class="muted">Tip: large images work, but faster if you keep them &lt; ~2–3MB.</div>
        </div>
        <div class="row">
          <input id="file" type="file" accept="image/*" />
        </div>
      </div>

      <label>Reference preview (zoom + pan)</label>
      <div class="preview-box" id="refPreview"></div>

      <label>Generative description (live editable)</label>
      <textarea id="prompt"></textarea>

      <label>Model (Images API)</label>
      <select id="model">
        <option value="gpt-image-1.5">gpt-image-1.5 (if enabled)</option>
        <option value="gpt-image-1">gpt-image-1</option>
      </select>

      <div class="row" style="margin-top:10px;">
        <button class="btn" id="gen8">Generate 8</button>
        <button class="btn" id="clear">Clear</button>
      </div>

      <label>Selected traits (template → randomized per slot)</label>
      <div class="traits" id="traitsBox"></div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated images (8)</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <!-- Firebase (same style as shipping-1 uses: compat init + modular storage/auth) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
    import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";

    // --- Netlify functions base ---
    const functionsBaseUrl = `${window.location.origin}/.netlify/functions`;

    // --- Firebase config (matches shipping-1 patterns) ---
    // NOTE: keep using your project/bucket shown in shipping-1  [oai_citation:14‡shipping-1.html](sediment://file_00000000873871fd94817134ae30ec49)
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    window.db = firebase.firestore();

    // modular twin (same approach as shipping-1 resumable uploader  [oai_citation:15‡shipping-1.html](sediment://file_00000000873871fd94817134ae30ec49))
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const auth = getAuth(modApp);
    const storage = getStorage(modApp);
    await signInAnonymously(auth).catch(console.error);

    // --- UI State ---
    const fileEl = document.getElementById("file");
    const dropEl = document.getElementById("drop");
    const refNameEl = document.getElementById("refName");
    const refPreviewEl = document.getElementById("refPreview");
    const promptEl = document.getElementById("prompt");
    const modelEl = document.getElementById("model");
    const gen8Btn = document.getElementById("gen8");
    const clearBtn = document.getElementById("clear");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const traitsBox = document.getElementById("traitsBox");

    let referenceDataUrl = null;
    let slots = [];

    // Trait defs (placeholder — we’ll wire this to your dropdown menus next)
    const TRAITS = {
      skin: ["very light","light","medium","tan","deep","very deep"],
      camera: ["straight-on chest-up","3/4 chest-up","profile neck focus","close crop collarbone"],
      wardrobe: ["blazer neutral top","knit sweater","linen shirt","black tee"],
      backdrop: ["muted sand","misty blue","soft gray","pastel studio"],
      lighting: ["soft daylight","window light airy","diffused studio","editorial softbox"],
    };

    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function makeTraits(){
      return {
        skin: pick(TRAITS.skin),
        camera: pick(TRAITS.camera),
        wardrobe: pick(TRAITS.wardrobe),
        backdrop: pick(TRAITS.backdrop),
        lighting: pick(TRAITS.lighting),
      };
    }

    // Default prompt (edit freely)
    promptEl.value =
`Create a hyper-realistic product photo variation based on the reference image.
Keep the jewelry accurate: chain geometry, station spacing, metal tone, scale, drape.
Change only the model/photo context based on traits.
No warped metal, no melted links, no extra jewelry.`;

    // --- Zoom + pan listeners (same behavior as sorting/shipping preview boxes)  [oai_citation:16‡sorting.html](sediment://file_000000009ce4722f924e48e4c99f157e)
    function attachZoomPan(box){
      let isMouseDown = false;
      let dragStartX = 0, dragStartY = 0;
      let lastX = 0, lastY = 0;

      box.addEventListener("wheel", (ev) => {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let s = parseFloat(img.dataset.scale) || 1;
        let ox = parseFloat(img.dataset.offsetX) || 0;
        let oy = parseFloat(img.dataset.offsetY) || 0;
        if (ev.deltaY < 0) s *= 1.1;
        else {
          s /= 1.1;
          if (s <= 1) { s = 1; ox = 0; oy = 0; }
        }
        if (s > 8) s = 8;
        img.dataset.scale = s;
        img.dataset.offsetX = ox;
        img.dataset.offsetY = oy;
        img.style.transform = `translate(${ox}px, ${oy}px) scale(${s})`;
      }, { passive:false });

      box.addEventListener("mousedown", (ev) => {
        const img = box.querySelector("img");
        if (!img) return;
        isMouseDown = true;
        dragStartX = ev.clientX;
        dragStartY = ev.clientY;
        lastX = parseFloat(img.dataset.offsetX) || 0;
        lastY = parseFloat(img.dataset.offsetY) || 0;
      });
      window.addEventListener("mouseup", () => { isMouseDown = false; });
      window.addEventListener("mousemove", (ev) => {
        const img = box.querySelector("img");
        if (!img || !isMouseDown) return;
        const dx = ev.clientX - dragStartX;
        const dy = ev.clientY - dragStartY;
        const ox = lastX + dx;
        const oy = lastY + dy;
        img.dataset.offsetX = ox;
        img.dataset.offsetY = oy;
        const s = parseFloat(img.dataset.scale) || 1;
        img.style.transform = `translate(${ox}px, ${oy}px) scale(${s})`;
      });
    }

    function setPreview(box, dataUrl){
      box.innerHTML = `<img src="${dataUrl}" data-scale="1" data-offsetX="0" data-offsetY="0" />`;
      attachZoomPan(box);
    }

  async function fileToDataUrl(file, opts = {}){
    const {
      maxDim = 1536,         // keep detail, shrink payload
      mime = "image/jpeg",   // much smaller than png
      quality = 0.92
    } = opts;

    // Modern path
    try {
      const bmp = await createImageBitmap(file);
      const w = bmp.width, h = bmp.height;
      const scale = Math.min(1, maxDim / Math.max(w, h));
      const tw = Math.max(1, Math.round(w * scale));
      const th = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = tw;
      canvas.height = th;

      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(bmp, 0, 0, tw, th);

      // Important: toDataURL on jpeg dramatically reduces size
      return canvas.toDataURL(mime, quality);
    } catch (_) {
      // Fallback: FileReader -> Image -> canvas
      const dataUrl = await new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onload = ()=> resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });

      const img = await new Promise((resolve, reject)=>{
        const i = new Image();
        i.onload = ()=> resolve(i);
        i.onerror = reject;
        i.src = dataUrl;
      });

      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      const scale = Math.min(1, maxDim / Math.max(w, h));
      const tw = Math.max(1, Math.round(w * scale));
      const th = Math.max(1, Math.round(h * scale));

      const canvas = document.createElement("canvas");
      canvas.width = tw;
      canvas.height = th;

      const ctx = canvas.getContext("2d", { alpha: false });
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(img, 0, 0, tw, th);

      return canvas.toDataURL(mime, quality);
    }
  }

    // Drag/drop
    dropEl.addEventListener("dragover", (e)=>{ e.preventDefault(); dropEl.style.borderColor="#2b6cff"; });
    dropEl.addEventListener("dragleave", ()=>{ dropEl.style.borderColor="#3a4262"; });
    dropEl.addEventListener("drop", async (e)=>{
      e.preventDefault(); dropEl.style.borderColor="#3a4262";
      const f = e.dataTransfer.files?.[0];
      if (!f) return;
      await loadReference(f);
    });
    fileEl.addEventListener("change", async ()=>{
      const f = fileEl.files?.[0];
      if (!f) return;
      await loadReference(f);
    });

    async function loadReference(file){
      refNameEl.textContent = file.name;
      referenceDataUrl = await fileToDataUrl(file);
      setPreview(refPreviewEl, referenceDataUrl);
    }

    // Grid
    function makeSlot(i){
      const el = document.createElement("div");
      el.className = "slot";
      el.innerHTML = `
        <div class="slotTop">
          <b>Slot ${i+1}</b>
          <button class="btn" data-reg="${i}">Regenerate</button>
        </div>
        <div class="slotPrev" id="prev_${i}"></div>
        <div class="bar"><div id="bar_${i}"></div></div>
        <div class="small" id="meta_${i}">—</div>
      `;
      return el;
    }

    function renderGrid(){
      gridEl.innerHTML = "";
      slots = Array.from({length:8}).map((_,i)=>({
        i,
        traits: makeTraits(),
        prompt: "",
        imageDataUrl: null,
        uploadUrl: null,
        uploading: false,
      }));
      slots.forEach((s)=> gridEl.appendChild(makeSlot(s.i)));

      // show trait template (first slot)
      renderTraits(slots[0].traits);

      // regen handler
      gridEl.querySelectorAll("button[data-reg]").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const idx = Number(btn.getAttribute("data-reg"));
          await generateOne(idx);
        });
      });
    }

    function renderTraits(t){
      traitsBox.innerHTML = "";
      Object.entries(t).forEach(([k,v])=>{
        const d = document.createElement("div");
        d.className = "pill";
        d.textContent = `${k}: ${v}`;
        traitsBox.appendChild(d);
      });
    }

    function setBar(i, pct){
      const bar = document.getElementById(`bar_${i}`);
      if (bar) bar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
    }

    function setMeta(i, txt){
      const m = document.getElementById(`meta_${i}`);
      if (m) m.textContent = txt;
    }

    function setSlotPreview(i, dataUrl){
      const box = document.getElementById(`prev_${i}`);
      if (!box) return;
      box.innerHTML = `<img src="${dataUrl}" data-scale="1" data-offsetX="0" data-offsetY="0" />`;
      attachZoomPan(box);
    }

    // Upload with realtime progress
    async function uploadWithProgress(path, file, onProgress){
      const storageRef = ref(storage, path);
      const task = uploadBytesResumable(storageRef, file, { contentType: file.type });
      await new Promise((resolve, reject) => {
        task.on("state_changed",
          (snap) => {
            if (!snap.totalBytes) return;
            onProgress?.(snap.bytesTransferred / snap.totalBytes);
          },
          reject,
          resolve
        );
      });
      return await getDownloadURL(storageRef);
    }

    function b64ToBlob(b64, mime="image/png"){
      const bin = atob(b64);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i);
      return new Blob([bytes], { type: mime });
    }

    async function callOpenAIImageEdits({ model, prompt, input_image }){
      const resp = await fetch("/.netlify/functions/openaiImageProxy", {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({
          kind: "edits",
          model,
          prompt,
          input_image
        })
      });

      const raw = await resp.text();              // <-- never assume JSON
      let data = null;
      try { data = raw ? JSON.parse(raw) : null; } catch (_) {}

      if (!resp.ok) {
        const msg =
          data?.error?.message ||
          data?.message ||
          raw ||
          `openaiImageProxy failed with HTTP ${resp.status} (empty body)`;
        throw new Error(msg);
      }

      if (!data) throw new Error("openaiImageProxy returned 200 but empty body");
      return data;
    }

    function buildPrompt(base, traits){
      return [
        base,
        "",
        `Traits:`,
        `- skin: ${traits.skin}`,
        `- camera: ${traits.camera}`,
        `- wardrobe: ${traits.wardrobe}`,
        `- backdrop: ${traits.backdrop}`,
        `- lighting: ${traits.lighting}`,
      ].join("\n");
    }

    async function generateOne(i){
      if (!referenceDataUrl) throw new Error("No reference image selected");
      const slot = slots[i];
      slot.traits = makeTraits(); // new random traits per regeneration
      const fullPrompt = buildPrompt(promptEl.value.trim(), slot.traits);
      slot.prompt = fullPrompt;
      renderTraits(slot.traits);

      // progress “feel” while waiting for API
      setBar(i, 2);
      setMeta(i, "Generating…");
      let fake = 2;
      const timer = setInterval(()=>{ fake = Math.min(90, fake + (Math.random()*6)); setBar(i, fake); }, 220);

      const model = modelEl.value;
      const runId = `lg1_${Date.now()}_${Math.random().toString(16).slice(2)}`;

      try {
        const out = await callOpenAIImageEdits({ model, prompt: fullPrompt, input_image: referenceDataUrl });

        // OpenAI Images API returns base64 in data[].b64_json (per docs)  [oai_citation:17‡OpenAI Platform](https://platform.openai.com/docs/api-reference/images?utm_source=chatgpt.com)
        const b64 = out?.data?.[0]?.b64_json;
        if (!b64) throw new Error("No b64_json returned");

        const imgUrl = `data:image/png;base64,${b64}`;
        slot.imageDataUrl = imgUrl;
        setSlotPreview(i, imgUrl);

        clearInterval(timer);
        setBar(i, 94);
        setMeta(i, "Uploading to Firebase…");

        // Upload
        const blob = b64ToBlob(b64, "image/png");
        const file = new File([blob], `slot_${i+1}.png`, { type:"image/png" });
        const storagePath = `listing-generator-1/generated/${runId}/slot_${i+1}.png`;

        const dl = await uploadWithProgress(storagePath, file, (p)=>{
          // map upload progress into 94–100
          setBar(i, 94 + Math.floor(p*6));
        });

        slot.uploadUrl = dl;
        setMeta(i, `Uploaded: ${storagePath}`);

        // Firestore record for your “other app” to fetch in realtime
        await window.db.collection("ListingGenerator1Images").add({
          runId,
          slotIndex: i,
          createdAt: new Date(),
          storagePath,
          downloadURL: dl,
          model,
          prompt: fullPrompt,
          traits: slot.traits
        });

        setBar(i, 100);
      } catch (e){
        clearInterval(timer);
        setBar(i, 0);
        setMeta(i, `Error: ${e.message}`);
        console.error(e);
      }
    }

    async function generateEight(){
      statusEl.textContent = "Generating 8…";
      gen8Btn.disabled = true;

      // fire all 8 concurrently (your throughput requirement)
      await Promise.all(slots.map(s => generateOne(s.i)));

      gen8Btn.disabled = false;
      statusEl.textContent = "Done";
    }

    // Init
    renderGrid();

    gen8Btn.addEventListener("click", generateEight);
    clearBtn.addEventListener("click", ()=>{
      referenceDataUrl = null;
      refNameEl.textContent = "No image selected";
      refPreviewEl.innerHTML = "";
      renderGrid();
      statusEl.textContent = "Idle";
    });
  </script>
</body>
</html>