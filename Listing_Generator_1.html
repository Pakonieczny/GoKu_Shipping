<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Listing-Generator-1</title>
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 420px 1fr; gap:14px; }
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:12px; }
    h1{ font-size:16px; margin:0 0 10px 0; }
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    textarea, select, input{ width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; }
    textarea{ min-height:120px; resize:vertical; }
    .row{ display:flex; gap:8px; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); }
    .btnSmall{ padding:6px 10px; border-radius:10px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    .muted{ color:var(--muted); font-size:12px; line-height:1.35; }
    .drop{
      border:1px dashed #3a4262; border-radius:14px; padding:12px; background:#0e1220;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
    .drop strong{ font-size:13px; }
    .preview-box{
      width:100%; height:280px; border-radius:14px; border:1px solid var(--line);
      background:#0b0d12; overflow:hidden; position:relative;
    }
    .preview-box img{ width:100%; height:100%; object-fit:contain; transform-origin:center; }
    .traits{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; margin-top:10px; }
    .pill{ font-size:12px; border:1px solid var(--line); background:#0e1220; border-radius:999px; padding:8px 10px; color:var(--muted); }
    .grid{
      display:grid; grid-template-columns: repeat(4, minmax(220px, 1fr)); gap:12px;
    }
    .slot{ background:#0e1220; border:1px solid var(--line); border-radius:14px; padding:10px; }
    .slotTop{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:8px; }
    .slotTop b{ font-size:12px; color:var(--muted); }
    .slotRefs{ display:flex; gap:8px; margin:8px 0; }
    .slotRefBox{
      flex:1;
      height:72px;
      border-radius:12px;
      border:1px solid var(--line);
      background:#0b0d12;
      overflow:hidden;
      position:relative;
    }
    .slotRefBox img{ width:100%; height:100%; object-fit:contain; }
    .slotRefEmpty{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      color:var(--muted);
    }
    .slotRefLabel{
      position:absolute;
      left:6px;
      bottom:6px;
      font-size:10px;
      color:var(--muted);
      background:rgba(0,0,0,0.35);
      padding:2px 7px;
      border-radius:999px;
      max-width:calc(100% - 12px);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }
    
    /* === UPDATED SLOT PREVIEW STYLES (Zoom/Grid support) === */
    .slotPrev {
      width:100%; 
      height:190px; 
      border-radius:12px; 
      border:1px solid var(--line); 
      background:#0b0d12; 
      overflow:hidden; /* Critical for cropping zoom */
      position: relative; /* Anchor for grid overlay */
    }
    
    .slotPrev img { 
      width:100%; 
      height:100%; 
      object-fit:contain; 
      transform-origin:center center; 
      transition: transform 0.3s ease; /* Smooth zoom transition */
      display: block;
      cursor: grab;
    }
    
    .slotPrev img:active {
      cursor: grabbing;
    }

    /* Rule-of-thirds overlay (from Index.html) */
    .slotPrev::after {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 700; 

      /* four thin lines at 1/3 and 2/3 */
      background-image:
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to right, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25)),
        linear-gradient(to bottom, rgba(255,255,255,.25), rgba(255,255,255,.25));
      background-size: 1px 100%, 1px 100%, 100% 1px, 100% 1px;
      background-position: 33.333% 0, 66.666% 0, 0 33.333%, 0 66.666%;
      background-repeat: no-repeat;
    }

    /* Success border style */
    .slotPrev.success-border {
      border: 3px solid lightgreen !important;
    }

    .bar{ height:8px; border-radius:999px; background:#0b0d12; border:1px solid var(--line); overflow:hidden; margin-top:10px; }
    .bar > div{ height:100%; width:0%; background:#2b6cff; transition:width 120ms linear; }
    .small{ font-size:11px; color:var(--muted); margin-top:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>Listing-Generator-1</h1>

      <div class="row" style="margin-bottom: 14px; background: #0e1220; padding: 4px; border-radius: 12px; border: 1px solid var(--line);">
        <button class="btn" id="toggleGenerate" style="flex:1; background: var(--line); border:none; color: var(--text);">Generate</button>
        <button class="btn" id="toggleReview" style="flex:1; background: transparent; border:none; color: var(--muted);">Review</button>
        <button class="btn" id="toggleCharmMaker" style="flex:1; background: transparent; border:none; color: var(--muted);">Charm Maker</button>
      </div>
      
      <div id="generateSection">
        <div class="muted">Pick a category, upload assets into the right folders, then click Generate Set.</div>

        <label>Category (Storage source of truth)</label>
        <select id="activeCategory"></select>
        <div class="muted" style="margin-top:6px;">
          Inputs come from Firebase Storage folders under <code>listing-generator-1/{Category}/...</code>.
          <br>
          <strong>Note:</strong> Stud/Hoop Earrings use <code>New_Charms_Earrings</code>. Others use <code>New_Charms</code>.
        </div>

        <div class="row" style="margin-top:10px;">
          <button class="btn" id="generateSet">Generate Set (Randomized Refs)</button>
        </div>

        <label style="margin-top:12px;">Category Asset Manager (Drag & Drop)</label>
        <div id="panels"></div>

        <label style="margin-top:12px;">Shared Pool (Autoselected based on category)</label>
        <div id="panelNewCharms"></div>
      </div>

      <div id="reviewSection" style="display: none;">
        <label style="margin-top:12px;">Select Set to Review</label>
        <div class="row">
          <select id="reviewSetSelect"></select>
        </div>
        <div class="row" style="margin-top:10px;">
           <button class="btn" id="approveSetBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Approve Set (Move to Completed)</button>
        </div>
        <div style="margin-top: 8px; font-size: 11px; color: var(--muted);" id="backgroundQueueStatus"></div>
      </div>

      <div id="charmMakerSection" style="display: none;">
        <div class="row" style="margin-top:12px; gap: 14px;">
          <div style="flex:1;">
            <label>New_Charms (Next Available)</label>
            <div class="slotPrev" id="previewNewCharms"><div class="slotRefEmpty">Loading...</div></div>
          </div>
          <div style="flex:1;">
            <label>New_Charms_Earrings (Next Available)</label>
            <div class="slotPrev" id="previewNewCharmsEarrings"><div class="slotRefEmpty">Loading...</div></div>
          </div>
        </div>

        <div class="row" style="margin-top:14px;">
          <button class="btn" id="executeCharmGenBtn" style="width:100%; background: #1f4026; color: #7fdb96; border: 1px solid #2f5e3a;">Generate Charms</button>
        </div>

        <div id="charmMakerResults" style="display:none; margin-top:20px;">
          <label style="color:#7fdb96;">Generated Derivatives Previews</label>
          <div class="row" style="gap: 14px;">
            <div style="flex:1;">
              <div class="muted" style="margin-bottom:6px;">New_Charms Derivative</div>
              <div class="slotPrev" id="resultPrevCharms"><div class="slotRefEmpty">Ready</div></div>
            </div>
            <div style="flex:1;">
              <div class="muted" style="margin-bottom:6px;">New_Charms_Earrings Derivative</div>
              <div class="slotPrev" id="resultPrevEarrings"><div class="slotRefEmpty">Ready</div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <h1 style="margin:0;">Generated set</h1>
        <div class="muted" id="status">Idle</div>
      </div>
      <div class="grid" id="grid"></div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <script type="module">
   import { initializeApp, getApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
   import { getStorage, ref, uploadBytesResumable, getDownloadURL, getBytes, listAll, getMetadata, deleteObject } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
   import { getAuth, signInAnonymously as modSignInAnonymously, onAuthStateChanged as modOnAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    // --- Netlify functions base (Safely handle file:// fallback) ---
    let originStr = window.location.origin;
    if (!originStr || originStr === "null" || window.location.protocol === "file:") {
      originStr = "https://listing-generator-1.goldenspike.app"; // Fallback if opened locally
    }
    const functionsBaseUrl = `${originStr}/.netlify/functions`;

    // -------------------------
    // Per-slot folder layout (Firebase Storage)
    // -------------------------
    const ROOT = "listing-generator-1";

    const GENERATABLE_CATEGORIES = new Set([
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
    ]);

    const ALL_CATEGORIES = [
      "Beady_Necklace",
      "Regular_Necklace",
      "Stud_Earrings",
      "Hoop_Earrings",
      "Charms",
      "Bracelets",
      "New_Charms",
      "New_Charms_Earrings", // Added for clarity, though it's a shared folder
      "Completed_Charm",
    ];


    const CATEGORY_SUBFOLDERS = {
      Beady_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Regular_Necklace: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Necklace_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      Stud_Earrings: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Product_Shots_2",
        "Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],

      Hoop_Earrings: [
        "Hoop_Earring_Models","Hoop_Earring_Sec_Models","Hoop_Charm_Dimensions","Hoop_Metal_Options","Hoop_Size_Options","Hoop_Model_Size_Guide","Hoop_Earring_Care_Guide","Hoop_Primary_Product","Ready_To_List","Completed_&_Listed_Sets" 
      ],

      Charms: [
        "Primary_Charm_Template","Charm_Types","Primary_Models","Back_Engraving",
        "Hoop_Charm_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Gold_Filled_Guide",
        "Ready_To_List","Completed_&_Listed_Sets"
      ],
      Bracelets: [
        "Primary_Models","Secondary_Models","Background_AI_Images","Product_Shots","Back_Engraving",
        "Bracelet_Size_Guide","Charm_Size_Guide","Care_Metal_Guide","Ready_To_List","Completed_&_Listed_Sets"
      ],
      New_Charms: [],
      New_Charms_Earrings: [],
      Completed_Charm: [],
    };

    const SLOT_MAP = {
      Beady_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Regular_Necklace: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"copy", folder:"Necklace_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Stud_Earrings: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Product_Shots_2" },
        { type:"copy", folder:"Care_Metal_Guide" },
      ],
      Hoop_Earrings: [
        { type:"gen", folder:"Hoop_Earring_Models" },       // Slot 1
        { type:"gen", folder:"Hoop_Primary_Product" },      // Slot 2
        { type:"gen", folder:"Hoop_Size_Options" },         // Slot 3
        { type:"gen", folder:"Hoop_Earring_Sec_Models" },   // Slot 4       
        { type:"gen", folder:"Hoop_Charm_Dimensions" },     // Slot 5
        { type:"copy", folder:"Hoop_Model_Size_Guide" },    // Slot 6
        { type:"gen", folder:"Hoop_Metal_Options" },        // Slot 7 
        { type:"copy", folder:"Hoop_Earring_Care_Guide" },  // Slot 8
      ],
      Charms: [
        { type:"gen", folder:"Primary_Charm_Template" },
        { type:"gen", folder:"Charm_Types" },
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Hoop_Charm_Size_Guide" },
        { type:"copy", folder:"Care_Metal_Guide" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"copy", folder:"Gold_Filled_Guide" },
      ],
      Bracelets: [
        { type:"gen", folder:"Primary_Models" },
        { type:"gen", folder:"Background_AI_Images" },
        { type:"gen", folder:"Charm_Size_Guide" },
        { type:"gen", folder:"Back_Engraving" },
        { type:"gen", folder:"Secondary_Models" },
        { type:"gen", folder:"Bracelet_Size_Guide" },
        { type:"gen", folder:"Product_Shots" },
        { type:"gen", folder:"Care_Metal_Guide" },
      ],
    };

    // --- Firebase config (matches shipping-1 patterns) ---
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };
    firebase.initializeApp(firebaseConfig);
    // âœ… IMPORTANT: use COMPAT auth so COMPAT firestore (window.db) has permissions
    try {
      const cred = await firebase.auth().signInAnonymously();
      console.log("Anon auth âœ”", cred?.user?.uid);
    } catch (e) {
      console.error("Anon auth âŒ", e);
    }

    window.db = firebase.firestore();

    // Firestore transport hardening
    try {
      window.db.settings({
        ignoreUndefinedProperties: true,
        experimentalForceLongPolling: true,
      });
    } catch (e) {
      console.warn("Firestore settings skipped:", e);
    }

    // modular twin (same approach as shipping-1 resumable uploader)
    let modApp;
    try { modApp = getApp(); } catch { modApp = initializeApp(firebase.app().options); }
    const storage = getStorage(modApp);
    const modAuth = getAuth(modApp);

    // Gate specifically for Storage (modular) so request.auth is never null in Storage rules
    async function ensureStorageSignedIn() {
      if (modAuth.currentUser) return modAuth.currentUser;
      try { await modSignInAnonymously(modAuth); } catch (_) {}

      return await new Promise((resolve, reject) => {
        const t = setTimeout(() => reject(new Error("Modular auth not ready. Enable Anonymous sign-in in Firebase Auth.")), 8000);
        const unsub = modOnAuthStateChanged(modAuth, async (u) => {
          if (!u) return;
          clearTimeout(t);
          unsub();
          try { await u.getIdToken(); } catch (_) {}
          resolve(u);
        });
      });
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
    
    // -------------------------------------------------------------------------
    // NEW: Zoom & Pan Logic (Ported from Index.html)
    // -------------------------------------------------------------------------
    function attachPreviewBoxListeners(box) {
      // Clamp offsets so the image never bleeds outside the viewport
      function clampAndApply(img, scale, offX, offY) {
        const viewportW = box.clientWidth || 120;
        const viewportH = box.clientHeight || 120;
        const baseW = img.clientWidth || 120;   
        const baseH = img.clientHeight || 120;
        const scaledW = baseW * scale;
        const scaledH = baseH * scale;

        // allowable pre-scale translation so the scaled image still covers viewport
        const maxX = Math.max(0, (scaledW - viewportW) / 2 / scale);
        const maxY = Math.max(0, (scaledH - viewportH) / 2 / scale);

        offX = Math.max(-maxX, Math.min(maxX, offX));
        offY = Math.max(-maxY, Math.min(maxY, offY));

        img.dataset.scale = scale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `scale(${scale}) translate(${offX}px, ${offY}px)`;
      }

      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0, dragStartY = 0;
      let lastX = 0, lastY = 0;
      const dragThreshold = 3;
      const MAX_SCALE = 8;
      
      // Re-clamp the current image when the preview box resizes
      if (typeof ResizeObserver !== "undefined") {
        const ro = new ResizeObserver(() => {
          const img = box.querySelector("img");
          if (!img) return;
          const s = parseFloat(img.dataset.scale) || 1;
          let offX = parseFloat(img.dataset.offsetX) || 0;
          let offY = parseFloat(img.dataset.offsetY) || 0; 
          clampAndApply(img, s, offX, offY);
        });
        ro.observe(box);
      }

      box.addEventListener("wheel", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;

        if (ev.deltaY < 0) {
          currentScale *= 1.1;            // zoom in
        } else {
          currentScale /= 1.1;            // zoom out
          if (currentScale <= 1) {        // snap back
            currentScale = 1;
            offX = 0; offY = 0;
          }
        }
        if (currentScale > MAX_SCALE) currentScale = MAX_SCALE;
        clampAndApply(img, currentScale, offX, offY);
      });

      box.addEventListener("mousedown", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;        // only drag when zoomed
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX; dragStartY = ev.clientY;
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mousemove", function (ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;

        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = (ev.clientX - lastX) * 0.5;
        const dy = (ev.clientY - lastY) * 0.5;
        offX += dx; offY += dy;
        clampAndApply(img, scaleNow, offX, offY);
        lastX = ev.clientX; lastY = ev.clientY;
      });

      box.addEventListener("mouseup",   () => { isMouseDown = false; });
      box.addEventListener("mouseleave",() => { isMouseDown = false; });

      box.addEventListener("click", function (ev) {
        if (isDragging) { isDragging = false; return; }
        const img = box.querySelector("img");
        if (!img) return;

        // Current transform (pre-scale offsets)
        const s0    = parseFloat(img.dataset.scale)   || 1;
        const offX0 = parseFloat(img.dataset.offsetX) || 0;
        const offY0 = parseFloat(img.dataset.offsetY) || 0;

        // Click in screen space relative to box center
        const rect = box.getBoundingClientRect();
        const cx = rect.left + box.clientWidth  / 2;
        const cy = rect.top  + box.clientHeight / 2;
        const dx_screen = ev.clientX - cx;
        const dy_screen = ev.clientY - cy;

        // Convert to pre-scale image space:
        const px = dx_screen / s0 - offX0;
        const py = dy_screen / s0 - offY0;

        // Offsets that place the clicked point exactly at the center
        let targetOffX = -px;
        let targetOffY = -py;

        // Minimum scale needed so that centering is valid (no blank edges)
        const halfW = (img.clientWidth  || 120) / 2;
        const halfH = (img.clientHeight || 120) / 2;
        function requiredScaleFor(delta, half) {
          const ratio = Math.abs(delta) / half;     // in [0, 1]
          if (ratio >= 1) return Infinity;          // edge pixel needs infinite scale
          return 1 / (1 - ratio);                   // solve half*(1 - 1/s) >= |delta|
        }
        const needX = requiredScaleFor(targetOffX, halfW);
        const needY = requiredScaleFor(targetOffY, halfH);

        const DESIRED = 1.33;                          // your preferred zoom jump
        let s1 = Math.max(DESIRED, s0 * 1.5, needX, needY);
        if (!Number.isFinite(s1)) s1 = MAX_SCALE;
        if (s1 > MAX_SCALE) s1 = MAX_SCALE;
        
        // Toggle Zoom Out if already zoomed
        if (s0 > 1.2 && Math.abs(s1 - s0) < 0.5) s1 = 1; 

        clampAndApply(img, s1, targetOffX, targetOffY);
      });
    }

    async function waitForSlotPngUrl(outputBasePath, slotIndex, opts = {}) {
      const timeoutMs  = Number(opts.timeoutMs ?? 600000);  // Increased to 10 min
      const intervalMs = Number(opts.intervalMs ?? 3000);   // Increased to 3s to reduce load
      const fileName = `Slot_${slotIndex + 1}.png`;
      const afterUpdatedMs  = opts.afterUpdatedMs == null ? null : Number(opts.afterUpdatedMs);
      const afterGeneration = opts.afterGeneration == null ? null : Number(opts.afterGeneration);

      // Stagger initial check to prevent thundering herd of 8 concurrent requests
      await sleep(Math.random() * 3000); 

      const t0 = Date.now();
      while (true) {
        await ensureStorageSignedIn();

        // âœ… Only LIST-first polling.
        try {
          const folderRef = ref(storage, outputBasePath);
          const res = await listAll(folderRef);
          const hit = (res.items || []).find(it => it.name === fileName);
          if (hit) {
            // If this call is part of a Redo, the slot file likely already exists.
            // Only return once we detect the file has been overwritten (metadata changed).
            if (afterUpdatedMs != null || afterGeneration != null) {
              try {
                const meta = await getMetadata(hit);
                const updatedMs = Date.parse(meta?.updated || meta?.timeCreated || "") || 0;
                const gen = Number(meta?.generation || 0) || 0;

                const okGen = (afterGeneration == null) ? true : (gen > afterGeneration);
                const okUpd = (afterUpdatedMs == null)  ? true : (updatedMs > afterUpdatedMs);

                if (!okGen || !okUpd) {
                  // Found the file, but it's still the old version â€” keep waiting.
                  throw new Error("slot_not_updated_yet");
                }
              } catch (e2) {
                if (String(e2?.message || e2).includes("slot_not_updated_yet")) {
                  // keep waiting
                } else {
                  // transient metadata issue â€” keep waiting
                }
                throw e2;
              }
            }

            try {
              const url = await getDownloadURL(hit);
              return { storagePath: hit.fullPath, url };
            } catch (eUrl) {
              const msg = String(eUrl?.message || eUrl);
              const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");

              if (looksUnauthorized) {
                throw new Error(
                  `Cannot download ${hit.fullPath} (permission/token issue).\n` +
                  `If this slot was produced via server-side copy(), ensure metadata.firebaseStorageDownloadTokens is set on the copied object.\n` +
                  `Server fix: after copy() call setMetadata({ metadata: { firebaseStorageDownloadTokens: <uuid> } }).`
                );
              }
              throw eUrl;
            }
          }
        } catch (e) {
          // If LIST is blocked by Storage rules, we cannot poll without causing 404s.
          const msg = String(e?.message || e);
          
          // Check for 500 error specifically and backoff
          if (msg.includes("500") || msg.includes("internal")) {
             console.warn("Storage 500 error, retrying with backoff...", outputBasePath);
             await sleep(5000); 
             // Don't throw, just loop again after wait
          } else {
             const looksUnauthorized =
                msg.includes("storage/unauthorized") ||
                msg.includes("403") ||
                msg.toLowerCase().includes("permission");
             if (looksUnauthorized) {
                throw new Error(
                `Storage rules block LIST on: ${outputBasePath}\n` +
                `Allow LIST for Ready_To_List (or at least ${outputBasePath}) so the UI can detect Slot PNGs without any 404 polling.`
                );
             }
             // transient listing issue: keep waiting
          }
        }

        if ((Date.now() - t0) > timeoutMs) {
          throw new Error(`Timed out waiting for ${fileName} in ${outputBasePath}`);
        }
        await sleep(intervalMs);
      }
    }

    // --- UI State ---
    const activeCategoryEl = document.getElementById("activeCategory");
    const panelsEl = document.getElementById("panels");
    const panelNewCharmsEl = document.getElementById("panelNewCharms");
    const generateSetBtn = document.getElementById("generateSet");
    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");

    // --- Mode Variables ---
    const toggleGenerateBtn = document.getElementById("toggleGenerate");
    const toggleReviewBtn = document.getElementById("toggleReview");
    const toggleCharmMakerBtn = document.getElementById("toggleCharmMaker");
    const generateSection = document.getElementById("generateSection");
    const reviewSection = document.getElementById("reviewSection");
    const charmMakerSection = document.getElementById("charmMakerSection");
    const reviewSetSelect = document.getElementById("reviewSetSelect");
    const approveSetBtn = document.getElementById("approveSetBtn"); 
    const backgroundQueueStatus = document.getElementById("backgroundQueueStatus"); // Status text
    let appMode = "generate"; // 'generate', 'review', or 'charmMaker'

    function setStatus(msg){ statusEl.textContent = msg; }

    // Busy-state helper (Generate button + basic UI lock)
    function setBusy(isBusy){
      generateSetBtn.disabled = !!isBusy;
      generateSetBtn.style.opacity = isBusy ? "0.6" : "1";
      generateSetBtn.style.cursor = isBusy ? "not-allowed" : "pointer";
      // approveSetBtn is now managed by the background Queue, not blocking the UI globally
    }

   // Current generated set context (used by per-slot Redo)
    let CURRENT_SET = null; // { category, outputBasePath, setN }
    
    // NEW: Global tracker for Redo operations across all sets
    const REDO_STATE = {}; 

    function setAllRedoEnabled(enabled){
      gridEl.querySelectorAll("button.redoBtn").forEach(b => { b.disabled = !enabled; });
    }

    function cacheBust(url){
      if (!url) return url;
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}v=${Date.now()}`;
    }

    async function redoSlot(slotIndex){
      if (!CURRENT_SET?.outputBasePath || !CURRENT_SET?.category) {
        throw new Error("No active set to redo yet. Generate a set first.");
      }

      const ctxSetPath = CURRENT_SET.outputBasePath;
      const ctxCategory = CURRENT_SET.category;
      const ctxSetN = CURRENT_SET.setN;
      
      const slotPlan = SLOT_MAP[ctxCategory];
      const spec = slotPlan?.[slotIndex];
      if (!spec) throw new Error(`Invalid slotIndex ${slotIndex} for ${ctxCategory}`);
      
      const redoKey = `${ctxSetPath}::${slotIndex}`;

      REDO_STATE[redoKey] = { status: 'running' };
      updateDropdownLabels(); 
      updateApproveButtonState(); // NEW: Check state immediately

      const slotFileName = `Slot_${slotIndex + 1}.png`;
      const slotStoragePath = `${ctxSetPath}/${slotFileName}`;
      let beforeUpdatedMs = 0;
      let beforeGeneration = 0;
      try {
        await ensureStorageSignedIn();
        const beforeMeta = await getMetadata(ref(storage, slotStoragePath));
        beforeUpdatedMs = Date.parse(beforeMeta?.updated || beforeMeta?.timeCreated || "") || 0;
        beforeGeneration = Number(beforeMeta?.generation || 0) || 0;
      } catch (_) {
        // Slot may not exist yet
      }

      // Check if we are still viewing the set we initiated this from
      const isViewing = (CURRENT_SET?.outputBasePath === ctxSetPath);
      
      if (isViewing) {
          const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
          const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
          const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
          
          if (redoBtn) redoBtn.disabled = true;
          if (prevBox) {
              prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
              prevBox.classList.remove("success-border"); // RESET BORDER
          }
          setStatus(`Redo Slot ${slotIndex + 1}â€¦`);
      }

      const srcFolder = slotRefFolder(ctxCategory, spec.folder);
      const srcRandom = await listRandomFile(srcFolder); 
      if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);

      const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(ctxCategory);
      const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
      const charmLatest = await listLatestFile(charmFolderPath); 
      if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);
      
      let waitedResult = null; 

      try {
          if (spec.type === "copy") {
            const r = await postJson(GEMINI_FN, {
              kind: "copy_to_slot",
              activeCategory: ctxCategory,
              source_storage_path: srcRandom.fullPath, 
              output_base_path: ctxSetPath,
              slotIndex,
            });

            waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          } else {
            await postJson(GEMINI_BG_FN, {
              kind: "edits",
              activeCategory: ctxCategory,
              input_storage_path: srcRandom.fullPath, 
              input_charm_storage_path: charmLatest.fullPath,
              output_base_path: ctxSetPath,
              slotIndex,
              model: "gemini-3-pro-image-preview",
              prompt: buildSlotPrompt(ctxCategory, spec.folder, slotIndex + 1),
            });

              waitedResult = await waitForSlotPngUrl(ctxSetPath, slotIndex, {
              afterUpdatedMs: beforeUpdatedMs,
              afterGeneration: beforeGeneration,
            });
          }
          
          // SUCCESSS Handling
          const finalUrl = cacheBust(waitedResult.url);
          REDO_STATE[redoKey] = { status: 'completed', url: finalUrl };
          updateDropdownLabels(); 
          updateApproveButtonState(); // NEW: Check state again

          // If still viewing, update DOM
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
              const slotCard = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"]`);
              const prevBox  = slotCard?.querySelector(`#slotPrev_${slotIndex}`);
              const metaEl   = slotCard?.querySelector(`#slotMeta_${slotIndex}`);
              const redoBtn  = slotCard?.querySelector(`#redo_${slotIndex}`);
              
              if (prevBox) {
                  prevBox.innerHTML = `<img src="${finalUrl}" />`;
                  // âœ… ATTACH LISTENERS AFTER REDO
                  attachPreviewBoxListeners(prevBox);
                  prevBox.classList.add("success-border"); 
              }
              if (metaEl) metaEl.textContent = `Source: ${srcRandom.fullPath}`;
              if (redoBtn) redoBtn.disabled = false;
              setStatus(`Ready (Set_${ctxSetN})`);
          }

      } catch(err) {
          console.error("Redo failed", err);
          delete REDO_STATE[redoKey];
          updateDropdownLabels();
          updateApproveButtonState(); // NEW: Ensure state is reset on error
          if (CURRENT_SET?.outputBasePath === ctxSetPath) {
             const prevBox = gridEl.querySelector(`.slot[data-slot-index="${slotIndex}"] #slotPrev_${slotIndex}`);
             if (prevBox) prevBox.innerHTML = `<div class="slotRefEmpty">Error</div>`;
             setStatus("Redo failed: " + err.message);
          }
      }

      // MANIFEST UPDATE (Non-blocking usually, but await here for consistency)
      try {
        const manifestRef = ref(storage, `${ctxSetPath}/manifest.json`);
        
        const buffer = await getBytes(manifestRef);
        const text = new TextDecoder().decode(buffer);
        const manifestJson = JSON.parse(text);

        const slotNum = slotIndex + 1;
        const idx = manifestJson.slots.findIndex(s => s.slot === slotNum);
        
        const newEntry = {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcRandom.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waitedResult?.storagePath || "",
            updatedAt: new Date().toISOString()
        };

        if (idx > -1) {
            manifestJson.slots[idx] = { ...manifestJson.slots[idx], ...newEntry };
        } else {
            manifestJson.slots.push(newEntry);
            manifestJson.slots.sort((a,b) => a.slot - b.slot);
        }

        await postJson("geminiImageProxy", {
            kind: "write_manifest",
            activeCategory: ctxCategory,
            output_base_path: ctxSetPath,
            manifest: manifestJson,
        });
      } catch (e) {
        console.warn("Manifest update failed (non-fatal):", e);
      }
    }
    
    window.redoSlot = redoSlot;

    // Back-compat alias
    const categoryEl = activeCategoryEl;

    function folderPath(category, subfolder) {
      return `${ROOT}/${category}/${subfolder}`;
    }

    function newCharmsPath() {
      return `${ROOT}/New_Charms`;
    }

    function newCharmsEarringsPath() {
      return `${ROOT}/New_Charms_Earrings`;
    }

    // -------------------------------------------------------------------------
    // NEW: Randomizer Function
    // -------------------------------------------------------------------------
    async function listRandomFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      
      if (!res.items?.length) return null;

      const randomIndex = Math.floor(Math.random() * res.items.length);
      const randomItem = res.items[randomIndex];
      const url = await getDownloadURL(randomItem);
      return { fullPath: randomItem.fullPath, name: randomItem.name, url };
    }

    async function listLatestFile(fullFolderPath) {
      await ensureStorageSignedIn();
      const folderRef = ref(storage, fullFolderPath);
      const res = await listAll(folderRef);
      if (!res.items?.length) return null;

      const metas = await Promise.all(res.items.map(async (it) => {
        const meta = await getMetadata(it);
        return {
          fullPath: it.fullPath,
          name: it.name,
          updatedMs: Date.parse(meta?.updated || meta?.timeCreated || "") || 0,
        };
      }));

      metas.sort((a, b) => {
        if (a.updatedMs !== b.updatedMs) return a.updatedMs - b.updatedMs;
        return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
      });

      const latest = metas[metas.length - 1];
      const latestRef = ref(storage, latest.fullPath);
      const url = await getDownloadURL(latestRef);
      return { fullPath: latest.fullPath, name: latest.name, url };
    }

    function makeUploadPanel(targetFullPath, title) {
     const el = document.createElement("div");
      el.className = "drop";
      el.style.marginBottom = "10px";
      el.innerHTML = `
        <div style="flex:1;">
          <strong>${title}</strong>
          <div class="muted"><code>${targetFullPath}/</code></div>
          <div class="muted" id="count">Loadingâ€¦</div>
        </div>
        <div class="row">
          <input type="file" multiple accept="image/*" />
        </div>
      `;

      const input = el.querySelector("input");
      const countEl = el.querySelector("#count");

      async function refreshCount() {
        try {
          await ensureStorageSignedIn();
          const res = await listAll(ref(storage, targetFullPath));
          countEl.textContent = `${res.items.length} file(s)`;
        } catch (e) {
          console.warn("[Storage:listAll] failed", { targetFullPath, e });
        }
      }

      async function uploadFiles(files) {
        if (!files?.length) return;
        await ensureStorageSignedIn();
        setStatus(`Uploading â†’ ${title}`);

        for (const f of files) {
          const safeName = `${Date.now()}_${f.name.replace(/[^\w.\-]+/g, "_")}`;
          const dst = ref(storage, `${targetFullPath}/${safeName}`);
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(dst, f, { contentType: f.type || "application/octet-stream" });
            task.on("state_changed", null, reject, resolve);
          });
        }
        await refreshCount();
        setStatus("Idle");
      }

      el.addEventListener("dragover", (e) => { e.preventDefault(); el.classList.add("hover"); });
      el.addEventListener("dragleave", () => el.classList.remove("hover"));
      el.addEventListener("drop", async (e) => {
        e.preventDefault();
        el.classList.remove("hover");
        await uploadFiles([...e.dataTransfer.files]);
      });

      input.addEventListener("change", async (e) => {
        await uploadFiles([...e.target.files]);
        input.value = "";
      });

      refreshCount();
      refreshCount().catch((e) => console.warn("refreshCount failed", e));
      return el;
    }

    function renderCategoryUI(category) {
      panelsEl.innerHTML = "";

      const subs = CATEGORY_SUBFOLDERS[category] || [];
      for (const sub of subs) {
        panelsEl.appendChild(makeUploadPanel(folderPath(category, sub), sub));
      }

      panelNewCharmsEl.innerHTML = "";
      if (["Stud_Earrings", "Hoop_Earrings"].includes(category)) {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsEarringsPath(), "New_Charms_Earrings (Earrings Only)"));
      } else {
        panelNewCharmsEl.appendChild(makeUploadPanel(newCharmsPath(), "New_Charms (Necklaces/Other)"));
      }

      const slotCount = (SLOT_MAP[category]?.length) || 0;
      if (GENERATABLE_CATEGORIES.has(category)) {
        setStatus(`Ready (${slotCount} slot(s))`);
      } else {
        setStatus("Asset manager only");
      }
    }

    activeCategoryEl.innerHTML = ALL_CATEGORIES.map(c => `<option value="${c}">${c}</option>`).join("");
    activeCategoryEl.value = "Beady_Necklace";
    renderCategoryUI(activeCategoryEl.value);

    // --- Tab Switching Logic ---
    function setAppMode(mode) {
      appMode = mode;
      
      toggleGenerateBtn.style.background = "transparent";
      toggleGenerateBtn.style.color = "var(--muted)";
      toggleReviewBtn.style.background = "transparent";
      toggleReviewBtn.style.color = "var(--muted)";
      toggleCharmMakerBtn.style.background = "transparent";
      toggleCharmMakerBtn.style.color = "var(--muted)";
      
      generateSection.style.display = "none";
      reviewSection.style.display = "none";
      charmMakerSection.style.display = "none";
      
      gridEl.innerHTML = "";

      if (mode === "generate") {
        toggleGenerateBtn.style.background = "var(--line)";
        toggleGenerateBtn.style.color = "var(--text)";
        generateSection.style.display = "block";
        renderCategoryUI(activeCategoryEl.value);
        setStatus("Ready");
      } else if (mode === "review") {
        toggleReviewBtn.style.background = "var(--line)";
        toggleReviewBtn.style.color = "var(--text)";
        reviewSection.style.display = "block";
        loadReviewSets();
      } else if (mode === "charmMaker") {
        toggleCharmMakerBtn.style.background = "var(--line)";
        toggleCharmMakerBtn.style.color = "var(--text)";
        charmMakerSection.style.display = "block";
        setStatus("Charm Maker Database");
        loadCharmMakerPreviews();
      }
    }

    toggleGenerateBtn.addEventListener("click", () => setAppMode("generate"));
    toggleReviewBtn.addEventListener("click", () => setAppMode("review"));
    toggleCharmMakerBtn.addEventListener("click", () => setAppMode("charmMaker"));


    activeCategoryEl.addEventListener("change", () => {
      if (appMode === "generate") {
        renderCategoryUI(activeCategoryEl.value);
      } else if (appMode === "review") {
        loadReviewSets();
        gridEl.innerHTML = "";
      }
    });

    // --- Loading Sets functionality ---
    async function loadReviewSets() {
      const category = activeCategoryEl.value;
      setStatus("Loading sets...");
      reviewSetSelect.innerHTML = `<option>Loading...</option>`;
      try {
        await ensureStorageSignedIn();
        const readyToListRef = ref(storage, `${ROOT}/${category}/Ready_To_List`);
        const res = await listAll(readyToListRef);
        const sets = res.prefixes.map(p => p.name).filter(n => n.startsWith('Set_'));
        sets.sort((a, b) => {
          const numA = parseInt(a.replace('Set_', '')) || 0;
          const numB = parseInt(b.replace('Set_', '')) || 0;
          return numB - numA;
        });

        if (sets.length > 0) {
          reviewSetSelect.innerHTML = sets.map(s => `<option value="${s}">${s}</option>`).join("");
          setStatus(`Found ${sets.length} sets.`);
          
          updateDropdownLabels();
          
          // Auto-load first item if present
          if (reviewSetSelect.value) {
              loadSetImages(reviewSetSelect.value);
          }
        } else {
          reviewSetSelect.innerHTML = `<option value="">No sets found</option>`;
          setStatus("No sets found.");
          gridEl.innerHTML = "";
        }
      } catch (e) {
        console.error("Error loading sets:", e);
        setStatus("Error loading sets");
        reviewSetSelect.innerHTML = `<option value="">Error loading</option>`;
      }
    }
    
    function updateDropdownLabels() {
        const category = activeCategoryEl.value;
        const options = Array.from(reviewSetSelect.options);
        
        options.forEach(opt => {
            const setName = opt.value;
            if (!setName) return;
            
            const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
            
            const statuses = [];
            Object.keys(REDO_STATE).forEach(key => {
                if (key.startsWith(setPath)) {
                    const slotIdx = key.split('::')[1];
                    const slotNum = parseInt(slotIdx) + 1;
                    const state = REDO_STATE[key];
                    if (state.status === 'running') {
                        statuses.push(`Slot ${slotNum}: â³`);
                    } else if (state.status === 'completed') {
                        statuses.push(`Slot ${slotNum}: ðŸŸ¢`);
                    }
                }
            });
            
            if (statuses.length > 0) {
                opt.text = `${setName} (${statuses.join(', ')})`;
            } else {
                opt.text = setName;
            }
        });
    }

    // NEW: Function to toggle approve button status
    function updateApproveButtonState() {
      if (!approveSetBtn) return;
      
      // Default Green Style
      const setGreen = () => {
        approveSetBtn.disabled = false;
        approveSetBtn.style.background = "#1f4026";
        approveSetBtn.style.color = "#7fdb96";
        approveSetBtn.style.border = "1px solid #2f5e3a";
        approveSetBtn.textContent = "Approve Set (Move to Completed)";
        approveSetBtn.style.cursor = "pointer";
        approveSetBtn.style.opacity = "1";
      };

      // Orange Style
      const setOrange = () => {
        approveSetBtn.disabled = true;
        approveSetBtn.style.background = "#7c2d12"; // Darker orange/rust
        approveSetBtn.style.color = "#fdba74"; // light orange
        approveSetBtn.style.border = "1px solid #ea580c";
        approveSetBtn.textContent = "Waiting for Redo...";
        approveSetBtn.style.cursor = "not-allowed";
        approveSetBtn.style.opacity = "0.8";
      };

      if (!CURRENT_SET || appMode !== 'review') {
         return; 
      }

      const setPath = CURRENT_SET.outputBasePath;
      let hasRunning = false;
      
      Object.keys(REDO_STATE).forEach(k => {
        if (k.startsWith(setPath) && REDO_STATE[k].status === 'running') {
          hasRunning = true;
        }
      });

      if (hasRunning) {
        setOrange();
      } else {
        setGreen();
      }
    }

    // NEW: Consolidated Load Function
    async function loadSetImages(setName) {
      if (!setName) return;

      const category = activeCategoryEl.value;
      setBusy(true);
      setStatus(`Loading ${setName}...`);
      gridEl.innerHTML = "";

      try {
        await ensureStorageSignedIn();
        const setPath = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const setRef = ref(storage, setPath);
        const res = await listAll(setRef);

        let parsedSetN = parseInt(setName.replace('Set_', '')) || 0;
        CURRENT_SET = { category, outputBasePath: setPath, setN: parsedSetN };

        // 404 Safety: try/catch the manifest load
        let manifestData = null;
        try {
            const manifestRef = ref(storage, `${setPath}/manifest.json`);
            const buffer = await getBytes(manifestRef);
            const text = new TextDecoder().decode(buffer);
            manifestData = JSON.parse(text);
        } catch(err) {
            // expected if manifest doesn't exist
        }

        const slotPlan = SLOT_MAP[category] || [];
        
        slotPlan.forEach((spec, i) => {
          const slotNum = i + 1;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          slotCard.dataset.slotIndex = i;

          let sourceStr = "Unknown";
          if (manifestData && manifestData.slots) {
              const slotMeta = manifestData.slots.find(s => s.slot === slotNum);
              if (slotMeta && slotMeta.source) sourceStr = slotMeta.source;
          }

          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">Review: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Loadingâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${sourceStr}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        });

        slotPlan.forEach((_, i) => {
             const key = `${setPath}::${i}`;
             const state = REDO_STATE[key];
             const prevBox = document.getElementById(`slotPrev_${i}`);
             const redoBtn = document.getElementById(`redo_${i}`);

             if (state && state.status === 'running') {
                 if (prevBox) {
                    prevBox.innerHTML = `<div class="slotRefEmpty">Workingâ€¦</div>`;
                    prevBox.classList.remove("success-border");
                 }
                 if (redoBtn) redoBtn.disabled = true;
             } 
             else if (state && state.status === 'completed') {
                 if (prevBox) prevBox.classList.add("success-border");
             }
        });

        const slotFiles = res.items.filter(item => item.name.startsWith("Slot_") && item.name.endsWith(".png"));
        
        await Promise.all(slotFiles.map(async (fileRef) => {
          const match = fileRef.name.match(/Slot_(\d+)\.png/);
          if (match) {
            const slotIndex = parseInt(match[1]) - 1;
            
            const key = `${setPath}::${slotIndex}`;
            if (REDO_STATE[key]?.status === 'running') return;

            try {
              const url = await getDownloadURL(fileRef);
              const prevBox = document.getElementById(`slotPrev_${slotIndex}`);
              if (prevBox) {
                const finalUrl = cacheBust(url);
                prevBox.innerHTML = `<img src="${finalUrl}" />`;
                // âœ… ATTACH LISTENERS AFTER LOADING
                attachPreviewBoxListeners(prevBox);
              }
            } catch (err) {
              // ignore
            }
          }
        }));

        slotPlan.forEach((spec, i) => {
          const prevBox = document.getElementById(`slotPrev_${i}`);
          if (prevBox && prevBox.innerHTML.includes("Loadingâ€¦")) {
            prevBox.innerHTML = `<div class="slotRefEmpty">Not Found</div>`;
          }
        });

        setStatus(`Viewing ${category} / ${setName}`);
      } catch (e) {
        // If the set folder itself is gone (404 on listAll), handle gracefully
        if (e.code === 'storage/object-not-found') {
             gridEl.innerHTML = `<div class='slotRefEmpty'>Set '${setName}' not found (might be deleted/moved).</div>`;
        } else {
             console.error(e);
             setStatus(`Error: ${e.message}`);
        }
      } finally {
        setBusy(false);
        updateApproveButtonState(); // NEW: Verify button state after load
      }
    }
    
    reviewSetSelect.addEventListener("change", (e) => {
        loadSetImages(e.target.value);
    });

    // NEW: "Optimistic" Approve function
    function approveSet() {
      const category = activeCategoryEl.value;
      const setName = reviewSetSelect.value;
      if (!setName) return;

      if (!confirm(`Approve ${setName}? (Instant Queue)`)) return;

      // 1. Remove from UI immediately
      const optionToRemove = reviewSetSelect.querySelector(`option[value="${setName}"]`);
      if (optionToRemove) optionToRemove.remove();

      // 2. Load next set immediately if exists
      if (reviewSetSelect.options.length > 0) {
          // Select first available (or keep index)
          reviewSetSelect.selectedIndex = 0; 
          loadSetImages(reviewSetSelect.value);
      } else {
          gridEl.innerHTML = "<div class='slotRefEmpty'>No more sets to review!</div>";
          setStatus("Queue clear.");
      }

      // 3. Trigger background move
      runBackgroundApproval(category, setName);
    }

    // NEW: Background Task
    async function runBackgroundApproval(category, setName) {
        const queueId = `${category}/${setName}`;
        backgroundQueueStatus.textContent = `Queued: ${setName}...`;
        console.log(`[Queue] Starting background move for ${setName}`);

        const srcFolder = `${ROOT}/${category}/Ready_To_List/${setName}`;
        const destFolderName = `${category}_${setName}`; 
        const destFolder = `${ROOT}/Completed_Sets/${destFolderName}`;

        try {
            await ensureStorageSignedIn();
            const srcRef = ref(storage, srcFolder);
            const res = await listAll(srcRef);
            
            for (const itemRef of res.items) {
               // Download -> Upload -> Delete
               const buffer = await getBytes(itemRef);
               const newRef = ref(storage, `${destFolder}/${itemRef.name}`);
               await uploadBytesResumable(newRef, buffer); // âœ… Changed 'blob' to 'buffer'
               await deleteObject(itemRef);
            }
            console.log(`[Queue] Finished moving ${setName}`);
            backgroundQueueStatus.textContent = `Completed: ${setName}`;
            
            // Clear status after 3s
            setTimeout(() => {
                if (backgroundQueueStatus.textContent.includes(setName)) {
                    backgroundQueueStatus.textContent = "";
                }
            }, 3000);

        } catch (e) {
            console.error(`[Queue] Failed to move ${setName}`, e);
            backgroundQueueStatus.textContent = `Error moving ${setName}`;
        }
    }

    approveSetBtn.addEventListener("click", approveSet);
    
    async function postJson(path, body) {
      const res = await fetch(`${functionsBaseUrl}/${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      });

      // IMPORTANT: do NOT silently turn non-JSON into {}
      const raw = await res.text().catch(() => "");
      let j = null;
      try { j = raw ? JSON.parse(raw) : null; } catch { j = null; }

      if (!res.ok) {
        const msg =
          (j?.error?.message || j?.error) ||
          (raw ? raw.slice(0, 300) : "") ||
          `HTTP ${res.status}`;
        throw new Error(msg);
      }

      // Netlify background functions often return 202 with an empty body.
      if (!j) {
        if (res.status === 202 && (!raw || !raw.trim())) {
          return { ok: true, accepted: true, status: 202 };
        }
        throw new Error(`Non-JSON success response from ${path}: ${raw ? raw.slice(0,120) : "(empty body)"}`);
      }
      return j;
    }

    // Use the NON-background endpoint so we always get JSON back.
    const GEMINI_FN = "geminiImageProxy";
    const GEMINI_BG_FN = "geminiImageProxy-background";

    async function allocSet(category) {
      return await postJson(GEMINI_FN, { kind: "alloc_set", activeCategory: category });
    }

   function pickFirstString(...candidates) {
      for (const v of candidates) {
        if (typeof v === "string" && v.trim()) return v.trim();
      }
      return null;
    }

    function normalizeAllocOutputBasePath(alloc) {
      // Some backends return a string directly, others nest under data/result/payload.
      if (typeof alloc === "string") return alloc.trim() || null;
      if (!alloc || typeof alloc !== "object") return null;

      const a = alloc;
      const d = a.data && typeof a.data === "object" ? a.data : null;
      const r = a.result && typeof a.result === "object" ? a.result : null;
      const p = a.payload && typeof a.payload === "object" ? a.payload : null;

      return pickFirstString(
        // top-level
        a.outputBasePath, a.output_base_path, a.output_base_path, a.outputBase, a.basePath,
        // common nesting
        d?.outputBasePath, d?.output_base_path, d?.outputBase, d?.basePath,
        r?.outputBasePath, r?.output_base_path, r?.outputBase, r?.basePath,
        p?.outputBasePath, p?.output_base_path, p?.outputBase, p?.basePath
      );
    }

    function slotRefFolder(category, folder) {
      return `${ROOT}/${category}/${folder}`;
    }

    async function generateSet() {
      setBusy(true);
      try {
        const category = String(categoryEl.value || "").trim();
        if (!category) throw new Error("Pick a category first.");
        const slotPlan = SLOT_MAP[category];
        if (!slotPlan) throw new Error(`Unknown category: ${category}`);

        setStatus("Allocating Setâ€¦");
        const alloc = await allocSet(category);
        console.log("alloc_set response:", alloc);
        const outputBasePath = normalizeAllocOutputBasePath(alloc);
        if (!outputBasePath) throw new Error("alloc_set did not return a valid outputBasePath");

        // Prefer server-provided setN, but fall back to parsing from outputBasePath
        let setN = alloc?.setN ?? alloc?.set_n;
        if (setN == null) {
          const m = outputBasePath.match(/\/Set_(\d+)\b/);
          if (m) setN = Number(m[1]);
        }

        // Save current set context for per-slot Redo
        CURRENT_SET = { category, outputBasePath, setN };

        // âœ… LOGIC UPDATE: Pick charm source based on category
        const isEarring = ["Stud_Earrings", "Hoop_Earrings"].includes(category);
        const charmFolderPath = isEarring ? newCharmsEarringsPath() : newCharmsPath();
        
        // Constraint C: Charms are NOT randomized. Keep listLatestFile here.
        const charmLatest = await listLatestFile(charmFolderPath);
        if (!charmLatest) throw new Error(`No files in ${charmFolderPath}/`);

        const manifest = {
          category,
          setN,
          outputBasePath,
          timestamp: new Date().toISOString(),
          slots: [],
          model: "gemini-3-pro-image-preview",
        };

        // 1) Resolve all slot sources up front
        // Constraint A & B: Randomize slot reference images.
        setStatus("Preparing slots (Randomizing)â€¦");
        const slotResolved = await Promise.all(slotPlan.map(async (spec, i) => {
          const srcFolder = slotRefFolder(category, spec.folder);
          // CHANGED: Use listRandomFile instead of listLatestFile
          const srcRandom = await listRandomFile(srcFolder);
          if (!srcRandom) throw new Error(`No files in ${srcFolder}/`);
          return { spec, i, slotNum: i + 1, srcLatest: srcRandom };
        }));

        // 2) Render all slot cards immediately
        gridEl.innerHTML = "";
        for (const r of slotResolved) {
          const { spec, i, slotNum, srcLatest } = r;
          const slotCard = document.createElement("div");
          slotCard.className = "slot";
          // Add data-slot-index for easier selection
          slotCard.dataset.slotIndex = i; 
          slotCard.innerHTML = `
            <div class="slotTop">
              <b>Slot ${slotNum}</b>
              <div class="muted" style="font-size:12px;">${spec.type}: ${spec.folder}</div>
            </div>
            <div class="slotPrev" id="slotPrev_${i}"><div class="slotRefEmpty">Queuedâ€¦</div></div>
            <div class="small" id="slotMeta_${i}">Source: ${srcLatest.fullPath}</div>
            <button class="btn btnSmall redoBtn" id="redo_${i}" style="margin-top:8px; width:100%;" disabled onclick="redoSlot(${i})">Redo Slot ${slotNum}</button>
          `;
          gridEl.appendChild(slotCard);
        }

        setStatus("Starting background runâ€¦");

        // 3) Construct Tasks Object
        const tasks = slotResolved.map((r) => {
          const { spec, i, slotNum, srcLatest } = r;
          if (spec.type === "copy") {
            return {
              type: "copy",
              slotIndex: i,
              source_storage_path: srcLatest.fullPath,
            };
          }
          return {
            type: "edits",
            slotIndex: i,
            input_storage_path: srcLatest.fullPath,
            input_charm_storage_path: charmLatest.fullPath, // Pass the correct charm file
            prompt: buildSlotPrompt(category, spec.folder, slotNum),
            model: "gemini-3-pro-image-preview",
          };
        });

        // ---------------------------------------------------------
        // FIX: Decouple Trigger and Polling
        // ---------------------------------------------------------

        // A. Start Polling Logic (Wait for images to appear in Storage)
        // We start this PROMISE immediately, but await it later.
        const pollingPromise = Promise.all(slotResolved.map(async (r) => {
          const { spec, i, slotNum, srcLatest } = r;
          const prevBox = document.getElementById(`slotPrev_${i}`);
          const setImg = (url) => { 
            if (prevBox) {
                prevBox.innerHTML = `<img src="${url}" />`;
                // âœ… ATTACH LISTENERS AFTER GENERATION
                attachPreviewBoxListeners(prevBox);
            } 
          };

          // Wait for the file to appear
          const waited = await waitForSlotPngUrl(outputBasePath, i);
          
          // cache-bust so the preview updates even if the filename is overwritten
          const finalUrl = `${waited.url}${waited.url.includes("?") ? "&" : "?"}cb=${Date.now()}`;
          setImg(finalUrl);

          return {
            slot: slotNum,
            type: spec.type === "copy" ? "copy" : "gen",
            source: srcLatest.fullPath,
            newCharm: spec.type === "copy" ? null : charmLatest.fullPath,
            output: waited.storagePath,
          };
        }));

        // B. Fire the Trigger (Send request to server)
        // âœ… CRITICAL FIX: We MUST await this. 
        // If the request fails, we throw immediately instead of waiting 10 minutes for a timeout.
        try {
            await postJson(GEMINI_BG_FN, {
              kind: "run_set_async",
              activeCategory: category,
              output_base_path: outputBasePath,
              delayMs: 20000, // 20.0s spacing between Gemini slot submissions
              tasks,
            });
            console.log("Background run triggered successfully");
        } catch (err) {
            // Throwing here stops execution, preventing the polling timeout error.
            throw new Error(`Failed to start generation on server: ${err.message}`);
        }

        setStatus("Generatingâ€¦ (Monitoring Storage)");

        // C. Wait for Polling to finish (This confirms images are created)
        const results = await pollingPromise;
        
        // Sort results to match manifest order
        results.sort((a, b) => a.slot - b.slot);
        manifest.slots = results;

        setStatus("Writing manifestâ€¦");
        await postJson("geminiImageProxy", {
          kind: "write_manifest",
          activeCategory: category,
          output_base_path: outputBasePath,
          manifest,
        });

        setStatus(`Done â†’ ${category}/Ready_To_List/Set_${setN}`);
        // Now that the set is done, enable per-slot Redo buttons
        setAllRedoEnabled(true);
      } catch (e) {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      } finally {
        setBusy(false);
      }
    }

    // --- Charm Maker Logic ---
    let currentCharmRef = null;
    let currentEarringRef = null;

    const previewNewCharms = document.getElementById("previewNewCharms");
    const previewNewCharmsEarrings = document.getElementById("previewNewCharmsEarrings");
    const executeCharmGenBtn = document.getElementById("executeCharmGenBtn");
    const charmMakerResults = document.getElementById("charmMakerResults");
    const resultPrevCharms = document.getElementById("resultPrevCharms");
    const resultPrevEarrings = document.getElementById("resultPrevEarrings");

    async function loadCharmMakerPreviews() {
      previewNewCharms.innerHTML = `<div class="slotRefEmpty">Fetching...</div>`;
      previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Fetching...</div>`;
      
      try {
        await ensureStorageSignedIn();
        
        // Fetch next available standard charm
        const charmsLatest = await listLatestFile(newCharmsPath());
        currentCharmRef = charmsLatest;
        if (charmsLatest) {
          previewNewCharms.innerHTML = `<img src="${cacheBust(charmsLatest.url)}" />`;
        } else {
          previewNewCharms.innerHTML = `<div class="slotRefEmpty">Queue Empty</div>`;
        }

        // Fetch next available earring charm
        const earringsLatest = await listLatestFile(newCharmsEarringsPath());
        currentEarringRef = earringsLatest;
        if (earringsLatest) {
          previewNewCharmsEarrings.innerHTML = `<img src="${cacheBust(earringsLatest.url)}" />`;
        } else {
          previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Queue Empty</div>`;
        }
      } catch (e) {
        console.error("Error fetching charm previews:", e);
        previewNewCharms.innerHTML = `<div class="slotRefEmpty">Error loading</div>`;
        previewNewCharmsEarrings.innerHTML = `<div class="slotRefEmpty">Error loading</div>`;
      }
    }

executeCharmGenBtn.addEventListener("click", async () => {
        // Step 1: We now only require the base Charm reference from New_Charms
        if (!currentCharmRef) {
            alert("No reference charm loaded in the New_Charms queue. Please upload to New_Charms.");
            return;
        }

        const basePrompt = `CRITICAL INITIAL ANALYSIS: Before generating, conceptually analyze the reference image to determine its exact genre and subject matter (e.g., "Genre: Animal, Subject Matter: Rabbit/Leporidae"). Use this specific analysis as the strict foundational concept for the new charm. DO NOT add additional jump rings and chains.

        TASK: Generate a highly realistic, 2D jewelry charm that functions as a thematic and aesthetic extension of the provided reference based on your analysis. Your goal is to keep the SAME genre and loosely similar subject matter and overall concept but adapt it to attract similar audiences.

        HARD PHYSICAL CONSTRAINTS (NON-NEGOTIABLE):
        â€¢ Use engravings very sparingly and very strategically. Do not cram too many pointless engravings onto the charm.
        â€¢ Leave a lot of white space between the engravings; do not bunch up engravings and cutouts closely together.
        â€¢ FLAT SHEET METAL: The charm must appear as a perfectly flat, thin sheet of high-polish metal.
        â€¢ SHARP 2D CUTOUTS: Use laser-cut precision. Do NOT allow rounded edges, bevels, or 3D thickness.
        â€¢ VIEWPOINT: Always render the charm perfectly front-facing (orthographic) with 0% perspective tilt.
        â€¢ BACKGROUND COLOR (CRITICAL): Generate the charm on a 100% PURE SOLID BLACK (#000000) background. Absolutely NO white backgrounds, NO grey backgrounds, and NO transparency.
        â€¢ NO TEXT: Never render letters, numbers, or words.

        THEMATIC & AESTHETIC EVOLUTION:
        â€¢ You may only introduce minor stylistic alterations to the outer contour (e.g., slightly sharper points, smoother curves, or stylistic edges) while preserving the exact overall recognizable footprint.
        â€¢ AESTHETIC ANCHORING: Maintain the exact gold tone, luminosity, and "luxe-minimalist" feel of the reference image. The "vibe" must remain cohesive.
        â€¢ ENGRAVING DEPTH: All internal details must be surface-level laser etchings. No embossing or 3D extrusion.

        NEGATIVE CONSTRAINTS (NEVER DO THESE):
        â€¢ NEVER generate a white background. It MUST be pure solid black.
        â€¢ NEVER add additional jump rings and chains
        â€¢ NEVER introduce 3D volume, thickness, or side-profile views.
        â€¢ NEVER use matte or brushed textures if the reference is high-polish.
        â€¢ NEVER deviate from the established level of intricate detail seen in the reference.`;

        // Add the Hoop Prompt ONLY for standard New_Charms
        const promptStrCharm = basePrompt + `\n\nHOOP/BAIL REQUIREMENT (CRITICAL):
        â€¢ We must ensure that the hoop already present in the reference image MUST ALWAYS be correctly and strategically positioned on the newly generated Charm. THIS IS A MUST AND ABSOLUTELY CRUCIAL!!!!`;

        // NEW EARRING PROMPT: Strict instruction to only remove the hoop from the newly generated base charm
        const promptStrEarring = `CRITICAL INSTRUCTION: Analyze the provided reference image of a jewelry charm. 
        Your task is to generate an image that is 100% identical to this reference, keeping everything absolutely the same, with ONLY 1 EXCEPTION:
        
        Exception 1: Completely remove the hoop/bail from the top of the charm.

        HARD CONSTRAINTS:
        â€¢ Keep the exact same solid pure black (#000000) background. NO white or grey backgrounds.
        â€¢ Keep all engravings, cutouts, overall shape, proportions, and gold tone 100% identical to the reference.
        â€¢ Do not introduce any new elements, 3D thickness, or styling changes.
        â€¢ The final output MUST be the exact same charm, just missing the top hoop.`;

        setBusy(true);
        setStatus("Generating Base Charm Derivative...");
        executeCharmGenBtn.disabled = true;
        
        charmMakerResults.style.display = "block";
        resultPrevCharms.classList.remove("success-border");
        resultPrevEarrings.classList.remove("success-border");
        
        resultPrevCharms.innerHTML = `<div class="slotRefEmpty">Generating...</div>`;
        resultPrevEarrings.innerHTML = `<div class="slotRefEmpty">Waiting for Base...</div>`;

        try {
            const timestamp = Date.now();
            const outputBasePath = `${ROOT}/Completed_Charm/Deriv_${timestamp}`;
            
            // =========================================================
            // STEP 1: Generate the Base Charm (New_Charms Derivative)
            // =========================================================
            await postJson(GEMINI_BG_FN, {
                kind: "edits",
                activeCategory: "Charms", 
                input_storage_path: currentCharmRef.fullPath,
                input_charm_storage_path: currentCharmRef.fullPath,
                output_base_path: outputBasePath,
                slotIndex: 0,
                model: "gemini-3-pro-image-preview",
                prompt: promptStrCharm
            });

            // Poll for the Base Charm Result
            const charmRes = await waitForSlotPngUrl(outputBasePath, 0, { timeoutMs: 600000, intervalMs: 5000 });
            
            // Update UI for Base Charm
            resultPrevCharms.innerHTML = `<img src="${cacheBust(charmRes.url)}" />`;
            attachPreviewBoxListeners(resultPrevCharms);
            resultPrevCharms.classList.add("success-border");

            // =========================================================
            // STEP 2: Generate the Earring Twin using the Base Charm
            // =========================================================
            setStatus("Generating Earring Twin (Removing Hoop)...");
            resultPrevEarrings.innerHTML = `<div class="slotRefEmpty">Removing Hoop...</div>`;
            
            await sleep(2000); // Brief pause before firing second request
            
            await postJson(GEMINI_BG_FN, {
                kind: "edits",
                activeCategory: "Stud_Earrings", 
                // CRITICAL: Pass the NEWLY generated charm's storage path as the input!
                input_storage_path: charmRes.storagePath,
                input_charm_storage_path: charmRes.storagePath,
                output_base_path: outputBasePath,
                slotIndex: 1,
                model: "gemini-3-pro-image-preview",
                prompt: promptStrEarring
            });

            // Poll for Earring Twin Result
            const earringRes = await waitForSlotPngUrl(outputBasePath, 1, { timeoutMs: 600000, intervalMs: 5000 });
            
            // Update UI for Earring Twin
            resultPrevEarrings.innerHTML = `<img src="${cacheBust(earringRes.url)}" />`;
            attachPreviewBoxListeners(resultPrevEarrings);
            resultPrevEarrings.classList.add("success-border");

            setStatus("Derivatives Processing Complete.");

        } catch (err) {
            console.error("Master Generation Catch:", err);
            setStatus(`Error: ${err.message}`);
            
            // Reset "Waiting" state if it failed before reaching step 2
            if (resultPrevEarrings.innerHTML.includes("Waiting for Base...")) {
                resultPrevEarrings.innerHTML = `<div class="slotRefEmpty">Aborted</div>`;
            }
        } finally {
            setBusy(false);
            executeCharmGenBtn.disabled = false;
        }
    });

    // ------------------------------------------------------------
    // Per-slot prompt pipelines (Slots 1â€“8)
    // ------------------------------------------------------------
    
    // =========================================================================
    // 0. BEADY_NECKLACE
    // =========================================================================

    const SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).

    â€¢ Critical: Never Cut out darkened areas of the Charm/Pendant. Darkened portions of the Charm/Pendant are typically hatched engravings.

    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const SLOT3_SIZING_GUIDE_PROMPT =
    `CRITICAL: Slot 3 is a sizing-guide charm replacement task.

    PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Single pass only.
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 9 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 10 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ Do NOT allow any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement, block all Charm/Pendant related shadows.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ The chain must remain exactly the same size and detail as reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const SLOT7_PROMPT =
    `    ULTRA-MICRO SIZE OVERRIDE (TOP PRIORITY â€” MAKE IT BARELY VISIBLE)
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 13 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
     â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Do not embossed engravings on the Charm/Pendant, all engravings must be visible and flat and superficial having no descernable depth.
    â€¢ Limit any shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;


    // =========================================================================
    // 1. // REGULAR NECKLACE
    // =========================================================================
    const REGULAR_SLOT2_DUPLICATE_PROMPT = 
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    Do noy cutout any engravings, preserve ALL Charm/Pendant engravings in great detail.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const REGULAR_SLOT3_SIZING_GUIDE_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace ONLY the charm in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT add any necklace chain, jump ring, or jewelry.
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ The text â€œ~12mm x 12mmâ€ MUST remain visible, crisp, and identical.
    â€¢ The short black pointer line MUST remain visible and MUST point to the charm exactly.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The new charm must sit in the EXACT same position as the original charm in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY (Charm Image IS SINGLE TRUTH SOURCE)
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from Charm Image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    INTEGRATED HOOP RULE
    â€¢ The hoop/bail MUST be part of the same laser-cut silhouette as the charm body.
    â€¢ The hoop MUST connect with a wide, solid bridge of metal (large surface area).
    â€¢ HARD FAIL if the hoop looks barely touching, point-connected, floating, or welded-on.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_DEFAULT_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Slightly vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Charm Image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT4_PROMPT =
    `PROCESS ORDER (NON-NEGOTIABLE)
    â€¢ Use reference image as the base sizing-guide graphic.
    â€¢ Replace BOTH charms in the reference image with the charm from Charm image.

    INPUT IMAGES (ORDER MATTERS)
    â€¢ Reference Image = sizing guide base image (ALL text, layout, pencil, line, background)
    â€¢ Charm Image = charm macro (pixel-truth source for silhouette, cutouts, engraving, integrated hoop)

    ABSOLUTE LOCKS (DO NOT CHANGE)
    â€¢ Do NOT move, resize, restyle, blur, or alter any text.
    â€¢ Do NOT crop, zoom, or reframe the image.

    CHARM POSITION + SIZE MATCH (NON-NEGOTIABLE)
    â€¢ The silver necklace charm is the backside of the gold chain charm. When replacing the charms you must produce the same output where one charm is front facing and the silver charm is showing the bakc with an engraved name.
    â€¢ Both new charms must sit in the EXACT same position as the original charms in the reference image.
    â€¢ The new charm must match the original charmâ€™s on-image size EXACTLY.
    â€¢ This is a strict size match â€” no scaling up or down.

    CHARM FIDELITY
    â€¢ Preserve the exact outer perimeter, cutouts, engraving, and integrated hoop from the reference image.
    â€¢ Do NOT redraw, smooth, stylize, thicken, clean up, or reinterpret.
    â€¢ Keep edges crisp. No blur or smear.

    HARD FAIL CONDITIONS
    - Any text change.
    - Any charm size mismatch vs charm image.
    - Any weak or disconnected hoop connection.`;

    const REGULAR_SLOT5_PROMPT =
    `CRITICAL: This is a standard fashion product photo edit. Keep the subject modest. No nudity.

    ULTRA-MICRO SIZE OVERRIDE
    â€¢ Force the Charm to be very small: final on-image charm height MUST be 12 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ limit shadows (Contact or otherwise) to be visible undereath and around the Charm/Pendant placement.
    â€¢ The Charm/Pendant must be gold colour, do not saturate the Charm/Pendant gold colour, do not show visible reflections.
    â€¢ When generating the necklace chain ensure the fidelity of every single chain link and correct any link/chain imperfections.
    â€¢ Vary the wardrobe.

    TASK
    Duplicate and zoom-in into the female model in reference image, only replace the charm from Charm Image onto the existing necklace chain in reference image as a hanging flat charm.
    Match the subject identity from reference image; do not change the modelâ€™s appearance or skin tone.
    Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
    HARD LOCK: Never render female model above the neck and below the bust.
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with Reference Image
    Focus on Charm Engraving details and ensure 100% accuracy to Reference image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in Reference Image.`;

    const REGULAR_SLOT7_PROMPT =
    `ULTRA-MICRO SIZE OVERRIDE 
    â€¢ Force the Charm to be small: final on-image charm height MUST be 15 pixels tall (absolute pixel height, not relative).
    â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
    â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
    â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.
    â€¢ The Charm/Pendant must be gold in colour just like the necklace chain in the reference image, do not saturate the Charm/Pendant gold colour.
    â€¢ The chain must remain exactly the same size and detail as in the reference image. Only the charm is scaled.

    TASK
    Duplicate and zoom-in into the reference image, only replace the charm onto the existing necklace chain in the reference image as a hanging flat charm.
    Match the subject identity from reference image; 
    HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    DO NOT allow any rounded/radius on the cutout edges.
    DO not zoom out when generating the image. Keep model and frame consistent with the reference image.
    Focus on Charm Engraving details and ensure 100% accuracy to Charm image
    Do not output text.
    Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

  



    // =========================================================================
    // 2. // BRACELET PROMPTS
    // =========================================================================
    const BRACELET_MODEL_PROMPT =
    `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_CREATIVE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SIZE_GUIDE_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;

    const BRACELET_ENGRAVING_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    
    const BRACELET_SEC_MODEL_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;
    const BRACELET_PRODUCT_PROMPT =
   `  TASK:
        â€¢ Generate a photorealistic hoop earring model image based on the attached reference. 
        â€¢ Force the Charm to be ULTRA TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Critical: You must vary the model, ear, accessories but keep the style somewhat similar 
        â€¢ Critically: Keep Huggie/Hoop earring visible, photorealistic details, Yellow 14K gold colour.
        â€¢ Maintain zoom level and frame.
        â€¢ The Huggie/Hoop earring must be Yellow 14K gold colour 
        â€¢ DO NOT allow the Huggie/Hoop earring to be dark, grey, black, the Huggie/Hoop earring must be bright and light. 
        â€¢ Never allow embossed engravings on the Charm/Pendant, all engravings must be flat and superficial having no descernable depth.`;





    // =========================================================================
    // 3. // STUD EARRINGS PROMPTS
    // =========================================================================
    const STUD_MODEL_PROMPT =
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and thin sheet of metal, always render the Charm/Pendant completely flat
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. `;

    const STUD_CREATIVE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SIZE_GUIDE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be VERY SMALL)
        â€¢ Duplicate the female model and stud earrings in reference image, only replace the charm from Charm Image onto the existing stud earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow engraving colour to be dark, brown, or black, ensure all engraving colours are a light shade of copper colour`;

    const STUD_PRODUCT_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin.  
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;

    const STUD_PRODUCT_2_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ Ensure to always show the earring stud as it appears in the reference image
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ DO NOT allow any form of earring backings. Backings are the metal clips that slide onto the earring stud`;



















    // =========================================================================
    // 4. // HOOP EARRINGS PROMPTS
    // =========================================================================

    const HOOP_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
    â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
    â€¢ The new Charm must be the same or smaller size then the Reference Image. 
    â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
    â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
    â€¢ HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin. 
    â€¢ DO NOT allow any rounded/radius on the cutout edges.
    â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
    â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
    â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
    â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.
    â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;

    const HOOP_METAL_OPTIONS_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm (2 Yellow Gold & 2 Silver) using the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth. `;

    const HOOP_SIZE_PROMPT =
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all 4 charm from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;

    const HOOP_SEC_MODEL_PROMPT =
    `TASK (Force the Charm to be ULTRA TINY, EXTREMELY TINY, BARELY VISIBLE AS TINY AS POSSIBLE)
        â€¢ Duplicate the female model and hoop earrings in reference image, only replace the charm from Charm Image onto the existing hoop earring in reference image.
        â€¢ The new Charm must be the same or smaller size then the Reference Image. 
        â€¢ Your primary objective is to maintain Charm Engraving fidelity and accuracy to the Charm Reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
          HARD LOCK: The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and very thin, DO NOT allow any rounded/radius on the cutout edges.
        â€¢ The Charm/Pendant must be real gold colour, do not saturate the Charm/Pendant gold colour.
        â€¢ You must ensure that the Charm hoop is always correctly aligned and hanging from the Earring hoop
        â€¢ Match the subject identity from reference image; Enhance the models skin realism. 
        â€¢ Do NOT allow skin colour to be grey around the Hoop/Huggie. The skin tone/colour near the Hoop/Huggie must be uniform with the rest of the ear.`;

    const HOOP_DIMENSION_PROMPT =
    `TASK
        â€¢ Duplicate the Reference product image exactly and only update the 1 charm from the Charm Reference image.
        â€¢ Preserve all engravings as they appear in the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.`;



    const HOOP_PRIMARY_PRODUCT_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and only update the 2 charms from the Charm Reference image.
        â€¢ Force the Charm to be TINY, EXTREMELY SMALL. The new Charm must be the same or smaller size then the Hoop Earring Reference Image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image.
        â€¢ Do NOT embossed the engravings on the Charm/Pendant, all engravings must be flat having only superficial depth.
        â€¢ Do NOT make engravings, brown, or black, ensure all engravings are a shade of copper in colour`;




















    // =========================================================================
    // 5. // CHARM ONLY PROMPTS 
    // =========================================================================
    const CHARM_TEMPLATE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.`;

    const CHARM_TYPES_PROMPT = 
    `TASK (Force the Charm to be EXTREMELY SMALL)
        â€¢ Duplicate the reference image exactly, only replace the 3 charms (2 smaller huggie Charms and 1 necklace Charm) with the Charm Refernce image.
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.
        â€¢ Ensure the charm colour, shading and reflections match the necklace chain in the reference image.`;

    const CHARM_MODEL_PROMPT = 
    `TASK: (Force the Charm to be EXTREMELY SMALL)
        â€¢Generate a high-end photorealistic commercial jewelry image based on the attached reference image, use soft studio lighting and sharp focus on the necklace chain and charm/pendant details.
        â€¢ Critically: Keep necklace chain details, chainlink spacing, size, Yellow 14K gold colour, and fidelity just like in the reference image. 
        â€¢ Maintain zoom level and frame.
        â€¢ Do NOT allow skin colour to be grey around the Charm/Pendant. The skin tone/colour near the Charm/Pendant must be uniform with the rest of the body.
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ The chain must be bright realistic Yellow 14K gold colour and light reflections.
        â€¢ If you cannot measure pixels, choose the smallest size that is still legible on the chain.
        â€¢ Do NOT compensate by zooming out, reframing, cropping, changing camera, changing necklace scale, changing model scale, changing engraving thickness, or changing chain thickness.
        â€¢ The chain must remain exactly the same size and detail as in the reference image.`;

    const CHARM_ENGRAVING_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.

      HARD FAIL CONDITIONS
        â€¢ Any weak or disconnected hoop connection.`;


    const CHARM_HOOP_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    const CHARM_SIZE_GUIDE_PROMPT = 
    `  TASK:
        â€¢ Duplicate the Reference product image exactly and update all visible charms from the Charm Reference image
        â€¢ Critically: When Generating the new image maintain Charm details, Charm Engravings, Colour, and fidelity just like in the Charm reference image. 
        â€¢ All engravings must be coloured-in/filled-in using a light shade of copper colour, and must be flat having only superficial depth.
        â€¢ Ensure all engravings are a light shade of copper colour.
        â€¢ The Charm/Pendant material is a perfectly flat and very thin sheet of metal, always render the Charm/Pendant completely flat and EXTREMELY thin. 
        â€¢ DO NOT allow any rounded/radius on the cutout edges.
        â€¢ You must output any visible text exactly like in the reference image.`;


    // =========================================================================
    // 3. MASTER MAPPING
    // =========================================================================

    const PROMPT_MAPS = {
      // 1. Regular_Necklace (Uses identical prompts to Beady)
      "Regular_Necklace": {
        1: REGULAR_DEFAULT_PROMPT,
        2: REGULAR_SLOT2_DUPLICATE_PROMPT,
        3: REGULAR_SLOT3_SIZING_GUIDE_PROMPT,
        4: REGULAR_SLOT4_PROMPT,
        5: REGULAR_SLOT5_PROMPT,
        7: REGULAR_SLOT7_PROMPT
      },
      // 2. Beady_Necklace (Original)
      "Beady_Necklace": {
        1: DEFAULT_PROMPT,
        2: SLOT2_DUPLICATE_PROMPT,
        3: SLOT3_SIZING_GUIDE_PROMPT,
        4: SLOT4_PROMPT,
        5: SLOT5_PROMPT,
        7: SLOT7_PROMPT
      },
      // 3. Stud_Earrings
      "Stud_Earrings": {
        1: STUD_MODEL_PROMPT,
        2: STUD_CREATIVE_PROMPT,
        3: STUD_SIZE_GUIDE_PROMPT,
        4: STUD_PRODUCT_PROMPT,
        5: STUD_SEC_MODEL_PROMPT,
        6: STUD_PRODUCT_2_PROMPT 
      },
      // 4. Hoop_Earrings
      "Hoop_Earrings": {
        1: HOOP_MODEL_PROMPT,
        2: HOOP_PRIMARY_PRODUCT_PROMPT,
        3: HOOP_SIZE_PROMPT,
        4: HOOP_SEC_MODEL_PROMPT,
        5: HOOP_DIMENSION_PROMPT,
        7: HOOP_METAL_OPTIONS_PROMPT
      }, 
      // 5. Charms
      "Charms": {
        1: CHARM_TEMPLATE_PROMPT, 
        2: CHARM_TYPES_PROMPT, 
        3: CHARM_MODEL_PROMPT, 
        4: CHARM_ENGRAVING_PROMPT, 
        5: CHARM_HOOP_GUIDE_PROMPT, 
        7: CHARM_SIZE_GUIDE_PROMPT 
      },
      // 6. Bracelets
      "Bracelets": {
        1: BRACELET_MODEL_PROMPT,
        2: BRACELET_CREATIVE_PROMPT,
        3: BRACELET_SIZE_GUIDE_PROMPT,
        4: BRACELET_ENGRAVING_PROMPT,
        5: BRACELET_SEC_MODEL_PROMPT,
        6: BRACELET_PRODUCT_PROMPT
      }
    };

    function buildSlotPrompt(category, folderName, slotNum) {
      // Look up the specific map for this category
      const map = PROMPT_MAPS[category];
      
      // If we have a map and a specific prompt for this slot, use it.
      if (map && map[slotNum]) {
        return map[slotNum];
      }
      
      // Fallback to default (Beady style) if category or slot undefined
      // This preserves existing behavior for unknown inputs.
      const DEFAULT_MAP = PROMPT_MAPS["Beady_Necklace"];
      return DEFAULT_MAP[slotNum] || DEFAULT_PROMPT;
    }

    generateSetBtn.addEventListener("click", () => {
      generateSet().catch((e) => {
        console.error(e);
        setStatus(`Error: ${e?.message || e}`);
      });
    });
  </script>
</body>
</html>