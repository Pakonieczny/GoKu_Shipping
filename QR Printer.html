<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Auto-Print QR Code for Multiple Listings</title>

  <!-- pdfmake (and its fonts) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/pdfmake.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfmake@0.2.7/build/vfs_fonts.js"></script>

  <!-- qrcode.js (for generating QR) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

  <!-- No fallback UI, no headings, no user text input -->
  <style>
    /* Body reset to remove margin/padding */
    html, body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
<script>
/********************************************************
 * On page load:
 * 1) Read "qrPrintAll" from localStorage, which is an object:
 *      {
 *        dispatchDate: string like "25 Sep 2025" or "N/A",
 *        items: [ array of transactions for this order ],
 *        userTypedOrderNum: string (the typed Etsy order # from sorting.html),
 *        notesBlock?: { metal?, title4?, matrixNums?, matrixTitle?, matrixImageTitle?, ... }
 *      }
 * 2) Build a 1×1 PDF label with:
 *     - QR of order number
 *     - 0–2 dots (group A/B)
 *     - date, order number
 *     - 3-line notes (Metal / Title / Match) **aggregated across ALL items**
 ********************************************************/
window.addEventListener("load", async () => {
  try {
    // 1) Load from localStorage
    const dataStr = localStorage.getItem("qrPrintAll");
    if (!dataStr) {
      console.error("No 'qrPrintAll' found in localStorage. Nothing to print.");
      return;
    }

    // Must be an object { dispatchDate, items[], userTypedOrderNum? }
    const dataObj = JSON.parse(dataStr);
    if (!dataObj || !Array.isArray(dataObj.items) || !dataObj.items.length) {
      console.error("'qrPrintAll' missing items or is empty.");
      return;
    }

    // The date to show in bold
    const dispatchDate = dataObj.dispatchDate || "N/A";

    // The array of transactions
    const items = dataObj.items;
    console.log("Loaded 'qrPrintAll' =>", dataObj);
    console.log("Dispatch date =>", dispatchDate);
    items.forEach((it, idx) => {
      console.log(
        `Item #${idx} => receipt_id=${it.receipt_id}, title=${it.title}, keywords=${JSON.stringify(it.keywords)}`
      );
    });

    // 2) Order number for QR
    const orderNum = dataObj.userTypedOrderNum
                  || items[0].receipt_id
                  || "UnknownOrder";

    // 3) Dot count (A/B)
    const dotCount = getCumulativeDotCount(items);

    // 4) Notes block (STRICT: never include variations)
    const notes = buildAggregatedNotes(dataObj, items);

    // 5) Build & print the PDF label (with notes)
    await buildAndPrintLabel(orderNum, dotCount, dispatchDate, notes);

  } catch (err) {
    console.error("Error in QR Printer auto-run:", err);
  }
});

/* =================== Aggregation Helpers =================== */

/** First N words from a string (normalized whitespace). */
function firstNWords(str, n = 2) {
  return String(str || "")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .slice(0, n)
    .join(" ");
}

/** Unique-preserving join. */
function uniqJoin(arr, sep = ", ") {
  const out = [];
  const seen = new Set();
  for (const v of arr) {
    const k = String(v || "").trim();
    if (!k) continue;
    if (!seen.has(k)) { seen.add(k); out.push(k); }
  }
  return out.join(sep);
}

/** Normalize a loose numbers string into "n, n, n" (unique, in-order). */
function normalizeMatrixNums(s) {
  const nums = [...String(s||"").matchAll(/\d+/g)].map(m => m[0]);
  if (!nums.length) return "";
  const seen = new Set();
  const out = [];
  for (const n of nums) { if (!seen.has(n)) { seen.add(n); out.push(n); } }
  return out.join(", ");
}

/** Extract "n, n, n" from a title-like string (e.g., "Silver_22_Ear" → "22"). */
function extractNumsFromTitle(str) {
  return normalizeMatrixNums(str);
}

/** Try to sniff metal from plain text (order: RoseGold → Silver → Gold). */
function sniffMetalFromText(txt) {
  const t = String(txt || "").toLowerCase();
  if (/(rose[\s-]?gold|rosegold)/.test(t)) return "RoseGold";
  if (/\bsilver\b/.test(t)) return "Silver";
  if (/\bgold\b/.test(t)) return "Gold";
  return "";
}

/**
 * Build aggregated lines across ALL items in the order.
 * Uses values passed via notesBlock if available; otherwise derives them.
 */
function buildAggregatedNotes(dataObj, items) {
  const nb = dataObj?.notesBlock || {};

  // --- METAL (prefer passed-in aggregated, else derive from all items)
  let metalAgg = String(nb.metal || "").trim();
  if (!metalAgg) {
    const metals = [];
    for (const it of items) {
      const sniffed = sniffMetalFromText(it.title || "");
      if (sniffed) metals.push(sniffed);
      // Also look into keywords as a weak signal
      if (Array.isArray(it.keywords)) {
        const joined = (it.keywords || []).join(" ");
        const sniffK = sniffMetalFromText(joined);
        if (sniffK) metals.push(sniffK);
      }
    }
    metalAgg = uniqJoin(metals);
  }

  // --- TITLE (prefer passed-in aggregated title4, else 2 words per item)
  let titleAgg = String(nb.title4 || "").trim();
  if (!titleAgg) {
    const titles = items.map(it => firstNWords(it.title, 2)).filter(Boolean);
    titleAgg = titles.join(", ");
  }

  // --- MATCH NUMBERS (prefer passed-in; else aggregate across candidates)
  let matchAgg = normalizeMatrixNums(String(nb.matrixNums || "").trim());
  if (!matchAgg) {
    matchAgg = deriveAllMatrixNums(dataObj, items, nb);
  }

  // Also hand through any matrixTitle passed (not required for print)
  const matrixTitle = String(nb.matrixTitle || nb.matrixImageTitle || "").trim();

  return {
    metal: metalAgg,
    title4: titleAgg,
    matrixNums: matchAgg,
    matrixTitle
  };
}

/**
 * Aggregate ALL matrix numbers from any reasonable candidate:
 * - notesBlock.matrixTitle, matrixImageTitle, etc.
 * - per-item matrix* fields (if present)
 * - items' titles and keywords as last-resort
 */
function deriveAllMatrixNums(dataObj, items, nb) {
  const candidates = [];
  const pushIf = (v) => { if (typeof v === "string" && v.trim()) candidates.push(v); };

  // Highest priority: explicit matrix-title fields on the notes block
  const keys1 = ["matrixTitle","matrixImageTitle","matrix","matrix_title","matrix_name","matrixImage","matrixFile","matrixFileName","titleFull"];
  for (const k of keys1) pushIf(nb?.[k]);

  // Per-item matrix titles / names if attached to items
  const keys2 = ["matrixTitle","matrixImageTitle","matchedMatrixTitle","matrix","matrix_title","matrix_name"];
  if (Array.isArray(items)) {
    for (const it of items) {
      for (const k of keys2) pushIf(it?.[k]);
    }
  }

  // Last-resort fallbacks (titles / keywords may embed numbers)
  if (Array.isArray(items)) {
    for (const it of items) {
      pushIf(it?.title);
      if (Array.isArray(it?.keywords) && it.keywords.length) pushIf(it.keywords.join(" "));
    }
  }

  // Accumulate unique numbers in encounter order
  const seen = new Set();
  const out = [];
  for (const s of candidates) {
    const nums = [...String(s).matchAll(/\d+/g)].map(m => m[0]);
    for (const n of nums) {
      if (!seen.has(n)) { seen.add(n); out.push(n); }
    }
  }
  return out.join(", ");
}

/* --------- Phrase matcher used for dot-count classification --------- */
function containsPhrase(str = "", phrase = "") {
  const pattern = "\\b" + phrase
    .trim()
    .replace(/\s+/g, "[\\s\\W]+")
    + "\\b";
  return new RegExp(pattern, "i").test(str.toLowerCase());
}

/********************************************************
 * getCumulativeDotCount(listings)
 ********************************************************/
function getCumulativeDotCount(listings) {
  const groupA = ["stud","studs","stud earrings","ring","rings","earrings"];      // 2 dots
  const groupB = ["necklace","necklaces","huggie","huggies","huggie earrings",
    "hoop","hoops","hoop earrings","bracelet","bracelets",
    "extender","extenders","chain","chains"];                          // 1 dot

  let hitsA = 0;
  let hitsB = 0;

  listings.forEach((listing, idx) => {
    const kwArr = Array.isArray(listing.keywords) ? listing.keywords.map(k=>k.toLowerCase()) : [];
    const src   = kwArr.length ? kwArr.join(" ") : (listing.title || "");

    const matchesA = groupA.filter(p => containsPhrase(src, p));
    const matchesB = groupB.filter(p => containsPhrase(src, p));

    hitsA += matchesA.length;
    hitsB += matchesB.length;

    console.log(`#${idx} «${listing.title}»
        A-hits: [${matchesA.join(", ")}]   B-hits: [${matchesB.join(", ")}]`);
  });

  if (hitsA === 0 && hitsB === 0) return 1;   // default B
  if (hitsA >= hitsB) return 2;               // ties → A
  return 1;
}

/********************************************************
 * buildAndPrintLabel(orderNum, dotCount, dispatchDate):
 ********************************************************/
async function buildAndPrintLabel(orderNum, dotCount, dispatchDate, notes) {
  // 1) Generate a large QR code (512×512) for high-res
  const hiddenQRContainer = document.createElement("div");
  hiddenQRContainer.style.display = "none";
  document.body.appendChild(hiddenQRContainer);

  await makeLargeQRCode(orderNum, hiddenQRContainer);

  let qrImg = hiddenQRContainer.querySelector("img");
  if (!qrImg) {
    const qrCanvas = hiddenQRContainer.querySelector("canvas");
    if (qrCanvas) {
      qrImg = convertCanvasToImg(qrCanvas);
    }
  }
  if (!qrImg) {
    console.error("No QR image rendered for order:", orderNum);
    return;
  }

  const dataUrl = qrImg.src;
  const docDefinition = buildPDFDocWithDots(
    dataUrl,
    dotCount,
    dispatchDate,
    orderNum,
    notes
  );

  const pdfDocGenerator = pdfMake.createPdf(docDefinition);
  pdfDocGenerator.getBlob((blob) => {
    const blobUrl = URL.createObjectURL(blob);

    const hiddenIframe = document.createElement("iframe");
    hiddenIframe.style.position = "fixed";
    hiddenIframe.style.visibility = "hidden";
    hiddenIframe.style.right = "10000px";
    hiddenIframe.style.width = "1px";
    hiddenIframe.style.height = "1px";
    document.body.appendChild(hiddenIframe);

    hiddenIframe.onload = function() {
      hiddenIframe.contentWindow.print();
    };

    hiddenIframe.src = blobUrl;
  });
}

/********************************************************
 * buildPDFDocWithDots(dataUrl, dotCount, dispatchDate):
 ********************************************************/
function buildPDFDocWithDots(dataUrl, dotCount, dispatchDate, orderNum, notes) {
  // Dot = 6px diameter => radius=3, spaced 12px
  const dotEllipses = [];
  if (dotCount > 0) {
    const spacing = 4.44;
    for (let i = 0; i < dotCount; i++) {
      dotEllipses.push({
        type: 'ellipse',
        x: i * spacing,
        y: 0,
        r1: 1.65,
        r2: 1.65,
        color: 'black',
        fillOpacity: 1
      });
    }
  }

  // Normalize fields for consistent printing (already aggregated)
  const normMetal  = String(notes?.metal ?? "").replace(/^\s*Metal:\s*/i, "").trim();
  const normTitle4 = String(notes?.title4 ?? "").trim();
  const normMatch  = String(notes?.matrixNums ?? "").trim();

  return {
    pageSize: { width: 72, height: 72 }, // 1×1 label in points
    pageMargins: [0, 0, 0, 0],
    content: [
      { absolutePosition: { x:4, y:2.75 }, canvas: dotEllipses },
      { image: dataUrl, width: 28.9, absolutePosition:{ x:2, y:6 } },              // QR −15%
      { text: dispatchDate || "N/A", fontSize: 4.7, bold: true, absolutePosition:{ x:2, y:39 } }, // Ship Date −15%
      { text: orderNum || "Unknown", fontSize: 4.7, bold: true, absolutePosition: { x:2, y:46 } }, // Order # −15%
      {
        text: [
          "Metal: " + normMetal,
          "Title: " + normTitle4,
          "Match: " + normMatch
        ].join("\n"),
        fontSize: 3.33,
        bold: false,
        lineHeight: 1.0,
        absolutePosition: { x:33, y:0.5 }
      }
    ]
  };
}

/********************************************************
 * makeLargeQRCode(text, container)
 ********************************************************/
async function makeLargeQRCode(text, container) {
  return new Promise(resolve => {
    new QRCode(container, {
      text: text,
      width: 512,
      height: 512,
      correctLevel: QRCode.CorrectLevel.H
    });
    setTimeout(resolve, 600); // let qrcode.js finish drawing
  });
}

/********************************************************
 * convertCanvasToImg(canvas)
 ********************************************************/
function convertCanvasToImg(canvas) {
  const dataUrl = canvas.toDataURL("image/png");
  const imgEl = document.createElement("img");
  imgEl.src = dataUrl;
  return imgEl;
}
</script>
</body>
</html>