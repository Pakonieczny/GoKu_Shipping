<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Sorting - Single-Click Zoom</title>
  <!-- Materialize CSS -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
  />
  <style>
    body {
      background-color: #fff;
      margin: 0;
      height: 100vh;
      position: relative;
      opacity: 0;
      transition: opacity 0s;
    }
    /* Main Buttons */
    #connectEtsyBtn,
    #testOpenAIBtn,
    #openConfigBtn,
    #cropImagesBtn,
    #sendMatchBtn {
      position: absolute;
      left: 20px;
      width: 140px;
      height: 36px;
    }
    #connectEtsyBtn {
      top: 20px;
    }
    #testOpenAIBtn {
      top: 70px;
    }
    #openConfigBtn {
      top: 120px;
    }
    #cropImagesBtn {
      top: 170px;
    }
    #sendMatchBtn {
      top: 220px;
    }

    /* Etsy Order Number input */
    #etsyOrderNumber {
      position: absolute;
      left: 20px;
      top: 270px;
      width: 300px;
      height: 30px;
      border: 1px solid #999;
      padding: 4px;
      outline: none;
      font-size: 0.9em;
    }

    /* Image Comparison UI */
    #imageComparisonContainer {
      position: absolute;
      left: 20px;
      top: 310px;
    }
    #photoDragDrop {
      width: 100px;
      height: 100px;
      border: 2px dashed #ccc;
      text-align: center;
      line-height: 100px;
      display: inline-block;
      margin-right: 10px;

      }

      /* Make only the Unmatched area scroll inside matchesModal */
      /* 1) STOP the parent modal from scrolling (Materialize sets overflow on .modal) */
      #matchesModal.modal {
        overflow-y: hidden !important;   /* <- key line: kill modal-level scroll */
        max-height: none !important;     /* remove the 70% cap that forces scrollbars */
        height: auto !important;
      }
      /* 2) Let the modal content itself be free of its own scrollbar */
      #matchesModal .modal-content {
        overflow-y: visible;             /* children manage their own scroll */
      }

      #matchesModal #unmatchedWrapper .unmatched-scroller {
        max-height: 260px;             /* tweak to taste */
        overflow-y: auto;              /* own scrollbar */
        padding-right: 6px;            /* room for scrollbar, avoids jitter */
      }
      /* Raise the entire “Unmatched User Photos” section by 30px */
      #matchesModal #unmatchedWrapper {
        margin-top: -30px;
      }

      /* highlight on drag-hover */
      #photoDragDrop.drag-hover {
        border: 2px dashed #2196F3 !important;   /* blue dashed outline */
      }
    
    #userImage {
      width: 100px;
      height: 100px;
      border: 1px solid #000;
      display: none;
      vertical-align: top;
    }

    /* Container for dynamically generated preview boxes and detail boxes */
    #photoGridContainer {
      position: relative;
      width: 1200px;
      max-height: 700px;
      overflow-y: auto;
      border-left: 1px dashed #ccc;
      border-right: 1px dashed #ccc;
      left: 350px;
      top: 20px;
    }
    /* Preview box styling (110x110) */
    .preview-box {
      position: absolute;
      width: 110px;
      height: 110px;
      border: 1px solid #000;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      user-select: none;
      font-size: 0.7em;
      text-align: center;
    }
    .preview-box img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform-origin: center center;
      transition: transform 0.3s ease;
    }
    /* Detail text boxes: 55px x 7px */
    .detail-box {
      position: absolute;
      width: 55px;
      height: 7px;
      font-size: 0.6em !important;
      border: none !important;
      outline: none !important;
      -webkit-appearance: none !important;
      -moz-appearance: none !important;
      appearance: none !important;
      background: #f0f0f0;
      color: #333;
      padding: 0;
      margin: 0;
      box-shadow: none !important;
    }

    #matrixProgressWrap .progress { margin:0 !important; }

    #unmatchedContainer {
      position: absolute;
      left: 20px;
      top: 420px; /* ~100px below #photoDragDrop which starts at top:310px */
      width: 600px;
    }

    /* pointer-events enabled on read-only inputs */
    .detail-box:read-only {
      pointer-events: auto !important;
      cursor: pointer !important;
    }

    /* Config Modal */
    #configModal.modal {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 250px !important;
      height: 450px !important;
      max-height: none !important;
      overflow-y: auto !important;
    }
    #configTable thead tr th {
      font-size: 0.9em;
    }
    #configTable tbody tr td {
      font-size: 0.8em;
    }
    #configTable .left-input,
    #configTable .top-input,
    #configTable .width-input,
    #configTable .height-input {
      width: 80px !important;
    }
    .modal {
      opacity: 0 !important;
      transform: translateY(20px) scale(0.95) !important;
      will-change: opacity, transform;
      transition: opacity 300ms ease, transform 300ms ease;
    }
    .modal.open {
      opacity: 1 !important;
      transform: translateY(0) scale(1) !important;
    }
    .modal-overlay {
      opacity: 0;
      will-change: opacity;
      transition: opacity 300ms ease;
    }
    .modal-overlay.show {
      opacity: 1;

     /* Hide the Cancel button in matchesModal */
     #matchesModal .modal-footer .modal-close{display:none !important;}

    }

    /* === custom button colour (outline blue) ================= */
    :root { --outlineBlue:#2196F3; }      /* material-blue-500 */

    #matchPrintBtn,
    #mpBackBtn,
    #mpNextBtn {
      background-color:var(--outlineBlue) !important;
      color:#fff !important;
    }

   /* ===== Pre-Filter Monitor (temporary debug UI) ===== */
    #prefilterPanel {
      position:absolute;
      left:1460px; top:70px; width:360px; height:650px;
      border:1px solid #ccc; background:#fff; overflow:auto; padding:8px;
      box-shadow:0 2px 6px rgba(0,0,0,.08); border-radius:8px;
      font-size:.85em;
    }
    #prefilterPanel h6 { margin:4px 0 8px 0; font-weight:600; }
    .pf-cell { margin-bottom:10px; border:1px solid #e5e5e5; border-radius:6px; }
    .pf-head { background:#f7f7f7; padding:6px 8px; border-bottom:1px solid #eee; }
    .pf-head small { color:#777; }
    .pf-list { list-style:none; padding:6px 8px; margin:0; }
    .pf-list li { margin:0 0 4px 0; }
    .pf-hit { font-weight:600; }
    .pf-sent { font-size:.8em; color:#666; padding:0 8px 6px; }
    /* tiny pill for the 2-word descriptor */
    .pf-tag {
      display:inline-block; padding:2px 6px; border:1px solid #ddd;
      border-radius:999px; font-size:.75em; margin-left:6px; background:#f9f9f9;
    }

  </style>
</head>
<body>
  <!-- Main Buttons -->
  <button id="connectEtsyBtn" class="btn waves-effect waves-light">Connect to Etsy</button>
  <!-- Live Search: Etsy Order Item Titles -->
  <input id="orderSearchBox" class="browser-default" type="text" autocomplete="off"
         placeholder="Search orders…">
  <button id="filterIncompleteBtn" class="btn waves-effect waves-light">Filter</button>
  <button id="openConfigBtn" class="btn waves-effect waves-light">Open Config</button>
  <button id="mpBackBtn" class="btn waves-effect waves-light">Back</button>
  <button id="mpNextBtn" class="btn waves-effect waves-light">Next</button>
  <button id="sendMatchBtn" class="btn waves-effect waves-light">Send & Match</button>
  <button id="matchPrintBtn" class="btn waves-effect waves-light" style="top: 270px;" 
  onclick="initMatchAndPrintFlow()">Match & Print</button>

  <!-- ===== NEW TITLE ELEMENTS (BEGIN) ===== -->
<div id="titleEtsyOrderNumber"
     style="position:absolute; left:20px; top:245px; font-size:0.9em;">
  Etsy Order Number
</div>

<div id="titleImageMatrixDrop"
     style="position:absolute; left:20px; top:295px; font-size:0.9em;">
  Image Matrix Drop
</div>

<div id="titleUnmatchedImages"
     style="position:absolute; left:20px; top:400px; font-size:0.9em;">
  Unmatched Images
</div>
<!-- ===== NEW TITLE ELEMENTS (END) ===== -->

  <!-- Etsy Order Number input -->
  <input
    type="text"
    id="etsyOrderNumber"
    placeholder="Comma-delimited Etsy Order Numbers"
  />

  <!-- Image Comparison UI -->
  <div id="imageComparisonContainer">
    <div id="photoDragDrop">Drag & Drop</div>
    <!-- Inline progress: sits directly below the Drag & Drop box -->
    <div id="matrixProgressWrap" style="display:none; margin-top:8px;">
      <div id="matrixProgressTitle" style="font-size:1.06em; font-weight:bold; margin-bottom:4px;">Analyzing…</div>
      <div id="matrixProgressRow" style="display:flex; align-items:center; gap:6px;">
        <div class="progress" style="height:14px; width:219px; margin:0;">
          <div id="matrixProgressBar" class="determinate" style="width:0%"></div>
        </div>
        <div id="matrixProgressPct" style="font-size:1.06em; font-weight:bold; min-width:32px; line-height:1;">0%</div>
      </div>
    </div>
    <div id="unmatchedContainer"></div>
  </div>

  <!-- Container for dynamically generated preview boxes and detail boxes -->
  <div id="photoGridContainer">
    <!-- Preview boxes and detail boxes will be created dynamically -->
  </div>

 <!-- ===== TEMP: Pre-Filter Monitor (real-time) ===== -->
  <div id="prefilterPanel" aria-live="polite">
    <h6>Pre-Filter Monitor</h6>
    <div id="pfInner"></div>
  </div>

  <!-- Config Modal -->
  <div id="configModal" class="modal">
    <div class="modal-content">
      <table class="striped" id="configTable">
        <thead>
          <tr>
            <th>Element</th>
            <th>Left (px)</th>
            <th>Top (px)</th>
            <th>Width (px)</th>
            <th>Height</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="modal-footer">
      <a
        href="#!"
        id="saveConfigBtn"
        class="modal-close waves-effect waves-green btn"
      >
        Save Config
      </a>
    </div>
  </div>

  <!-- Matches Modal -->
  <div id="matchesModal" class="modal">
    <div class="modal-content">
    <h5 style="position:relative; top:-12px; padding-bottom:5px;">Successful Image Matches</h5>

      <!-- ► New title 5 px below “Successful Image Matches” and 4 px above the box ◄ -->
      <div id="customerNotesTitle"
           style="font-weight:bold; font-size:0.7em; margin-top:0px; margin-bottom:4px;">
        Customer Notes
      </div>

      <!-- Customer Notes input -->
      <input id="customerNotes"
             type="text"
             readonly
             placeholder="Customer Notes"
             style="display:block; margin-top:0; width:500px; height:35px; margin-bottom:10px;" />
      <div
        id="matchesGridContainer"
        style="display: flex; flex-wrap: wrap; gap: 10px;"
      ></div>
    </div>
 <div class="modal-footer">
   <input id="matrixSearchBox"
          class="browser-default"
          type="text"
          placeholder="Matrix Image Search"
          style="width:260px; margin-right:10px;" />
   <!-- “Save” button that will perform the array updates and then close the modal -->
   <a href="#!" id="saveMatchesBtn" class="waves-effect waves-green btn">Save</a>
      <!-- “Cancel” button that closes the modal without saving changes -->
      <a href="#!" class="modal-close waves-effect waves-red btn">Cancel</a>
    </div>
  </div>

    <!-- 1) Firebase (compat mode) – must be above your main sorting code -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- jQuery & Materialize JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"
  ></script>

  <!-- Everything is in this single <script> block -->
  <script>
/********************************************************
 * Base URL & Global Variables
 ********************************************************/

// === Image fetch caches + tiny queue (match design.html expectations) ===
window.__imagesCache  = window.__imagesCache  || new Map();   // listingId -> [images]
window.__imagesFlight = window.__imagesFlight || new Map();   // listingId -> in-flight Promise

// Simple concurrency limiter so we don't hammer functions; tune as needed
const IMAGE_QUEUE_CONCURRENCY = 3;
window.__imageQueue  = window.__imageQueue  || [];
window.__imageActive = window.__imageActive || 0;

function runImageTask(taskFn) {
  return new Promise((resolve, reject) => {
    __imageQueue.push({ taskFn, resolve, reject });
    pumpImageQueue();
  });
}

function pumpImageQueue() {
  while (__imageActive < IMAGE_QUEUE_CONCURRENCY && __imageQueue.length) {
    const { taskFn, resolve, reject } = __imageQueue.shift();
    __imageActive++;
    (async () => {
      try {
        const out = await taskFn();
        resolve(out);
      } catch (e) {
        reject(e);
      } finally {
        __imageActive--;
        pumpImageQueue();
      }
    })();
  }
}

// Shared proxy loader → returns data:URL; define once if missing
window.getLocalImageData = window.getLocalImageData || (async function(imageUrl){
  const resp = await fetch(
    functionsBaseUrl + "/imageProxy?url=" + encodeURIComponent(imageUrl)
  );
  if (!resp.ok) throw new Error("imageProxy HTTP " + resp.status);
  const blob = await resp.blob();
  return await new Promise((resolve, reject) => {
    const r = new FileReader();
    r.onload = () => resolve(r.result);
    r.onerror = reject;
    r.readAsDataURL(blob);
  });
});

const functionsBaseUrl = window.location.origin + "/.netlify/functions";

/* ===== Etsy OAuth boot + auto-refresh wiring (match design.html) ===== */
const TOKEN_KEYS = {
  access  : "access_token",
  refresh : "refresh_token",
  expires : "token_expires_at"   // epoch seconds
};

let __refreshPromise = null;       // single-flight guard

function scheduleTokenRefresh(){
  clearTimeout(window.__etsyRefreshTimer);
  const exp = Number(localStorage.getItem(TOKEN_KEYS.expires) || 0);
  if (!exp){
    if (localStorage.getItem(TOKEN_KEYS.refresh)){
      window.__etsyRefreshTimer = setTimeout(refreshAccessToken, 55 * 60 * 1000);
    }
    return;
  }
  const now = Math.floor(Date.now()/1000);
  const leadSec = 120;
  const delayMs = Math.max(5000, (exp - now - leadSec) * 1000);
  window.__etsyRefreshTimer = setTimeout(refreshAccessToken, delayMs);
}

function setTokens({ access_token, refresh_token, expires_in, issued_at }){
  if (access_token)  localStorage.setItem(TOKEN_KEYS.access,  access_token);
  if (refresh_token) localStorage.setItem(TOKEN_KEYS.refresh, refresh_token);
  const now = Math.floor(Date.now()/1000);
  const iat = Number(issued_at || now);
  const exp = iat + Number(expires_in || 3600);
  localStorage.setItem(TOKEN_KEYS.expires, String(exp));
  scheduleTokenRefresh();
}

async function refreshAccessToken(){
  if (__refreshPromise) return __refreshPromise;
  const rt = localStorage.getItem(TOKEN_KEYS.refresh);
  if (!rt) return;
  __refreshPromise = (async () => {
    try{
      const resp = await fetch(`${functionsBaseUrl}/refreshEtsyToken`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ refresh_token: rt })
      });
      if (!resp.ok) throw new Error("HTTP " + resp.status);
      const data = await resp.json();
      setTokens({
        access_token : data.access_token,
        refresh_token: data.refresh_token || rt,
        expires_in   : data.expires_in,
        issued_at    : data.issued_at || Math.floor(Date.now()/1000)
      });
      M.toast?.({ html: "Etsy token refreshed" });
      return true;
    }catch(err){
      console.warn("Token refresh failed:", err);
      localStorage.removeItem(TOKEN_KEYS.access);
      localStorage.removeItem(TOKEN_KEYS.expires);
      await startOAuth("refresh-failed");
      throw err;
    }finally{
      __refreshPromise = null;
    }
  })();
  return __refreshPromise;
}

async function ensureFreshToken(){
  const exp = Number(localStorage.getItem(TOKEN_KEYS.expires) || 0);
  if (!exp) return;
  const now = Math.floor(Date.now()/1000);
  if (exp - now <= 120) await refreshAccessToken();
}

/* Resilient Etsy fetch (proactive refresh + single 401 retry, else headless OAuth) */
async function apiFetch(path, init = {}){
  await ensureFreshToken();
  let token = localStorage.getItem(TOKEN_KEYS.access) || "";
  let resp  = await fetch(`${functionsBaseUrl}${path}`, {
    ...init,
    headers: { ...(init.headers || {}), "access-token": token }
  });
  if (resp.status === 401){
    try{
      await refreshAccessToken();
      token = localStorage.getItem(TOKEN_KEYS.access) || "";
      resp  = await fetch(`${functionsBaseUrl}${path}`, {
        ...init,
        headers: { ...(init.headers || {}), "access-token": token }
      });
    }catch(_){}
    if (resp.status === 401){
      try { localStorage.removeItem(TOKEN_KEYS.access); } catch(_){}
      startOAuth("api-401");
      throw new Error("Unauthorized – reconnecting Etsy…");
    }
  }
  return resp;
}

let croppedImagesArray = [];
let userImagesArray = [];
let cellMatches = {};
let partialMatches = {};
let matchPrintFlowInProgress = false;
let pendingFetchControllers = [];
let globalRunId = 0;
let currentSaveHandler = null;      // tracks active “Save” listener
// Live grid filter: when true, only show items with missing/no matches
window.filterIncompleteOnly = false;
function parkSaveBtn() {
  const btn    = document.getElementById("saveMatchesBtn");
  const footer = document.querySelector("#matchesModal .modal-footer");
  if (btn && footer && !footer.contains(btn)) {
    footer.appendChild(btn);
    btn.style.display  = "";
    btn.style.position = "static";
    btn.style.margin   = "0";
  }
}
let skipMatches = {};   // { cellIndex: true }  
let earringCells  = {};            // { cellIdx : true }
let earringState  = {};            // { cellIdx : { firstImg:null } }

/* ===== ADAPTIVE COOLDOWN CONFIG (ADD) =========================== */
let lastRateLimitAt = 0;     // timestamp of most recent 429 / rate-limit
let burstCalls      = 0;     // running count of OpenAI compare calls this page load

const COOL_HEALTHY_MS        = 120;   // floor when no recent rate-limit
const COOL_RATE_LIMIT_MS     = 800;   // base when inside 15s RL window
const COOL_PER_CANDIDATE_MS  = 5;     // add per candidate in the just-finished cell
const COOL_JITTER_MAX_MS     = 200;   // random 0..200 jitter
const COOL_PERIODIC_PAUSE_MS = 400;   // extra pause every Nth burst (below)

function noteRateLimit() {
  lastRateLimitAt = Date.now();
}

async function adaptiveCooldown(loadFactor = 1) {
  burstCalls++;
  const inRLWindow = (Date.now() - lastRateLimitAt) < 15000; // 15s grace
  let wait = inRLWindow ? COOL_RATE_LIMIT_MS : COOL_HEALTHY_MS;
  wait += loadFactor * COOL_PER_CANDIDATE_MS;
  if (burstCalls % 50 === 0) {
    wait += COOL_PERIODIC_PAUSE_MS;   // tiny breather every 50 calls
  }
  wait += Math.floor(Math.random() * COOL_JITTER_MAX_MS); // jitter
  await new Promise(r => setTimeout(r, wait));
}
/* ===== END ADAPTIVE COOLDOWN CONFIG ============================= */

/********************************************************
 * flipImageHorizontal(dataURL) → returns mirrored dataURL
 ********************************************************/
function flipImageHorizontal(dataURL) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = function () {
      const canvas = document.createElement("canvas");
      canvas.width  = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      ctx.translate(canvas.width, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0);
      resolve(canvas.toDataURL());
    };
    img.onerror = reject;
    img.src = dataURL;
  });
}

 /********************************************************
  * Inline progress bar (no modal) — renders under #photoDragDrop
  * NOTE: we keep the SAME function names used elsewhere so callers
  * don’t need to change (showProgressModal / updateProgressModal / closeProgressModal).
  ********************************************************/
 function ensureProgressInline() {
   // Ensure wrapper exists right after the Drag & Drop node.
   let wrap = document.getElementById("matrixProgressWrap");
   if (!wrap) {
     const ref = document.getElementById("photoDragDrop");
     if (!ref) return null;
     wrap = document.createElement("div");
     wrap.id = "matrixProgressWrap";
     wrap.style.display = "none";
     wrap.style.marginTop = "8px";
     wrap.innerHTML = `
     <div id="matrixProgressTitle" style="font-size:1.06em; font-weight:bold; margin-bottom:4px;">Analyzing…</div>
      <div id="matrixProgressRow" style="display:flex; align-items:center; gap:6px;">
        <div class="progress" style="height:14px; width:219px; margin:0;">
          <div id="matrixProgressBar" class="determinate" style="width:0%"></div>
        </div>
        <div id="matrixProgressPct" style="font-size:1.06em; font-weight:bold; min-width:32px; line-height:1;">0%</div>
      </div>
    `;
     ref.insertAdjacentElement("afterend", wrap);
   }
   return wrap;
 }

 // Compatibility: same name, now drives the inline bar
 function showProgressModal(title, totalCount) {
   const wrap = ensureProgressInline();
   if (!wrap) return;
   const t = document.getElementById("matrixProgressTitle");
   if (t) t.textContent = title || "Working…";
   updateProgressModal(0, totalCount);
   wrap.style.display = "block";
 }

 // Compatibility: same name, updates inline bar
 function updateProgressModal(doneCount, totalCount) {
   const pct = totalCount ? Math.round((doneCount / totalCount) * 100) : 0;
   const bar = document.getElementById("matrixProgressBar");
   const txt = document.getElementById("matrixProgressPct");
   if (bar) bar.style.width = pct + "%";
   if (txt) txt.textContent = pct + "%";
 }

 // Compatibility: same name, hides inline bar
 function closeProgressModal() {
   const wrap = ensureProgressInline();
   if (wrap) wrap.style.display = "none";
 }

/* =========================================================
 * Pre-Filter Monitor helpers
 * =======================================================*/
function pfReset(title="Pre-Filter Monitor"){
  const wrap = document.getElementById("prefilterPanel");
  if (!wrap) return;
  const inner = document.getElementById("pfInner");
  if (inner) inner.innerHTML = "";
  wrap.querySelector("h6").textContent = title;
}
function pfStartCell(i, etsyTitle){
  const inner = document.getElementById("pfInner"); if (!inner) return;
  const box = document.createElement("div");
  box.className = "pf-cell";
  box.id = "pf-cell-" + i;
  const parsed = String(etsyTitle || "");
  const origArr = Array.isArray(window.cachedOrderItems) ? window.cachedOrderItems : [];
  const orig = escapeHtml(String(origArr[i]?.title || ""));
  box.innerHTML = `
    <div class="pf-head">
      <div><b>Cell ${i}</b></div>
      <small>Title (orig): ${orig.slice(0,120)}</small><br/>
      <small>Title (parsed): ${escapeHtml(parsed)}</small>
    </div>
    <ul class="pf-list" id="pf-list-${i}"></ul>
    <div class="pf-sent" id="pf-sent-${i}"></div>
  `;
  inner.appendChild(box);
}
function pfAddCandidate(i, userName, desc2, hitWord){
  const list = document.getElementById("pf-list-" + i); if (!list) return;
  const li = document.createElement("li");
  const d2  = normalizeTwoWordDescriptor(desc2 || "");
  const hit = hitWord ? ` <span class="pf-hit">[${hitWord}]</span>` : "";
  li.innerHTML = `<span class="pf-name">${escapeHtml(userName)}</span> <span class="pf-tag" title="Charm descriptor">${escapeHtml(d2)}</span>${hit}`;
  list.appendChild(li);
}
function pfMarkSent(i, count){
  const sent = document.getElementById("pf-sent-" + i); if (!sent) return;
  sent.textContent = `→ sending ${count} candidate${count===1?"":"s"} to OpenAI…`;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/**
 * normalizeTitleForPrefilter(title)
 * - lowercase
 * - remove ALL punctuation (keep only a–z, 0–9 and spaces)
 * - collapse whitespace
 * - use the FULL Etsy item title (no word limit)
 */
function normalizeTitleForPrefilter(title){
  return String(title || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/gi, " ")   // strip ALL punctuation
    .replace(/\s+/g, " ")            // collapse runs of whitespace
    .trim();
}

// Build the word list we will use for title prefiltering.
// Prefer the persisted 6-word descriptor (with potential 'ocean' augmentation),
// and fall back to the 2-word tag if 6-word is missing.
function descriptorWordsFor(baseName){
  const banned = new Set([
    "charm","jewelry","jewellery","pendant",
    "cute","fun","big","small","accessory","trinket","bling","flair","piece","play",
    "handmade","trendy","keepsake","gift","keeps","item","collection","doodad","dood",
    "quirky","playful","decoration","funky","fashion","ornament","bauble"
  ]);
  let sixMap = {};
  let twoMap = {};
  try { sixMap = JSON.parse(localStorage.getItem("matrixCharm6Words") || "{}"); } catch(_) {}
  try { twoMap = JSON.parse(localStorage.getItem("matrixCharm2Words") || "{}"); } catch(_) {}
  const raw = String(sixMap[baseName] || twoMap[baseName] || "").toLowerCase();
  if (!raw) return [];
  // keep hyphens inside words, split on whitespace
  const words = raw
    .replace(/[^a-z0-9-\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean)
    .filter(w => !banned.has(w));
  // de-dup to reduce redundant regex checks
  return Array.from(new Set(words)).slice(0, 12); // soft cap to avoid overly broad matches
}

// Lowercase, strip punctuation, collapse spaces, keep up to 8 words,
// and drop banned filler tokens (e.g., "charm", "jewelry", "jewellery").
function normalizeTwoWordDescriptor(s){
  const banned = new Set(["charm","jewelry","jewellery","pendant", "cute", "fun", "big", "small", "accessory", "trinket", "bling", "flair", "piece", "play", "handmade", "trendy", "keepsake", "gift", "keeps", "item", "collection", "doodad", "dood", "quirky", "playful", "decoration", "trendy", "funky", "fashion", "ornament", "bauble"]);

  return String(s || "")
    .toLowerCase()
    .replace(/[^a-z0-9-\s]/gi, " ")   // allow hyphen inside words
    .replace(/\s+/g, " ")
    .trim()
    .split(" ")
    .filter(Boolean)
    .filter(w => !banned.has(w))
    .slice(0, 6)
    .join(" ");
}

  /**
   * augmentSixWordDescriptorOcean(desc6)
   * If any of these appear as whole words in the 6-word descriptor:
   *   dolphin, marine, aquatic, mammal, orca, fish, beach
   * then append 'ocean' once (lowercase) to the descriptor words.
   * Returns the (possibly) augmented string.
   */
  function augmentSixWordDescriptorOcean(desc6){
    const triggers = new Set(["dolphin","marine","aquatic","mammal","orca","fish","beach", "whale", "water", "animal", "octopus"]);
    const words = String(desc6 || "")
      .toLowerCase()
      .replace(/[^a-z0-9-\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim()
      .split(" ")
      .filter(Boolean);
    if (!words.length) return "";
    const hasTrigger = words.some(w => triggers.has(w));
    if (hasTrigger && !words.includes("ocean")) words.push("ocean");
    return words.join(" ");
  }

/********************************************************
 * Firebase Initialization (REQUIRED)
 ********************************************************/
const firebaseConfig = {
  apiKey: "YourApiKeyHere",
  authDomain: "YourAuthDomainHere",
  projectId: "gokudatabase",
  storageBucket: "gokudatabase.firebasestorage.app",
  messagingSenderId: "1078662308113",
  appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/* ==============================================================
   UNIVERSAL drag‑and‑drop handlers for the Match Preview modal
   ==============================================================*/
let dragInfo = null;

function handleDragStart(e) {
  const img = e.target;
  dragInfo = {
    cell : img.dataset.cell,
    slot : img.dataset.slot,
    src  : img.src,
    name : img.title || ""
  };
  e.dataTransfer.setData("text/plain", "x"); // Firefox fix
}

function handleDrop(e) {
  e.preventDefault();
  e.currentTarget.classList.remove("droptarget");

  if (!dragInfo) return;
  const targetBox = e.currentTarget;
  const tCell = targetBox.dataset.cell;
  const tSlot = targetBox.dataset.slot;
  const tImg  = targetBox.querySelector("img");

  /* 1. place dragged image into target slot */
  tImg.src  = dragInfo.src;
  tImg.title = dragInfo.name;
  tImg.classList.remove("placeholder");

  if (!cellMatches[tCell]) cellMatches[tCell] = [];
  cellMatches[tCell][tSlot] = { userImage: dragInfo.src, userName: dragInfo.name };

  /* 2. clear the source slot, or remove from unmatched */
  if (dragInfo.cell !== undefined) {
    /* came from another matched box */
    const srcBox = document.querySelector(
      `.match-box[data-cell='${dragInfo.cell}'][data-slot='${dragInfo.slot}'] img`
    );
    srcBox.src   = "placeholder.png";
    srcBox.title = "";
    srcBox.classList.add("placeholder");
    if (cellMatches[dragInfo.cell]) cellMatches[dragInfo.cell][dragInfo.slot] = null;
  } else {
    /* came from unmatched list */
    e.dataTransfer.clearData();         // unmatched list already visually updated
  }

  dragInfo = null;
}

/********************************************************
 * Etsy Auth, Code Challenge, configIDs
 ********************************************************/
(function (){
  const url = new URLSearchParams(window.location.search);
  // Tokens returned by exchangeToken.js (access, refresh, expires_in, issued_at)
  const a = url.get("access_token");
  if (a){
    setTokens({
      access_token : a,
      refresh_token: url.get("refresh_token"),
      expires_in   : url.get("expires_in"),
      issued_at    : url.get("issued_at")
    });
    window.history.replaceState({}, document.title, window.location.pathname);
    M.toast?.({ html: "Connection Successful!" });
    return;
  }
  // Standard OAuth code return → hand back to server for code→tokens
  const code = url.get("code");
  if (code){
    const v = localStorage.getItem("etsy_code_verifier");
    if (v){
      const qs = new URLSearchParams({ code, code_verifier: v, redirect_domain: "sorting" });
      window.location.href = "/.netlify/functions/exchangeToken?" + qs.toString();
      return;
    }else{
      console.error("No code verifier found in localStorage.");
    }
  }
  // Page load without query: rehydrate or refresh
  if (localStorage.getItem(TOKEN_KEYS.access)) {
    scheduleTokenRefresh();
  } else if (localStorage.getItem(TOKEN_KEYS.refresh)) {
    refreshAccessToken();
  } else {
    // No tokens at all → start OAuth silently (like shipping-1/design)
    startOAuth("boot");
  }
})();

function generateRandomString(length) {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let text = "";
  for (let i = 0; i < length; i++) {
    text += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return text;
}

async function generateCodeChallenge(codeVerifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(codeVerifier);
  const digest = await crypto.subtle.digest("SHA-256", data);
  let base64String = btoa(String.fromCharCode(...new Uint8Array(digest)));
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

// Headless OAuth starter (no UI clicks needed)
let __oauthInFlight = false;
async function startOAuth(reason = "auto"){
  if (__oauthInFlight) return;
  __oauthInFlight = true;
  try{
    const codeVerifier = generateRandomString(64);
    localStorage.setItem("etsy_code_verifier", codeVerifier);
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    const CLIENT_ID   = "k75zdspz4r99txpqdji7i2em";
    const redirectUri = "https://sorting.goldenspike.app";
    const scope       = "listings_w listings_r transactions_r transactions_w";
    const state       = `reconnect_${Date.now()}_${reason}`;
    const etsyAuthUrl =
      "https://www.etsy.com/oauth/connect?response_type=code" +
      "&client_id=" + CLIENT_ID +
      "&redirect_uri=" + encodeURIComponent(redirectUri) +
      "&scope=" + encodeURIComponent(scope) +
      "&state=" + encodeURIComponent(state) +
      "&code_challenge=" + encodeURIComponent(codeChallenge) +
      "&code_challenge_method=S256";
    window.location.href = etsyAuthUrl;
  }catch(e){
    console.error("OAuth boot failed:", e);
    __oauthInFlight = false;
  }
}

// ADDED these two lines so you can reposition/resize them in the Config modal
const configIDs = [
  "connectEtsyBtn",
  "testOpenAIBtn",
  "openConfigBtn",
  "mpBackBtn",
  "mpNextBtn",
  "etsyOrderNumber",
  "photoGridContainer",
  "unmatchedContainer",
  "configModal",
  "configTable",
  "saveConfigBtn",
  "photoDragDrop",
  "matrixProgressWrap",
  "sendMatchBtn",
  "matchPrintBtn",
  "titleEtsyOrderNumber",
  "titleImageMatrixDrop",
  "prefilterPanel",
  "orderSearchBox",
  "filterIncompleteBtn",
  "titleUnmatchedImages"
];

/********************************************************
 * DOMContentLoaded: Disable buttons & attach logic
 ********************************************************/
document.addEventListener("DOMContentLoaded", function () {
  M.AutoInit();

  // Disable "Send & Match", "Match & Print", "Back", "Next" on load
  disableSendMatch();
  disableMatchPrintFlow();

  setTimeout(function () {
    loadPositions();
    document.body.style.opacity = 1;
  }, 200);

  // Connect Etsy (manual) – reuse headless starter
  document.getElementById("connectEtsyBtn").addEventListener("click", () => startOAuth("manual"));

  // Load multiple orders on Enter (partial snippet)
  const etsyOrderInput = document.getElementById("etsyOrderNumber");
etsyOrderInput.addEventListener("keydown", async function (e) {
  if (e.key === "Enter") {

    // NEW: cancel *all* outstanding fetches / work from a previous run
    pendingFetchControllers.forEach(ctrl => ctrl.abort());
    pendingFetchControllers = [];     // fresh list for this run

    globalRunId++;                    // ← bump run ID so old tasks quit

    // Reset arrays & state
    croppedImagesArray = [];
    userImagesArray = [];
    cellMatches = {};
    partialMatches = {};
    window.cachedOrderItems = [];
    matchPrintFlowInProgress = false;

    // Clear UI
    document.getElementById("photoGridContainer").innerHTML = "";
    document.getElementById("unmatchedContainer").innerHTML = "";
    pfReset();  // ← clear pre-filter UI for a fresh run

    disableSendMatch();
    disableMatchPrintFlow();
    removeAllBlueHighlights();

    const inputVal = etsyOrderInput.value.trim();
    if (!inputVal) return;

    let orderNumbers = inputVal
      .split(",")
      .map((x) => x.trim())
      .filter((x) => x);

    await loadBatchEtsyOrders(orderNumbers);
  }
});

  // Attach "Send & Match" logic
  document.getElementById("sendMatchBtn").addEventListener("click", async function () {
    try {
      console.log("Starting to crop images...");
      croppedImagesArray = [];
      await cropAllImages();
      console.log("Done cropping. Pausing 250ms...");
      await new Promise(r => setTimeout(r, 250));
      console.log("Now sending & matching...");
      await sendAndMatch();
    } catch (err) {
      console.error("Error in combined Crop + Send & Match:", err);
    }
  });


  // ===== NEW LINE: Start listening for QR scans from sort-scan.html =====
  startScannedSortingListener();
});

  // Filter toggle
  const fbtn = document.getElementById("filterIncompleteBtn");
  if (fbtn) {
    fbtn.addEventListener("click", () => {
      window.filterIncompleteOnly = !window.filterIncompleteOnly;
      fbtn.textContent = window.filterIncompleteOnly ? "Show All" : "Filter";
      const q = document.getElementById("orderSearchBox")?.value || "";
      if (typeof window.applyOrderSearchFilter === "function") {
        window.applyOrderSearchFilter(q);
      }
    });
  }

/* ==========================================================
   Global helper – click any matchCellX to open the modal
   ==========================================================*/
function attachMatchCellListeners() {
  const matches = document.querySelectorAll("input[id^='matchCell']");
  matches.forEach((inp) => {
    inp.removeEventListener("click", matchCellHandler);  // clear stale
    inp.addEventListener("click",  matchCellHandler);    // add fresh
  });
}

function matchCellHandler(ev) {
  const idx = parseInt(ev.currentTarget.id.slice("matchCell".length), 10);
  if (!isNaN(idx)) openMatchPreviewModal(idx);
}

/********************************************************
 * Unified border logic – replaces old toggleSkipBorder
 ********************************************************/
function evaluateBorder(cellIdx) {
  const pb = document.getElementById("previewCell" + cellIdx);
  if (!pb) return;

  /* A) permanent green outline if skipped */
  if (skipMatches[cellIdx]) {
    pb.style.border = "3px solid green";
    return;
  }

  /* B) count ONLY real images, ignore placeholders */
  const realCount = (cellMatches[cellIdx] || [])
    .filter(m => m && m.userImage).length;
  const needed    = expectedSlots(window.cachedOrderItems[cellIdx]);

  pb.style.border = realCount >= needed
    ? "1px solid #000"          // complete
    : "3px solid orangered";    // incomplete
}

function toggleSkipBorder(cellIdx, isSkipped) {
  skipMatches[cellIdx] = isSkipped;
  evaluateBorder(cellIdx);
}

/********************************************************
 * hideMatchPrintUI(): strip all 3 px blue outlines & the
 * floating “Print” button, but keep any orangered alerts
 ********************************************************/
function hideMatchPrintUI() {
  // Remove blue borders only
  document.querySelectorAll("#photoGridContainer .preview-box").forEach(pb => {
    const b = pb.style.border || "";
    if (b.includes("3px") && b.includes("blue")) {
      pb.style.border = "1px solid #000";
    }
  });

  // Remove the single overlay Print button (if present)
  const overlayBtn = document.querySelector("button.overlay-print-btn");
  if (overlayBtn) overlayBtn.remove();

  // Mark the flow as interrupted
  window.matchPrintFlowInProgress = false;
}

/********************************************************
 * Disabling / Enabling “Send & Match”
 ********************************************************/
function disableSendMatch() {
  const btn = document.getElementById("sendMatchBtn");
  btn.disabled = true;
  btn.style.opacity = "0.5";
}
function enableSendMatch() {
  const btn = document.getElementById("sendMatchBtn");
  btn.disabled = false;
  btn.style.opacity = "1";
}

/********************************************************
 * startScannedSortingListener (NEW partial snippet)
 ********************************************************/
async function startScannedSortingListener() {
  try {
    const docRef = db.collection("Brites_Orders").doc("ScannedSortingOrder");
    docRef.onSnapshot((docSnap) => {
      if (!docSnap.exists) {
        console.log("No 'ScannedSortingOrder' doc in Firestore yet.");
        return;
      }
      const docData = docSnap.data();
      if (!docData["Order Number"]) {
        console.log("No 'Order Number' in 'ScannedSortingOrder' doc.");
        return;
      }
      const scannedVal = docData["Order Number"];
      console.log("Scanned Sorting code =>", scannedVal);

      const input = document.getElementById("etsyOrderNumber");
      if (!input) return;
      input.value = scannedVal;

      // [NEW: reset states as if app just opened]
      disableSendMatch();
      disableMatchPrintFlow();
      removeAllBlueHighlights();

      // Programmatically fire an Enter key
      const enterEvent = new KeyboardEvent("keydown", { key: "Enter" });
      input.dispatchEvent(enterEvent);
    });
  } catch (err) {
    console.error("Error starting scannedSortingListener:", err);
  }
}

/********************************************************
 * Enable Back and Next (NEW)
 ********************************************************/
function enableBackNext() {
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");
  if (backBtn) {
    backBtn.disabled = false;
    backBtn.style.opacity = "1";
  }
  if (nextBtn) {
    nextBtn.disabled = false;
    nextBtn.style.opacity = "1";
  }
}

/********************************************************
 * Disabling / Enabling “Match & Print” Flow
 * (i.e. Match & Print button, plus Back and Next)
 ********************************************************/
function disableMatchPrintFlow() {
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  matchPrintBtn.disabled = true;
  matchPrintBtn.style.opacity = "0.5";

  const backBtn = document.getElementById("mpBackBtn");
  backBtn.disabled = true;
  backBtn.style.opacity = "0.5";

  const nextBtn = document.getElementById("mpNextBtn");
  nextBtn.disabled = true;
  nextBtn.style.opacity = "0.5";

  //removeAllBlueHighlights();
}

function enableMatchPrintFlow() {
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");

  matchPrintBtn.disabled = false;
  matchPrintBtn.style.opacity = "1";

  backBtn.disabled = false;
  backBtn.style.opacity = "1";

  nextBtn.disabled = false;
  nextBtn.style.opacity = "1";
}


  /********************************************************
   * removeAllBlueHighlights (now clears green too)
   * ‑ resets any 3px blue OR green borders to 1px black
   * ‑ removes bold weight in matchCellX
   * ‑ deletes the single overlay Print button
   ********************************************************/
  function removeAllBlueHighlights() {
    const previewBoxes = document.querySelectorAll(".preview-box");
    previewBoxes.forEach((pb, i) => {
      const b = pb.style.border || "";
      if (b.includes("3px") && (b.includes("blue") || b.includes("green"))) {
        pb.style.border = "1px solid #000";
      }
      const matchBox = document.getElementById("matchCell" + i);
      if (matchBox) matchBox.style.fontWeight = "";
    });

    const overlayBtn = document.querySelector("button.overlay-print-btn");
    if (overlayBtn) overlayBtn.remove();
  }

    /* =========================================================
     expectedSlots(item)
     – Returns Qty × (2 if earring, else 1)
     =======================================================*/
    function expectedSlots(item = {}) {
      const qty  = Number(item.qty  || item.quantity || 1) || 1;        // listing quantity
      const disc = Number(item.discCount || 0);                         // 0-5

      /* Treat each disc as its own matrix-photo target. If discCount is 0,
         fall back to the normal listing quantity logic. */
      let base = disc > 0 ? qty * disc : qty;

      /* Earrings still double the slot requirement */
      return base * (item.isEarring ? 2 : 1);
    }

   /* ==============================================================
    * safePushMatch(cellIdx, obj)
    * — adds obj to cellMatches[cellIdx] **only** if we still have
    *   free capacity according to expectedSlots()
    *   returns true when pushed, false when skipped
    * ==============================================================*/
   function safePushMatch(cellIdx, obj){
     const need = expectedSlots(window.cachedOrderItems?.[cellIdx] || {});
     if (!cellMatches[cellIdx]) cellMatches[cellIdx] = [];
     const have = cellMatches[cellIdx].filter(m => m && m.userImage).length;
     if (have >= need) return false;   // already full → ignore extra
     cellMatches[cellIdx].push(obj);
     return true;
   }

  function removeHighlightForCell(cellIndex) {
    const previewBox = document.getElementById("previewCell" + cellIndex);
    if (previewBox) {
      // Reset any blue or orangered border back to 1 px black
      if ((previewBox.style.border || "").includes("blue") ||
          (previewBox.style.border || "").includes("orangered")) {
        previewBox.style.border = "1px solid #000";
      }

      // Reset match‑cell text if it was orangered
      const matchBox = document.getElementById("matchCell" + cellIndex);
      if (matchBox && matchBox.style.color === "orangered") {
        matchBox.style.color = "";
        matchBox.style.fontWeight = "";
      }
    }

    // NEW: remove the overlay “Print” button (there’s only ever one)
    const overlayBtn = document.querySelector("button.overlay-print-btn");
    if (overlayBtn) overlayBtn.remove();
}


/********************************************************
 * detectAnyOrangered()
 *  – returns TRUE only if a non‑skipped cell is still
 *    incomplete or visibly marked orangered.
 *  – every cell listed in skipMatches is ignored.
 ********************************************************/
  function detectAnyOrangered() {
    let found = false;

    /* (A) 3 px orangered border on preview boxes */
    const previewBoxes = document.querySelectorAll("#photoGridContainer .preview-box");
    previewBoxes.forEach((pb) => {
      const idx = Number(pb.id.replace("previewCell", ""));
      if (skipMatches[idx]) return;                       // ← ignore skipped cells
      if ((pb.style.border || "").includes("3px solid orangered")) {
        found = true;
      }
    });

    /* (B) orangered text colour or missing matches */
    for (let i = 0; i < croppedImagesArray.length; i++) {
      if (skipMatches[i]) continue;                       // ← ignore skipped cells

      const matchBox = document.getElementById("matchCell" + i);
      if (!matchBox) continue;

      /* 1) old orangered text */
      if (matchBox.style.color === "orangered") {
        found = true;
      }

      /* 2) not enough real matches */
      const realCount = cellMatches[i]
        ? cellMatches[i].filter(m => m && m.userImage).length
        : 0;
      const needed = expectedSlots(window.cachedOrderItems[i]);
      if (realCount < needed) found = true;
    }

    return found;
  }

/********************************************************
 * “Match & Print” main logic
 ********************************************************/
document.getElementById("matchPrintBtn").addEventListener("click", initMatchAndPrintFlow);

function initMatchAndPrintFlow() {
  console.log("Match & Print pressed.");

  // ↓ keep track globally that Match & Print is in progress
  window.matchPrintFlowInProgress   = true;

  // 1) Gather .preview-box elements and build uniqueOrders array
  const previewBoxes = document.querySelectorAll("#photoGridContainer .preview-box");
  const uniqueOrders = [];
  previewBoxes.forEach((pb, i) => {
    const orderCell = document.getElementById("orderCell" + i);
    if (orderCell && orderCell.value && !uniqueOrders.includes(orderCell.value)) {
      uniqueOrders.push(orderCell.value);
    }
  });

  // 2) If there are no orders, bail out
  if (!uniqueOrders.length) {
    M.toast({ html: "No orders found to highlight." });
    enableSendMatch();  // re-enable “Send & Match”
    return;
  }

  // ↓ store the orders list & current index
  window.matchPrintUniqueOrders = uniqueOrders;
  window.matchPrintCurrentIndex  = 0;

  // ↓ expose highlightOrder so we can call it later
  window.highlightOrderGlobal     = highlightOrder;

  // 3) Forcefully remove all old 3px blue outlines and old “Print” buttons
  removeAllHighlightsAndPrintButtons();

  // 4) currentIndex => start at 0
  let currentIndex = 0;

  // 5) Also disable “Send & Match” while in “Match & Print”
  disableSendMatch();

  // 6) If you want “Back” and “Next” to be enabled now
  enableBackNext();

  // 7) We'll store a reference to the “Print” button so we can remove it when switching orders
  let currentPrintBtn = null;

  // ------------------------------------------------------------------------
  // removeAllHighlightsAndPrintButtons => forcibly remove leftover 3px lines + "Print" buttons
  // ------------------------------------------------------------------------
  function removeAllHighlightsAndPrintButtons() {
    previewBoxes.forEach((pb, i) => {
      pb.style.border = "1px solid #000"; // reset to black
      const matchBox = document.getElementById("matchCell" + i);
      if (matchBox) {
        matchBox.style.fontWeight = "";
      }
    });
    // remove any leftover “Print” button in the DOM
    const leftoverPrintBtns = document.querySelectorAll(".overlay-print-btn");
    leftoverPrintBtns.forEach((btn) => btn.remove());
  }

  // ------------------------------------------------------------------------
  // highlightOrder => highlight all preview cells for a particular order
  // ------------------------------------------------------------------------
  function highlightOrder(orderNum) {

    // 0) Wipe previous blue outlines + Print button
    removeAllHighlightsAndPrintButtons();

    // 0.1) Re‑apply persistent 3 px GREEN borders for any skipped items
    Object.keys(skipMatches).forEach(idx => {
      if (skipMatches[idx]) {
        toggleSkipBorder(parseInt(idx, 10), true);   // restores green border
      }
    });

    // We'll keep track of which cell in this order gets the Print button
    let chosenIndexForPrintBtn = -1;

    // 1) Loop over all preview boxes for this order
    previewBoxes.forEach((pb, i) => {
      const orderCell = document.getElementById("orderCell" + i);
      if (orderCell && orderCell.value === orderNum) {
        pb.style.border = "3px solid blue";

        const matchBox = document.getElementById("matchCell" + i);
        if (matchBox) matchBox.style.fontWeight = "bold";

        // choose first encountered cell for Print button
        if (chosenIndexForPrintBtn < 0) chosenIndexForPrintBtn = i;
      }
    });

    // 2) Add overlay “Print” button to chosen cell
    if (chosenIndexForPrintBtn >= 0) {
      const chosenBox = document.getElementById("previewCell" + chosenIndexForPrintBtn);
      createPrintButtonOverBox(chosenBox, chosenIndexForPrintBtn);
    }
  }

  // ------------------------------------------------------------------------
  // createPrintButtonOverBox => place a “Print” button on top of the given preview box
  // ------------------------------------------------------------------------
  function createPrintButtonOverBox(previewBox, cellIndex) {
    const rect = previewBox.getBoundingClientRect();
    const btn = document.createElement("button");
    btn.textContent = "Print";
    btn.classList.add("overlay-print-btn");
    btn.style.position = "absolute";
    btn.style.width = "50px";
    btn.style.height = "25px";
    btn.style.background = "rgba(0,0,0,0.5)";
    btn.style.color = "#fff";
    btn.style.border = "none";
    btn.style.left = (rect.left + 30) + "px";
    btn.style.top = (rect.top + 40) + "px";
    btn.style.zIndex = "9999";
    btn.style.cursor = "pointer";

    btn.addEventListener("click", () => openIframePrinterForListing(cellIndex));
    document.body.appendChild(btn);
    return btn;
  }

  // ------------------------------------------------------------------------
  // Immediately highlight cell0 => “uniqueOrders[currentIndex]”
  // so the user sees a 3px blue outline and a "Print" button on cell0 right away
  // ------------------------------------------------------------------------
  highlightOrder(uniqueOrders[currentIndex]);

  // ------------------------------------------------------------------------
  // Hook up “Next” and “Back” logic
  // ------------------------------------------------------------------------
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");

  backBtn.onclick = () => {
    if (currentIndex <= 0) {
      M.toast({ html: "Already at the first order." });
      return;
    }
    currentIndex--;
    highlightOrder(uniqueOrders[currentIndex]);
  };

  nextBtn.onclick = () => {
    currentIndex++;
    if (currentIndex >= uniqueOrders.length) {
      M.toast({ html: "Congrats, You’re Done!" });
      removeAllHighlightsAndPrintButtons(); // remove leftover blue lines + “Print” button
      enableSendMatch(); // re-enable “Send & Match” or do whatever you want here
      return;
    }
    highlightOrder(uniqueOrders[currentIndex]);
  };
}


/********************************************************
 * openIframePrinterForListing(cellIndex)
 ********************************************************/
function openIframePrinterForListing(cellIndex) {
  console.log("Opening QR Printer for cell:", cellIndex);

  if (!window.cachedOrderItems) {
    console.warn("No cachedOrderItems found.");
    return;
  }

  // 1) Grab the clicked item
  const item = window.cachedOrderItems[cellIndex];
  if (!item) {
    console.warn("No item found for cellIndex:", cellIndex);
    return;
  }

  // 2) Extract the ship date (or default to "N/A")
  const dispatchDate = item.dispatch_date || "N/A";

  // 3) Filter out all items for this same order
  const orderID = item.receipt_id;
  console.log("Filtering items for order:", orderID);
  const itemsForOrder = window.cachedOrderItems.filter(one => one.receipt_id === orderID);

  // 4) Build an object for QR Printer
  const dataToPrint = {
    dispatchDate,
    items: itemsForOrder,
    userTypedOrderNum: item.typedOrderNumber || "UnknownOrder" // or whatever variable holds the typed Etsy order number
  };
  
  localStorage.setItem("qrPrintAll", JSON.stringify(dataToPrint));

  // 5) Save that object in localStorage
  localStorage.setItem("qrPrintAll", JSON.stringify(dataToPrint));

  // 6) CREATE A HIDDEN 1×1 IFRAME (NO OVERLAY)
  const hiddenIframe = document.createElement("iframe");
  hiddenIframe.style.position = "absolute";
  hiddenIframe.style.width = "1px";
  hiddenIframe.style.height = "1px";
  hiddenIframe.style.opacity = "0";
  hiddenIframe.style.border = "0";
  hiddenIframe.src = "QR Printer.html";
  document.body.appendChild(hiddenIframe);
}

    /* ===== Hard-coded fallback positions & sizes (no calculations) ===== */
    const defaultPos = {
      configModal:              { left:711, top:387, width:250, height:450 },
      configTable:              { left:27,  top:7,   width:525, height:1392 },
      connectEtsyBtn:           { left:1070,top:729,  width:170, height:35 },
      cropImagesBtn:            { left:20,  top:215, width:140, height:35 },
      etsyOrderNumber:          { left:20,  top:25,  width:200, height:30 },
      imageComparisonContainer: { left:0,   top:0,   width:0,   height:0 },
      matchPrintBtn:            { left:20,  top:315, width:210, height:35 },
      matchesModal:             { left:0,   top:0,   width:55,  height:0 },
      mpBackBtn:                { left:720, top:15,  width:100, height:35 },
      mpNextBtn:                { left:850, top:15,  width:100, height:35 },
      openConfigBtn:            { left:1270,top:729, width:140, height:35 },
      photoDragDrop:            { left:0,   top:-195,width:210, height:100 },
      photoGridContainer:       { left:270, top:68,  width:1140,height:650 },
      titleEtsyOrderNumber:     { left:20,  top:2,   width:145, height:20 },
      titleImageMatrixDrop:     { left:20,  top:91,  width:145, height:20 },
      titleUnmatchedImages:     { left:21,  top:437, width:145, height:20 },
      unmatchedContainer:       { left:0,   top:152, width:600, height:0 },
      userImage:                { left:0,   top:0,   width:100, height:100 },
      saveConfigBtn:            { left:10,  top:3,   width:85,  height:35 },
      sendMatchBtn:             { left:20,  top:255, width:210, height:35 },
      prefilterPanel:           { left:1460, top:68, width:360, height:650 },
      matrixProgressWrap:       { left:250,   top:-316, width:290,   height:50 },
      orderSearchBox :          { left: 1053, top: 15, width: 260, height: 35 },
      filterIncompleteBtn:      { left: 1328, top: 15, width: 120, height: 35 },
      testOpenAIBtn:            { left:20,  top:65,  width:140, height:35 }
    };

      /********************************************************
       * loadPositions -- apply stored values or hard defaults
       ********************************************************/
      function loadPositions() {
        configIDs.forEach((id) => {
          const el = document.getElementById(id);
          if (!el) return;

          const def = defaultPos[id] || {};
          const left   = parseInt(localStorage.getItem(`pos-${id}-left`), 10)   || def.left   || 0;
          const top    = parseInt(localStorage.getItem(`pos-${id}-top`), 10)    || def.top    || 0;
          const width  = parseInt(localStorage.getItem(`pos-${id}-width`), 10)  || def.width  || 0;
          const height = parseInt(localStorage.getItem(`pos-${id}-height`), 10) || def.height || 0;

          el.style.position = "absolute";
          el.style.left   = left   + "px";
          el.style.top    = top    + "px";
          if (width  > 0) el.style.width  = width  + "px";
          if (height > 0) el.style.height = height + "px";
        });
      }

    // --------------- (Your code for config table, openConfigBtn, saveConfigBtn, etc.) --------------
    document.getElementById("openConfigBtn").addEventListener("click", function () {
      populateConfigTable();
      M.Modal.getInstance(document.getElementById("configModal")).open();
    });

    document.getElementById("saveConfigBtn").addEventListener("click", function () {
      configIDs.forEach(function (id) {
        const el = document.getElementById(id);
        if (!el) return;
        const cs = window.getComputedStyle(el);
        localStorage.setItem("pos-" + id + "-left", parseInt(cs.left, 10) || 0);
        localStorage.setItem("pos-" + id + "-top", parseInt(cs.top, 10) || 0);
        localStorage.setItem("pos-" + id + "-width", parseInt(cs.width, 10) || 0);
        localStorage.setItem("pos-" + id + "-height", parseInt(cs.height, 10) || 0);
      });
      M.toast({ html: "Positions saved!" });
    });

    function populateConfigTable() {
      const tbody = document.querySelector("#configTable tbody");
      tbody.innerHTML = "";

      configIDs.forEach(function (id) {
        const el = document.getElementById(id);
        if (!el) return;
        const cs = window.getComputedStyle(el);
        const leftVal = parseInt(cs.left, 10) || 0;
        const topVal = parseInt(cs.top, 10) || 0;
        const widthVal = parseInt(cs.width, 10) || 0;
        const heightVal = parseInt(cs.height, 10) || 0;

        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${id}</td>
          <td><input type="number" value="${leftVal}" data-id="${id}" class="left-input"></td>
          <td><input type="number" value="${topVal}" data-id="${id}" class="top-input"></td>
          <td><input type="number" value="${widthVal}" data-id="${id}" class="width-input"></td>
          <td><input type="number" value="${heightVal}" data-id="${id}" class="height-input"></td>
        `;
        tbody.appendChild(row);

        row.querySelector(".left-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.left = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".top-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.top = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".width-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.width = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".height-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.height = parseInt(this.value, 10) + "px";
        });
      });
    }

    // --------------- Drag-and-drop logic ---------------    /* ⇢ anchor */
    const photoDragDropElem = document.getElementById("photoDragDrop");

    /* allow dropping */
    photoDragDropElem.addEventListener("dragover", (e) => {
      e.preventDefault();                        // must keep
      photoDragDropElem.classList.add("drag-hover");   // ★ add every frame
    });

    /* keep blue only while inside */
    photoDragDropElem.addEventListener("dragleave", () =>
      photoDragDropElem.classList.remove("drag-hover"));

    photoDragDropElem.addEventListener("drop", async function (e) {
      e.preventDefault();
      photoDragDropElem.classList.remove("drag-hover");   // remove after drop


    const files = e.dataTransfer.files;
    if (!files || files.length === 0) return;

    /* Collect every 400×400 quadrant here for one-time AI analysis */
    const subImagesToAnalyze = [];

    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      // Convert the dropped file to a DataURL
      const fileDataUrl = await readAsDataURL(file);

      // Slice into 10×14 = 140 tiles
      const subImages = await extractSubImages144(fileDataUrl);

      for (let q = 0; q < subImages.length; q++) {
         const cropped   = await cropTo512(subImages[q]);
         const corrected = await reduceRedTone(cropped, 0.85);   // NEW
 
         // Push to temporary array; NOT yet stored in userImagesArray
        subImagesToAnalyze.push({ origName: file.name + "_Q" + q, data: cropped });
              }

      M.toast({
        html: `File ${file.name}: Extracted 140 individual images`
      });
    }

    localStorage.removeItem("userImagesArray");
    userImagesArray = [];

    // Analyze every sub-image; store only those with a charm
    await analyzeAndStoreSubImages(subImagesToAnalyze);

    /* NOTE:
       We do NOT refresh unmatchedContainer here.
       That preview is shown ONLY after Send-and-Match finishes.  */
  });

/* ──────────────────────────────────────────────────────────────
   analyzeAndStoreSubImages(imgObjs)
   • Analyze up to 140 tiles via AI.
   • Save every image immediately (no tagging yet).
   • Track a “no charm” streak.
   • On 4th consecutive “no charm”: remove those 4 and stop.
   • Otherwise (even 1–3 “no charm”): keep all.
   • If you process all 140 without a 4-streak, keep all.
   • Persists names only, so downstream send&match sees every tile.
────────────────────────────────────────────────────────────── */
async function analyzeAndStoreSubImages(imgObjs) {
  if (!imgObjs || imgObjs.length === 0) return;

  const MAX = 140;
  const toRun = imgObjs.slice(0, MAX);

  showProgressModal("Analyzing Photos...", toRun.length);

  let done    = 0;
  let streak  = 0;
  let saved   = 0;

  for (let i = 0; i < toRun.length; i++) {
    const { origName, data } = toRun[i];
    const res = await openAIAnalyzePhoto(data);
    const isCharm = (res.charmPresent || "").toLowerCase() === "yes";

    // 1) Decide the final filename now
    const finalName = isCharm
      ? `${res.color || "UnknownColor"}_${res.topRightNumber || "XX"}.jpg`
      : `${origName}.jpg`;

    // Save the image immediately
    userImagesArray.push({ name: finalName, data, analyzed: true });
    saved++;

    // 1b) Persist the 2-word descriptor mapped to this image base name
    try {
      const k   = "matrixCharm2Words";
      const map = JSON.parse(localStorage.getItem(k) || "{}");
      const base = stripExtension(finalName);
      const norm = normalizeTwoWordDescriptor(res?.desc2 || "");
      if (norm) {
        map[base] = norm;           // e.g., { "Gold_2": "paw print" }
        localStorage.setItem(k, JSON.stringify(map));
      }
    } catch (e) {
      console.warn("matrixCharm2Words persist failed:", e);
    }

      // 1c) Persist the full 6-word descriptor, auto-appending 'ocean' on trigger
      try {
        const k6   = "matrixCharm6Words";
        const map6 = JSON.parse(localStorage.getItem(k6) || "{}");
        const base = stripExtension(finalName);
        const raw6 = String(res?.desc2 || "");
        const aug6 = augmentSixWordDescriptorOcean(raw6); // adds 'ocean' if dolphin/marine/aquatic/mammal/orca/fish/beach present
        if (aug6) {
          map6[base] = aug6;          // e.g., { "Gold_2": "animal dolphin pendant ... ocean" }
          localStorage.setItem(k6, JSON.stringify(map6));
        }
      } catch (e) {
        console.warn("matrixCharm6Words persist failed:", e);
      }

    // 2) Update streak
    if (isCharm) {
      streak = 0;
    } else {
      streak++;
      if (streak === 4) {
        // remove exactly those 4 empties and abort
        userImagesArray.splice(-4, 4);
        saved -= 4;
        M.toast({ html: "Stopped: 4 consecutive photos without charms." });
        break;
      }
    }

    done++;
    updateProgressModal(done, toRun.length);
  }

  closeProgressModal();

  // 3) If you ran out under the cap (no 4-streak), do nothing—keep all
  // 4) If you hit exactly 140 with no 4-streak, do nothing—keep all

  // 5) Persist only the names (no skipForCharm)
  try {
    const slim = userImagesArray.map(({ name }) => ({ name }));
    localStorage.setItem("userImagesArray", JSON.stringify(slim));
  } catch (err) {
    console.warn("localStorage quota exceeded:", err.message);
  }

  enableSendMatch();
  M.toast({ html: `Analysis complete – processed ${done} photos, saved ${saved}.` });
}

/********************************************************
 * stripExtension("photo.jpg") → "photo"
 ********************************************************/
function stripExtension(fileName) {
  return fileName.replace(/\.\w+$/, "");
}

// Reads a File object into a DataURL
async function readAsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

/********************************************************
 * extractSubImages144: always slice a composite into 10×14 = 140 tiles
 ********************************************************/
async function extractSubImages144(baseDataUrl) {
  const img = await loadImage(baseDataUrl);

  const fullW = img.naturalWidth;
  const fullH = img.naturalHeight;
  const cellW = fullW / 10;          // ← changed from /10
  const cellH = fullH / 14;          // ← changed from /14

  const results = [];
  for (let r = 0; r < 14; r++) {     // ← rows: 14 tall
    for (let c = 0; c < 10; c++) {   // ← cols: 10 wide
      const canvas = document.createElement("canvas");
      canvas.width  = cellW;
      canvas.height = cellH;

      const ctx = canvas.getContext("2d");
      ctx.drawImage(
        img,
        c * cellW, r * cellH, cellW, cellH,   // src
        0, 0, cellW, cellH                    // dest
      );
      results.push(canvas.toDataURL("image/jpeg", 0.7));
    }
  }
  return results;     // 140 sub-images
}

// cropTo400: forcibly resize each quadrant to 400×400
async function cropTo512(dataUrl) {
  const loaded = await loadImage(dataUrl);
  const canvas = document.createElement("canvas");
  canvas.width = 400;
  canvas.height = 400;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(loaded, 0, 0, 400, 400);
  return canvas.toDataURL("image/jpeg", 0.7);
}

 /* === NEW : reduceRedTone — dims the R-channel by 15 % === */
 async function reduceRedTone(dataURL, factor = 0.85) {
   return new Promise((resolve, reject) => {
     const img = new Image();
     img.crossOrigin = "Anonymous";
     img.onload = () => {
       const canvas = document.createElement("canvas");
       canvas.width  = img.width;
       canvas.height = img.height;
       const ctx = canvas.getContext("2d");
       ctx.drawImage(img, 0, 0);
 
       const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
       const data    = imgData.data;
       for (let i = 0; i < data.length; i += 4) {
         data[i] = Math.round(data[i] * factor);   // R channel ↓30 %
       }
       ctx.putImageData(imgData, 0, 0);
       resolve(canvas.toDataURL("image/png"));
     };
     img.onerror = reject;
     img.src = dataURL;
   });
 }

// Utility: load a DataURL into <img> so we can measure width/height
function loadImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}

// --------------- Single-Photo Analysis (TWO-PASS hue→label + verbose logs) ---------------
// FIX: wrap in an async function to avoid top-level await errors.
async function openAIAnalyzePhoto(base64Image) {
  /* ───────────────────── PASS 1 : hue / number / charm ───────────────────── */
  const ctrlHue = new AbortController();
  pendingFetchControllers.push(ctrlHue);

  const huePayload = {
    model: "gpt-5",
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text:
              "Return JSON EXACTLY like:\n" +
              '  {"hue":"<≤10-word description>", "topRightNumber":"<number or blank>", "charmPresent":"Yes|No",' +
              '   "medianHSV":{"H":<deg>,"S":<pct>,"V":<pct>}, "medianLab":{"L":<L*>,"a":<a*>,"b*":<b*>}}\n\n' +
              "TASK 1 – Describe the dominant metal hue (≤10 words).\n" +
              "TASK 2 – Extract the top-right number (blank if none).\n" +
              "TASK 3 – Is a jewellery charm clearly visible? (Yes|No).\n" +
              "Estimate MEDIAN HSV (H° 0–360, S% 0–100, V% 0–100) and MEDIAN CIELAB (L*, a*, b*).\n" +
              "IMPORTANT MASKING RULES FOR MEDIANS:\n" +
              "• Exclude background/near-black pixels and any white/near-white background.\n" +
              "• Ignore pixels if (HSV.V ≤ 18% OR Lab L* ≤ 20)  ← near-black/very dark. \n" +
              "• Ignore pixels if (HSV.V ≥ 96% OR Lab L* ≥ 96)  ← near-white/very bright. \n" +
              "• Ignore pixels with very low saturation (HSV.S < 8%) to avoid gray background bleed.\n" +
              "Respond with JSON only."
          },
          { type: "image_url", image_url: { url: base64Image, detail: "high" } }
        ]
      }
    ],
    max_tokens: 200
  };

  console.log("%c[openAIAnalyzePhoto] PASS 1 payload:", "color:#03A9F4", huePayload);

  let hueText   = "";
  let topNumber = null;
  let charmFlag = "no";
  let roseHit   = false;  // ← PASS-1 Rose detector

  // Medians from PASS 1 (declared in outer scope so PASS 2 can see them)
  let hsvH = NaN, hsvS = NaN, hsvV = NaN;
  let labL = NaN, labA = NaN, labB = NaN;

  try {
    const r1 = await fetch(functionsBaseUrl + "/openaiProxy", {
      method : "POST",
      headers: { "Content-Type": "application/json" },
      body   : JSON.stringify(huePayload),
      signal : ctrlHue.signal
    });
    const d1 = await r1.json();
    let raw1 = d1.choices?.[0]?.message?.content?.trim() || "";
    console.log("%c[openAIAnalyzePhoto] PASS 1 raw response:", "color:#03A9F4", raw1);

    raw1 = raw1.replace(/^```(\w+)?/, "").replace(/```$/, "").trim();
    const obj1 = JSON.parse(raw1);

    hueText   = obj1.hue            || "";
    topNumber = obj1.topRightNumber || null;
    charmFlag = (obj1.charmPresent  || "No").toLowerCase();
    roseHit   = /rose/i.test(hueText);

    const hsv = obj1.medianHSV || {};
    const lab = obj1.medianLab || {};
    hsvH = Number(hsv.H); hsvS = Number(hsv.S); hsvV = Number(hsv.V);
    labL = Number(lab.L); labA = Number(lab.a); labB = Number(lab.b);
    console.log("%c[openAIAnalyzePhoto] PASS 1 → medians:",
      "color:#03A9F4;font-weight:bold",
      `HSV H=${hsvH}° S=${hsvS}% V=${hsvV}% | Lab L*=${labL} a*=${labA} b*=${labB}`);
    console.log("%c[openAIAnalyzePhoto] PASS 1 → hue:", "color:#03A9F4;font-weight:bold",
      `"${hueText}"  |  topRightNumber: ${topNumber}  |  charmPresent: ${charmFlag}`);
  } catch (err) {
    console.error("[openAIAnalyzePhoto] PASS 1 error:", err);
    return { topRightNumber:null, color:null, charmPresent:"no" };
  }

/* ───────────────────── PASS 2 : hue ⇒ fixed label ───────────────────── */
  const ctrlLabel = new AbortController();
  pendingFetchControllers.push(ctrlLabel);
  const labelPrompt =
    `You are classifying metal color from numeric medians. APPLY THESE CUT LINES STRICTLY:\n` +
    `• HSV rule (primary): RoseGold if 16° ≤ median H ≤ 31° AND S ≥ 28%.\n` +
    `• CIELAB rule (cross-check): RoseGold if a* ≥ 7.5 AND b* ≥ 14.\n` +
    `• Gold rule (fallback): Gold if (median H ≥ 36° AND S ≥ 12%) OR (b* ≥ 15).\n` +
    `• Silver: If S ≤ 13% AND a* between −3 and +4 AND b* between −3 and +8.\n` +
    `• Voting: each satisfied rule is one vote. If both rules agree, use that label.\n` +
    `• Tie-breaking: if Gold vs Silver tie, choose Silver. If RoseGold vs Gold tie, choose Gold unless a* ≥ 8 OR hue contains "rose".\n` +
    `• Only return exactly one word: Gold, RoseGold, or Silver.\n\n` +
    `INPUT\n` +
    `hue="${hueText}"\n` +
    `medianHSV: H=${hsvH} S=${hsvS} V=${hsvV}\n` +
    `medianLab: L=${labL} a=${labA} b=${labB}`;
  const labelPayload = {
    model: "gpt-5",
    messages: [{ role: "user", content: labelPrompt }],
    max_tokens: 30
  };
  console.log("%c[openAIAnalyzePhoto] PASS 2 payload:", "color:#8E24AA", labelPayload);
  let finalColor = null;
  try {
    const r2 = await fetch(functionsBaseUrl + "/openaiProxy", {
      method : "POST",
      headers: { "Content-Type": "application/json" },
      body   : JSON.stringify(labelPayload),
      signal : ctrlLabel.signal
    });
    const d2 = await r2.json();
    let raw2 = d2.choices?.[0]?.message?.content?.trim() || "";
    console.log("%c[openAIAnalyzePhoto] PASS 2 raw response:", "color:#8E24AA", raw2);
    raw2       = raw2.replace(/[^A-Za-z]/g, "");
    finalColor = ["Gold", "RoseGold", "Silver"].includes(raw2) ? raw2 : "Unknown";
    console.log("%c[openAIAnalyzePhoto] PASS 2 → final metal label:", "color:#8E24AA;font-weight:bold", finalColor);
  } catch (err) {
    console.error("[openAIAnalyzePhoto] PASS 2 error:", err);
    finalColor = "Unknown";
  }

  /* ───────────────────── PASS 3 : two-word charm descriptor ───────────────────── */
  const ctrlDesc = new AbortController();
  pendingFetchControllers.push(ctrlDesc);
  const descPrompt = [
    "You will be shown ONE product-matrix tile image.",
    "Return EXACTLY eight (6) lowercase words separated by single spaces in this order:",
    "broad1 focus1 focus2 colloq1 colloq2 synonyms",
    "",
    "• broad1 — a single, high-level class word naming the motif’s category, purpose, function; singular noun only; exclude filler terms (charm, pendant, jewelry), (no plurals)",
    "• focus1 / focus2 — two specific subject/detail words that pin down the exact motif and its defining feature, subtype, purpose, function; singular nouns only; avoid colors, sizes, and marketing words, (no plurals)",
    "• colloq1 = informal synonyms or colloquial variants of broad1 shoppers might type",
    "• colloq2 = informal synonyms or colloquial variants of focus1 shoppers might type",
    "• synonyms = formal synonyms or variants of focus1 or focus2 that shoppers might type",
    "• STRICTLY ban: charm, jewelry, jewellery, pendant, cute, fun, big, small, accessory, trinket, bling, flair, piece, play, handmade, trendy, keepsake, gift, keeps, item, collection, doodad, dood, quirky, playful, decoration, trendy, funky, fashion, ornament, bauble",
    "• Do not mention metal color, engraving text, numbers, or counts",
    "• Output ONLY the 6 words, no punctuation (hyphens inside a word are allowed)"
  ].join("\\n");
  let desc2 = "";
  try {
    const r3 = await fetch(functionsBaseUrl + "/openaiProxy", {
      method : "POST",
      headers: { "Content-Type": "application/json" },
      body   : JSON.stringify({
        model: "gpt-5",
        messages: [
          { role: "user", content: [
            { type: "text", text: descPrompt },
            { type: "image_url", image_url: { url: base64Image, detail: "high" } }
          ]}
        ],
        max_tokens: 20
      }),
      signal : ctrlDesc.signal
    });
    const d3 = await r3.json();
    // Post-process to six words, drop banned tokens, keep hyphens
    desc2 = (d3.choices?.[0]?.message?.content || "")
      .toLowerCase()
      .replace(/[^a-z0-9-\\s]/g, " ")    // allow hyphen
      .replace(/\\s+/g, " ")
      .trim()
      .split(" ")
      .filter(Boolean)
      .filter(w => !["charm","jewelry","jewellery"].includes(w))
      .slice(0,6)
      .join(" ");
  } catch (e) {
    console.warn("[openAIAnalyzePhoto] PASS 3 (desc2) error:", e);
    desc2 = "";
  }

  return {
    topRightNumber : topNumber,
    color          : finalColor,
    charmPresent   : charmFlag,
    desc2
  };
}

// --------------- Master Analysis Function ---------------
async function analyzeUserImagesViaOpenAI() {
  /* -- make sure stripExtension exists in this scope -------- */
  const stripExtension =
    (typeof window.stripExtension === "function")
      ? window.stripExtension
      : (fn => (fn ? fn.replace(/\.\w+$/, "") : ""));

  const runId = globalRunId;   // snapshot current run

  const imagesToAnalyze = userImagesArray.filter(u => !u.analyzed);
  const totalImages     = imagesToAnalyze.length;
  if (totalImages === 0) {
    console.log("No new images to analyze.");
    return;
  }

  /* --- progress modal --- */
  showProgressModal("Image Analysis...", totalImages);

  let doneCount     = 0;
  let noCharmStreak = 0;
  const noCharmList = [];            // store refs to the latest “No‑charm” objects

  imgObj.name     = `${finalColor}_${numTxt}.jpg`;
  imgObj.analyzed = true;

  // Persist descriptors for search: 2-word + 6-word (with 'ocean' augmentation)
    try {
      const baseName = stripExtension(imgObj.name);
      // 2-word map
      (function(){
        const k = "matrixCharm2Words";
        const map = JSON.parse(localStorage.getItem(k) || "{}");
        const norm = normalizeTwoWordDescriptor(result?.desc2 || "");
        if (norm) {
          map[baseName] = norm;
          localStorage.setItem(k, JSON.stringify(map));
        }
      })();
      // 6-word map
      (function(){
        const k6 = "matrixCharm6Words";
        const map6 = JSON.parse(localStorage.getItem(k6) || "{}");
        const raw6 = String(result?.desc2 || "");
        const aug6 = augmentSixWordDescriptorOcean(raw6);
        if (aug6) {
          map6[baseName] = aug6;
          localStorage.setItem(k6, JSON.stringify(map6));
        }
      })();
    } catch (e) {
      console.warn("Descriptor persistence (single-image) failed:", e);
    }

  // helper: scrub one baseName from cellMatches + partialMatches
  function purgeBaseName(baseName) {
    Object.keys(cellMatches).forEach(idx => {
      cellMatches[idx] = (cellMatches[idx] || []).filter(
        m => m.userName !== baseName
      );
    });
    delete partialMatches[baseName + ".jpg"];       // full key in map
  }

  for (let i = 0; i < totalImages; i++) {
    if (runId !== globalRunId) { closeProgressModal(); return; }

     // ── If we hit exactly 140 tiles with a short “no charm” streak (1–3), drop them ──
     if (streak > 0 && streak < 4 && toRun.length === MAX) {
       userImagesArray.splice(-streak, streak);
       saved  -= streak;
     }

    const imgObj = imagesToAnalyze[i];
    await new Promise(res => setTimeout(res, 250));   // pacing

    try {
      const result = await openAIAnalyzePhoto(imgObj.data);

    /* ---------- colour / number naming ---------- */
    const finalColor = result.color || "UnknownColor";   // Gold | RoseGold | Silver | Unknown
    const numTxt     = result.topRightNumber || "XX";

    imgObj.name     = `${finalColor}_${numTxt}.jpg`;
    imgObj.analyzed = true;

    const baseName  = stripExtension(imgObj.name);       // keep this line
    // Persist the 2-word descriptor for this Matrix photo
    try {
      const k = "matrixCharm2Words";
      const map = JSON.parse(localStorage.getItem(k) || "{}");
      const norm = normalizeTwoWordDescriptor(result.desc2);
      if (norm) {
        map[baseName] = norm;                  // e.g., "paw print"
        localStorage.setItem(k, JSON.stringify(map));
      }
      imgObj.desc2 = norm || "";
    } catch (e) {
      console.warn("matrixCharm2Words persist failed:", e);
    }

      /* ---------- charm‑present handling ---------- */
      if (result.charmPresent === "no") {
        imgObj.skipForCharm = true;        // flag but keep for now
        noCharmList.push(imgObj);
        noCharmStreak++;
        
        purgeBaseName(baseName);           // ← NEW: scrub match refs now

        // 4‑in‑a‑row rule → remove the previous 3 flagged images
        if (noCharmStreak === 4) {
          const toDelete = noCharmList.slice(0, 3);     // previous 3
          toDelete.forEach(obj => {
            const idx = userImagesArray.indexOf(obj);
            if (idx >= 0) userImagesArray.splice(idx, 1);
            purgeBaseName(stripExtension(obj.name));
          });
          M.toast({ html: "Stopped: 4 consecutive photos without charms." });
          break;                                        // terminate early
        }
      } else {
        noCharmStreak = 0;
        noCharmList.length = 0;
      }

      console.log("Analysis complete:", imgObj.name,
                  "| charmPresent:", result.charmPresent);
    } catch (err) {
      console.warn("Analysis failed for an image:", err);
    }

    /* --- update progress --- */
    doneCount++;
    updateProgressModal(doneCount, totalImages);
  }

  /* ----- scrub matches referencing ALL flagged photos ----- */
  userImagesArray.forEach(u => {
    if (u.skipForCharm) purgeBaseName(stripExtension(u.name));
  });

  /* 🔥 PERMANENTLY delete all “no‑charm” photos from memory */
  userImagesArray = userImagesArray.filter(u => !u.skipForCharm);

  /* --- persist & finish --- */
  localStorage.setItem("userImagesArray", JSON.stringify(userImagesArray));
  closeProgressModal();
  M.toast({ html: "User Image Analysis Completed" });
  enableSendMatch();
}   // END analyzeUserImagesViaOpenAI

/******************************************************************
 * fillPreviewBoxes(items)
 ******************************************************************/
async function fillPreviewBoxes(items) {
  const container = document.getElementById("photoGridContainer");
  container.innerHTML = "";

  window.cachedOrderItems = items;  // store globally

  /* keyword helpers already used for other UI colouring */
  const groupA = ["stud","studs","stud earrings","ring","rings","earrings"];
  const groupB = ["necklace","necklaces","huggie","huggies","huggie earrings",
                  "hoop","hoops","hoop earrings","bracelet","bracelets",
                  "extender","extenders","chain","chains"];

  /* list that DEFINES an earring */
  const EARRING_PHRASES = [
    "stud","stud earrings","earring","earrings",
    "huggie","huggies","huggie earrings",
    "hoop","hoops","hoop earrings", "Huggie CHARM SET", "CHARM SET"
  ];

   /* --- NEW: pattern to capture “1–5 discs” --------------------------- */
   const DISC_REGEX = /\b([1-5])\s*disc(?:s)?\b/i;

  /* true phrase matcher – handles spaces, dashes, slashes, commas … */
  function containsPhrase(str = "", phrase = "") {
    // turn "stud earrings" → /\bstud[\s\W]+earrings\b/i
    const pattern = "\\b" + phrase
      .trim()
      .replace(/\s+/g, "[\\s\\W]+")   // any run of NON-alphanumerics
      + "\\b";
    return new RegExp(pattern, "i").test(str.toLowerCase());
  }

    /* helper: detect earring terms (≥1 for high-confidence words, else ≥2) */
    function isEarringString(str = "") {
      if (!str) return false;
      const lower = str.toLowerCase();

      // single-hit words that are always earrings
      const HIGH_CONFIDENCE = ["Huggie CHARM SET", "CHARM SET","hoop earrings","huggie earrings"];
      for (const kw of HIGH_CONFIDENCE) {
        const re = new RegExp("\\b" + kw.replace(/\s+/g, "\\s+") + "\\b", "i");
        if (re.test(lower)) return true;            // one match is enough
      }

      /* fallback: ONE keyword is enough */
      for (const ph of EARRING_PHRASES) {
        const re = new RegExp("\\b" + ph.replace(/\s+/g, "\\s+") + "\\b", "i");
        if (re.test(lower)) return true;      // first hit ⇒ earring!
      }
      return false;
    }

  /* ---------- MAIN LOOP: one preview row per transaction ---------- */
  items.forEach((item, index) => {
    /* --- qty memo ------------------------------------------------- */
    item.qty = Number(item.quantity) || 1;

    /* --- Group-A / Group-B keyword tagging ------------------------ */
    let keywords = [];
    if (item.title) {
      const lower = item.title.toLowerCase();
      groupA.forEach(p => { if (containsPhrase(item.title, p)) keywords.push(p); });
      groupB.forEach(p => { if (containsPhrase(item.title, p)) keywords.push(p); });
    }
    if (keywords.length === 0) keywords.push("groupB");   // fallback
    item.keywords = keywords;

    /* --- unified earring detector (title + chosen variations) ----- */
    let earringFound = false;

    /* 1 / title */
    if (item.title && isEarringString(item.title)) {
      earringFound = true;
    }

    /* 2 / buyer-chosen variations */
    if (!earringFound && Array.isArray(item.variations)) {
      for (const v of item.variations) {
        if (v && v.formatted_value && isEarringString(v.formatted_value)) {
          earringFound = true;
          break;
        }
      }
    }

    /* 3 / store & register */
    item.isEarring = earringFound;
    if (earringFound) {
      earringCells[index] = true;
      earringState[index] = { firstImg:null };
    }


     /* --- NEW: parse “X discs” in title or variations ------------------ */
     let discQty = 0;
     if (item.title) {
       const m = item.title.match(DISC_REGEX);
       if (m) discQty = Number(m[1]);
     }
     if (discQty === 0 && Array.isArray(item.variations)) {
       for (const v of item.variations) {
         const m = String(v?.formatted_value||"").match(DISC_REGEX);
         if (m) { discQty = Number(m[1]); break; }
       }
     }
     item.discCount = discQty;   // 0 when absent

    /* --- POSITION CALCULATIONS (unchanged from your file) -------- */
    const row  = Math.floor(index / 9);
    const col  = index % 9;
    const previewLeft = col * 125;
    const previewTop  = row * 165;

    /* --- build preview box + the 5 detail rows ------------------- */
    const previewBox = document.createElement("div");
    previewBox.classList.add("preview-box");
    previewBox.id = "previewCell" + index;
    previewBox.style.position = "absolute";
    previewBox.style.left   = previewLeft + "px";
    previewBox.style.top    = previewTop  + "px";
    previewBox.style.width  = "110px";
    previewBox.style.height = "110px";
    previewBox.innerHTML = "Loading...";

    const orderInput = document.createElement("input");
    orderInput.type = "text";
    orderInput.readOnly = true;
    orderInput.id = "orderCell" + index;
    orderInput.classList.add("detail-box");
    orderInput.style.left = previewLeft + "px";
    orderInput.style.top  = previewTop  + 95 + "px";
    orderInput.value = item.receipt_id
      ? item.receipt_id
      : item.orderNumber || "No Order #";
    orderInput.style.fontWeight = "bold";

    const qtyInput = document.createElement("input");
    qtyInput.type  = "text";
    qtyInput.readOnly = true;
    qtyInput.id = "quantityCell" + index;
    qtyInput.classList.add("detail-box");
    qtyInput.style.left = previewLeft + "px";
    qtyInput.style.top  = previewTop  + 107 + "px";
    qtyInput.value = " Qty: " + (item.quantity != null ? item.quantity : 0);

    // bold Quantity if > 1
    {
      const qVal = Number(item.quantity ?? item.qty ?? 0);
      if (qVal > 1) {
        qtyInput.style.fontWeight = "bold";
      }
    }

    const metalInput = document.createElement("input");
    metalInput.type  = "text";
    metalInput.readOnly = true;
    metalInput.id = "metalCell" + index;
    metalInput.classList.add("detail-box");
    metalInput.style.left = previewLeft + "px";
    metalInput.style.top  = previewTop  + 119 + "px";
    let metalSel = "";
    if (item.variations && Array.isArray(item.variations)) {
      const acceptedMetalNames = [
        "metal","metal choice","metal - engraving",
        "metal colour","color","metal choice / engraving option",
        "metal choice / necklace length",
        // — NEW —
        "number of discs / metal","number of discs/metal",
        "metal/necklace length","metal/necklace length/engrave",
        "number of discs / metal"
      ];
      /* ── find the metal-choice variation ────────────────────────────────
         ① label contains “metal”, OR
         ② label starts with “color/colour”, OR
         ③ label matches our static whitelist, OR
         ④ (fallback) the value itself looks like a metal keyword         */
      
      let metalVar = item.variations.find(v => {
        const name = (v.formatted_name || "").trim().toLowerCase();
        return (
          name.includes("metal")                              ||
          name.startsWith("color") || name.startsWith("colour") ||
          acceptedMetalNames.includes(name)
        );
      });
      
      /* If no luck, scan values for metal words (catches weird combos like
         “Number of Discs / Metal3 discs • gold”)                          */
      if (!metalVar) {
        metalVar = item.variations.find(v => {
          const val = (v.formatted_value || "").toLowerCase();
          return /rose\s*gold|rosegold|rosefilled|gold\s*filled|goldfilled|\bgold\b|silv[ae]?r|sterling\s*silver|14k|white\s*gold/.test(val);
        });
      }

      if (metalVar && metalVar.formatted_value) {
        metalSel = metalVar.formatted_value;

        /* ── strip engraving/character-count flags ───────────────────── */
        metalSel = metalSel
          /* +engraving / + Engrave (any case, with/without spaces) */
          .replace(/\+\s*engraving/gi, "")
          .replace(/\+\s*engrave/gi, "")
          /* 1-5 Characters | 6-10 Characters | 11+ Characters | 11 + Characters */
          .replace(/\b1-5\s*Characters\b/gi, "")
          .replace(/\b6-10\s*Characters\b/gi, "")
          .replace(/\b11\s*\+\s*Characters\b/gi, "")

          /* ·-delimited variants — 1-5·Character etc. */
          .replace(/\b1-5\s*·\s*Character(?:s)?\b/gi, "")
          .replace(/\b6-10\s*·\s*Character(?:s)?\b/gi, "")
          .replace(/\b11\+\s*·\s*Character(?:s)?\b/gi, "")

          /* collapse leftover double spaces */
          .replace(/\s{2,}/g, " ")
          .trim();


          /* ── NEW: yank out length junk & lock onto the metal ── */
        // 1) split camelCase so “LengthRose” → “Length Rose”
        metalSel = metalSel.replace(/([a-z])([A-Z])/g, "$1 $2");

        // 2) drop “Necklace Length”, trailing sizes like “- 20”, etc.
        metalSel = metalSel
          .replace(/\bnecklace\s*length\b[\s\/:]*/gi, "")
          .replace(/\s*-\s*\d+(\.\d+)?\s*$/g, "")
          .trim();

        /* normalise odd punctuation such as middle-dots, then lower-case */
        metalSel = metalSel.replace(/[·•]/g, " ").trim();
        const norm = metalSel.toLowerCase();

        /* — ROSE GOLD — catch plain, filled, or 14 K variants */
        if (/(?:14k\s*)?(?:rose\s*gold|rosegold|rose\s*gold\s*filled|rosegold\s*filled|rosefilled)\b/.test(norm)) {
          metalSel = "Rose Gold";

        /* — GOLD FILLED — plain or 14 K */
        } else if (/(?:14k\s*)?(?:gold\s*filled|goldfilled)\b/.test(norm)) {
          metalSel = "Gold Filled";

        /* — SILVER — plain or “Color Sterling Silver” spellings */
        } else if (/(?:color\s*)?sterling\s*silver\b|silv[ae]?r\b/.test(norm)) {
          metalSel = "Silver";

        /* — stand-alone 14 K (if it wasn’t part of a filled/rose match) */
        } else if (/\b14k\b/.test(norm)) {
          metalSel = "14K";

        /* — lone “gold” defaults to Gold Filled */
        } else if (/\bgold\b/.test(norm)) {
          metalSel = "Gold Filled";
        }

        /* tidy any doubles again */
        metalSel = metalSel.replace(/\s{2,}/g, " ").trim();
      }
    }
    metalInput.value = " Metal: " + (metalSel || "No Metal");

    // highlight Metal line if this order has a note
    {
      const rKey    = String(item.receipt_id || item.orderNumber);
      const noteTxt = (window.customerNotesMap && window.customerNotesMap[rKey])?.trim();
      if (noteTxt) {
        metalInput.style.fontWeight = "bold";
        metalInput.style.color      = "#008B8B"; // dark cyan
        metalInput.dataset.hasNote  = "1";
      }
    }

    const matchInput = document.createElement("input");
    matchInput.type  = "text";
    matchInput.readOnly = true;
    matchInput.id = "matchCell" + index;
    matchInput.classList.add("detail-box");
    matchInput.style.left = previewLeft + "px";
    matchInput.style.top  = previewTop  + 131 + "px";
    matchInput.value = "";

    /* --- add boxes to container ---------------------------------- */
    container.appendChild(previewBox);
    container.appendChild(orderInput);
    container.appendChild(qtyInput);
    container.appendChild(metalInput);
    container.appendChild(matchInput);

/* --- fetch & display listing image (match design.html) -------- */
fetchListingImages(item.listing_id)
  .then(imgs => {
    const first = Array.isArray(imgs) ? imgs[0] : null;
    const u = first?.url_fullxfull
           || first?.url
           || first?.image_url
           || first?.fullsize_url
           || first?.src
           || null;
    if (!u) throw new Error("no-image");
    return getLocalImageData(u);  // go through imageProxy to avoid CORS
  })
  .then(dataUrl => {
    previewBox.innerHTML =
      `<img src="${dataUrl}" alt="Listing ${item.listing_id}"
            data-scale="1" data-offsetX="0" data-offsetY="0" />`;
    attachPreviewBoxListeners(previewBox);
  })
  .catch(e => {
    console.warn("Image load issue:", e);
    previewBox.textContent = "No image";
  });
  });  // end items.forEach
}  // ← end fillPreviewBoxes

    function attachPreviewBoxListeners(box) {
      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0,
        dragStartY = 0;
      let lastX = 0,
        lastY = 0;
      const dragThreshold = 3;

      box.addEventListener("wheel", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        if (ev.deltaY < 0) {
          currentScale *= 1.1;
        } else {
          currentScale /= 1.1;
          if (currentScale <= 1) {
            currentScale = 1;
            offX = 0;
            offY = 0;
          }
        }
        if (currentScale > 8) currentScale = 8;
        img.dataset.scale = currentScale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `translate(${offX}px, ${offY}px) scale(${currentScale})`;
      });

      box.addEventListener("mousedown", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX;
        dragStartY = ev.clientY;
        lastX = ev.clientX;
        lastY = ev.clientY;
      });

      box.addEventListener("mousemove", function (ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        offX += dx;
        offY += dy;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `translate(${offX}px, ${offY}px) scale(${scaleNow})`;
        lastX = ev.clientX;
        lastY = ev.clientY;
      });

      box.addEventListener("mouseup", function () {
        isMouseDown = false;
      });
      box.addEventListener("mouseleave", function () {
        isMouseDown = false;
      });

      box.addEventListener("click", function (ev) {
        if (isDragging) {
          isDragging = false;
          return;
        }
        const img = box.querySelector("img");
        if (!img) return;
        const rect = box.getBoundingClientRect();
        const boxCenterX = rect.left + box.clientWidth / 2;
        const boxCenterY = rect.top + box.clientHeight / 2;
        const dx = ev.clientX - boxCenterX;
        const dy = ev.clientY - boxCenterY;
        const scale = 5;
        const fudgeY = 10;
        const offsetX = -scale * dx;
        const offsetY = -scale * dy + fudgeY;
        img.dataset.scale = scale;
        img.dataset.offsetX = offsetX;
        img.dataset.offsetY = offsetY;
        img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      });
    }

    /********************************************************
     * cropAllImages ‑‑ crop ONLY the Etsy‑grid preview boxes
     ********************************************************/
    async function cropAllImages() {
      /*  Grab boxes strictly inside the main grid container
          so we ignore unmatched‑preview thumbnails.           */
      const previewBoxes = document.querySelectorAll(
        "#photoGridContainer .preview-box"
      );

      for (let i = 0; i < previewBoxes.length; i++) {
        const cell = previewBoxes[i];
        const img  = cell.querySelector("img");
        if (img && img.src && img.src !== "") {
          try {
            const cropped = await cropImageFromPreview(cell, 320, 320);
            croppedImagesArray[i] = cropped;
            M.toast({ html: "Cell " + i + ": Cropped successfully." });
          } catch (err) {
            console.error("Cropping failed for cell", i, err);
            M.toast({ html: "Cell " + i + ": Cropping error" });
          }
        }
      }
    }

    function cropImageFromPreview(cell, canvasWidth, canvasHeight) {
      return new Promise((resolve, reject) => {
        const imgElem = cell.querySelector("img");
        if (!imgElem) {
          reject("No image element found");
          return;
        }

        const cellRect = cell.getBoundingClientRect();
        const imgRect = imgElem.getBoundingClientRect();

        const visibleLeft = Math.max(cellRect.left, imgRect.left);
        const visibleTop = Math.max(cellRect.top, imgRect.top);
        const visibleRight = Math.min(cellRect.right, imgRect.right);
        const visibleBottom = Math.min(cellRect.bottom, imgRect.bottom);

        if (visibleRight <= visibleLeft || visibleBottom <= visibleTop) {
          reject("No visible intersection");
          return;
        }

        const visibleWidth = visibleRight - visibleLeft;
        const visibleHeight = visibleBottom - visibleTop;

        const sourceImage = new Image();
        sourceImage.crossOrigin = "Anonymous";
        sourceImage.onload = function () {
          const ratioX = sourceImage.naturalWidth / imgRect.width;
          const ratioY = sourceImage.naturalHeight / imgRect.height;

          const srcX = (visibleLeft - imgRect.left) * ratioX;
          const srcY = (visibleTop - imgRect.top) * ratioY;
          const srcWidth = visibleWidth * ratioX;
          const srcHeight = visibleHeight * ratioY;

          const canvas = document.createElement("canvas");
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(
            sourceImage,
            srcX,
            srcY,
            srcWidth,
            srcHeight,
            0,
            0,
            canvasWidth,
            canvasHeight
          );
          resolve(canvas.toDataURL());
        };
        sourceImage.onerror = function (e) {
          reject(e);
        };
        sourceImage.src = imgElem.src;
      });
    }

/********************************************************
 * loadBatchEtsyOrders, fetchListingImages, getLocalImageData
 ********************************************************/

async function loadBatchEtsyOrders(orderNumbers) {
  try {
    M.toast({ html: "Loading " + orderNumbers.length + " order(s)..." });
    const token = localStorage.getItem("access_token") || "";
    let combinedItems = [];

    for (let i = 0; i < orderNumbers.length; i++) {
      const ord = orderNumbers[i];
      const url = functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(ord);
      const resp = await fetch(url, { headers: { "access-token": token } });
      if (!resp.ok) {
        console.warn("Order fetch failed for " + ord + ", status=" + resp.status);
        continue;
      }

      const data = await resp.json();
      // ▼▼ build & cache *all* customer notes (buyer note + gift + personalisation) ▼▼
      window.customerNotesMap = window.customerNotesMap || {};

      const notesParts = [];

      // 1) checkout note
      if (data.message_from_buyer) notesParts.push(data.message_from_buyer.trim());

      // 2) gift-wrap message (optional)
      if (data.gift_message) notesParts.push(data.gift_message.trim());

      // 3) item-level personalisation
      if (Array.isArray(data.transactions)) {
        data.transactions.forEach(tr => {
          // explicit field
          if (tr.personalization && tr.personalization.trim() &&
              tr.personalization.trim() !== "Not requested on this item.") {
            notesParts.push(tr.personalization.trim());
          }
          // variation called “Personalization”
          if (Array.isArray(tr.variations)) {
            tr.variations.forEach(v => {
              if ((v.formatted_name || "").trim().toLowerCase() === "personalization") {
                const val = (v.formatted_value || "").trim();
                if (val && val !== "Not requested on this item.") notesParts.push(val);
              }
            });
          }
        });
      }

      // ensure global notes map exists (run once before assigning)
      window.customerNotesMap = window.customerNotesMap || {};
      // key by receipt_id so it lines up with <input id="orderCellX">
      const receiptKey = data.receipt_id || ord;
      window.customerNotesMap[receiptKey] = notesParts.join(" | ");
      // ▲▲ done ▲▲
      console.log("Etsy Order Data:", data);

      // -- NEW CODE: attach the typed order # to each transaction --
      if (data.transactions && Array.isArray(data.transactions)) {
        data.transactions.forEach((t) => {
          t.typedOrderNumber = ord;
        });
      } else {
        console.warn("No transactions for order " + ord);
      }

      // ------------------------------------------------
      // APPLY THE SAME METHODOLOGY AS index.html
      // ------------------------------------------------
      if (data.transactions && data.transactions.length > 0) {
        const firstTrans = data.transactions[0];
        if (firstTrans.expected_ship_date) {
          // Convert from Unix to a nice, short date
          const sTS = new Date(firstTrans.expected_ship_date * 1000);
          const sDay = ("0" + sTS.getDate()).slice(-2);
          const monthNamesF = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
          const sMonth = monthNamesF[sTS.getMonth()];
          const sYear = sTS.getFullYear();

          // e.g. "25 Sep 2025"
          const formattedShipDate = sDay + " " + sMonth + " " + sYear;

          // Attach this to ALL transactions, so our code sees `t.dispatch_date`
          data.transactions.forEach((t) => {
            t.dispatch_date = formattedShipDate;
          });
        }
      }

      // If there’s an array of transactions, merge them in
      if (data.transactions && Array.isArray(data.transactions)) {
        combinedItems.push(...data.transactions);
      } else {
        console.warn("No transactions for order", ord);
      }
    }

      // Persist titles for prefilter: PARSED (lowercase, no punctuation, first 4 words)
      try {
        const titlesByCell = combinedItems.map(t => normalizeTitleForPrefilter(t?.title));
        localStorage.setItem("etsyTitlesByCell", JSON.stringify(titlesByCell));
      } catch (e) {
        console.warn("Failed to cache etsyTitlesByCell:", e);
      }
      // Then fill the UI with combined results
      await fillPreviewBoxes(combinedItems);

      attachMatchCellListeners();          // NEW

  } catch (err) {
    console.error("Error loading batch orders:", err);
    M.toast({ html: "Error: " + err.message });
  }
}

// Match design.html: token-safe, queued, cached image fetch
async function fetchListingImages(listingId) {
  const key = String(listingId);

  // 1) Serve from cache if we have it
  if (__imagesCache.has(key)) return __imagesCache.get(key);

  // 2) Share the same in-flight promise for duplicate callers
  if (__imagesFlight.has(key)) return __imagesFlight.get(key);

  // 3) Run inside the queue with built-in 429 tolerance via apiFetch
  const task = runImageTask(async () => {
    let attempt = 0;
    while (attempt < 5) {
      const resp = await apiFetch(`/etsyImages?listingId=${encodeURIComponent(key)}`);
      if (resp.status === 429) {
        const retryAfter = resp.headers?.get?.("retry-after");
        const raMs = Number.isFinite(Number(retryAfter)) ? Number(retryAfter) * 1000 : 0;
        const backoff = Math.max(raMs, 350 * Math.pow(2, attempt)); // 350, 700, 1400...
        await new Promise(r => setTimeout(r, backoff));
        attempt++;
        continue;
      }
      if (!resp.ok) {
        console.warn("Image fetch HTTP error:", resp.status);
        return [];
      }
      const data = await resp.json();
      const imgs = Array.isArray(data) ? data
                 : (data?.results || data?.images || data?.data || []);
      return imgs || [];
    }
    return [];
  });

  __imagesFlight.set(key, task);
  try {
    const results = await task;
    __imagesCache.set(key, results);
    return results;
  } finally {
    __imagesFlight.delete(key);
  }
}

async function getLocalImageData(imageUrl) {
  try {
    const response = await fetch(
      functionsBaseUrl + "/imageProxy?url=" + encodeURIComponent(imageUrl)
    );
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (err) {
    console.error("Error in getLocalImageData:", err);
    throw err;
  }
}

/********************************************************
 * compareImages, sendAndMatch, partialMatches, etc.
 ********************************************************/
async function compareImages(userImage, croppedGridImage, cellIndex, userImageName, signal = undefined) {
  // NEW: create an AbortController for this fetch
  const controller = new AbortController();
  pendingFetchControllers.push(controller);

  const payload = {
    model: "gpt-5",
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text:
              "Given two images that each contain a single jewelry charm or pendant, return ONE numeric similarity score between 0.0000 and 1.0000 (exactly four decimal places, no other text)." +
              "1. Isolate the charm: ignore all near-black, near-white, or low-saturation background pixels plus chains, hoops, rings, clothing, or skin. Work only on the pixels belonging to the charm itself." +
              "2. Normalize: scale, center, and rotate the cropped charm so its longest axis is horizontal before comparison." +
              "3. ShapeScore: compare overall outline, silhouette, and any interior cut-outs or holes." +
              "4. EngravingScore: compare engraving presence, design, size, position, and orientation." +
              "5. TypeScore: categorize by charm type and compare the style and type of charm, Example: Dog, Cat, Bird, Airplane, Mountain etc.." +
              "5. Animal special-case: when the charm depicts an animal, explicitly match head, eye, beak/mouth, ear, limb, and wing positions and proportions inside ShapeScore." +
              "6. Combine scores: Similarity = 0.5 × ShapeScore + 0.3 × EngravingScore + 0.2 x TypeScore" +
              "7. Confidence gate: if Similarity < 0.7000 after calculation, output 0.0000." +
              "8. Output **ONLY** the final Similarity value (e.g., `0.8732`)." 

          },
          { type: "image_url", image_url: { url: userImage, detail: "high" } },
          { type: "image_url", image_url: { url: croppedGridImage, detail: "high" } },
        ],
      },
    ],
    max_tokens: 50,
  };

  try {
    const response = await fetch(functionsBaseUrl + "/openaiProxy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: controller.signal               // NEW
    });
    if (!response.ok) {
      throw new Error("OpenAI compareImages call failed with " + response.status);
    }
    const data = await response.json();

    let similarityText = data.choices[0].message.content.trim();
    similarityText = similarityText.replace(/[^\d.]/g, ""); // keep only digits & dots

    let score = parseFloat(similarityText);
    if (isNaN(score)) {
      score = 0.0;
    }
    return { score };
  } catch (err) {
    console.error("Error comparing images with OpenAI:", err);
    if (/429|rate.?limit/i.test(String(err?.message || err))) {
      noteRateLimit();     // <-- mark recent rate-limit so cooldown stretches briefly
    }
    return { score: 0.0 };
  }
}

/********************************************************
 * sendAndMatch with metal filter logic
 ********************************************************/
async function sendAndMatch() {
  // Ensure Etsy titles cache exists in parsed form (first 4 words, no punctuation)
  (function ensureTitlesCache(){
    try {
      const k = "etsyTitlesByCell";
      const items  = Array.isArray(window.cachedOrderItems) ? window.cachedOrderItems : [];
      const titles = items.map(it => normalizeTitleForPrefilter(it?.title));
      localStorage.setItem(k, JSON.stringify(titles));  // overwrite each run to stay fresh
    } catch (e) { console.warn("ensureTitlesCache failed:", e); }
  })();
  /* --- progress setup --- */
  let smDone  = 0;
  let smTotal = 0;
  showProgressModal("Matching Images... (First Pass)", 1);

 // Deduplicate userImagesArray by file name to prevent double-sending
  if (Array.isArray(userImagesArray) && userImagesArray.length) {
    const seen = new Set();
    userImagesArray = userImagesArray.filter(u => {
      const key = String((u && u.name) || "");
      if (!key || seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  /* — reset earring maps for this run — */
  earringState  = {};

  const runId = globalRunId;     // snapshot current run

  /* Purge any residual skipForCharm photos */
  userImagesArray = userImagesArray.filter(u => !u.skipForCharm);

  // Disable Match & Print at the start
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  matchPrintBtn.disabled = true;
  matchPrintBtn.style.opacity = "0.5";

  if (userImagesArray.length === 0) {
    M.toast({ html: "No user images available! Please drop user images first." });
    return;
  }
  if (!croppedImagesArray || croppedImagesArray.length === 0) {
    M.toast({ html: "No cropped grid images available! Please crop images first." });
    return;
  }

  // --------------------------------------------------
  // NEW HELPER: checks if a user image name is allowed
  // based on the 3rd read-only text box metal content.
  // --------------------------------------------------
  function metalFilterOk(metalVal, userName) {
    // Normalize
    const m = String(metalVal || "").toLowerCase();
    const base = String(userName || "").toLowerCase()
                  .replace(/\.(jpg|jpeg|png|webp)$/, "");
    const tag = base.split("_")[0];  // "gold" | "rosegold" | "silver" ...

    // User image tags (strict, prefix-based)
    const userIsRose   = (tag === "rosegold" || tag === "rose");
    const userIsGold   = (tag === "gold");        // excludes "rosegold"
    const userIsSilver = (tag === "silver");

    // Listing metal (treat 14K as Gold unless explicitly "rose gold")
    const listingIsRose   = /\brose\s*gold\b|\brosegold\b/.test(m);
    const listingIs14k    = /\b14\s*k(?:t|arat)?\b/.test(m) && !listingIsRose;
    const listingIsGold   = /\bgold\b/.test(m) && !listingIsRose;
    const listingIsSilver = /\bsilver\b|sterling/.test(m);

    if (listingIsRose)                 return userIsRose;     // Rose ↔ Rose only
    if (listingIs14k || listingIsGold) return userIsGold;     // 14K/Gold ↔ Gold only (never Rose)
    if (listingIsSilver)               return userIsSilver;   // Silver ↔ Silver only
    return true; // unknown listing metal → don’t block
  }

  // Title-word prefilter — require ≥1 *word* overlap between Matrix descriptor words (prefer 6-word tag) and the Etsy cell title
  function passesTitlePrefilter(cellIdx, userImgName) {
    let titlesArr = [];
    try { titlesArr = JSON.parse(localStorage.getItem("etsyTitlesByCell") || "[]"); } catch (_) {}
    const rawTitle = String(titlesArr[cellIdx] || "");  // already normalized (full title, no punctuation)
    const title    = rawTitle;    
    if (!title) return true; // no title → don't block

  const base = String(userImgName || "").replace(/\.(jpg|jpeg|png|webp)$/i, "");
  const words = descriptorWordsFor(base);
  if (!words.length) return true; // no descriptor → don't block

  const wordIn = (w) =>
    w && new RegExp(`\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}\\b`).test(title);
  const hitWord = words.find(wordIn) || "";
  const ok = Boolean(hitWord);
  console.debug("prefilter", { cellIdx, base, words, title: rawTitle, hitWord, ok });
  return ok;
  }

    // --- NEW: helpers to render names and to keep filling until have >= need ---
    function namesForCell(i){
      return (cellMatches[i] || [])
        .filter(m => m && m.userImage)
        .map(m => m.userName);
    }

    async function fillRemaining(i, compareTarget, matchBox){
      while (true){
        if (runId !== globalRunId) return;

        const need = expectedSlots(window.cachedOrderItems?.[i] || {});
        const have = (cellMatches[i]||[]).filter(m=>m && m.userImage).length;
        if (have >= need) break;

        const metalVal = document.getElementById("metalCell" + i).value || "";
        const pool = userImagesArray.filter(u =>
          !u.skipForCharm &&
          metalFilterOk(metalVal, u.name) &&
          passesTitlePrefilter(i, u.name) &&
          !matchedUserNames.has(u.name)
        );
        if (!pool.length) break;

       // Also visualize these extra pre-filtered candidates before sending
        (function renderFillList(){
          const titlesArr = JSON.parse(localStorage.getItem("etsyTitlesByCell") || "[]");
          const etsyTitle = titlesArr[i] || "";
          let sixMap = {};
          let twoMap = {};
          try { sixMap = JSON.parse(localStorage.getItem("matrixCharm6Words") || "{}"); } catch(_) {}
          try { twoMap = JSON.parse(localStorage.getItem("matrixCharm2Words") || "{}"); } catch(_) {}
          const tagOf = (nm) => {
            const key = String(nm).replace(/\.(jpg|jpeg|png|webp)$/i, "");
            return sixMap[key] || twoMap[key] || "";
          };
          const hitWord = (tag, title) => {
            const words = String(tag)
              .toLowerCase()
              .replace(/[^a-z0-9-\s]/g, " ")
              .replace(/\s+/g, " ")
              .trim()
              .split(" ")
              .filter(Boolean)
              .filter(w => w !== "charm");
            const wordIn = (w) => w && new RegExp(`\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&')}\\b`).test(String(title).toLowerCase());
            return words.find(wordIn) || "";
          };
          // Only add a new block header if this cell wasn't started in FIRST PASS (fallback safe)
          if (!document.getElementById("pf-cell-" + i)) pfStartCell(i, etsyTitle);
          pool.forEach(u => pfAddCandidate(i, u.name, tagOf(u.name), hitWord(tagOf(u.name), etsyTitle)));
          pfMarkSent(i, pool.length);
        })();

        const promises = pool.map((user, j) =>
          new Promise(resolve => {
            setTimeout(() => {
              if (runId !== globalRunId) return resolve({ result: { score: 0 }, user });
              compareImages(user.data, compareTarget, i, user.name)
                .then(result => resolve({ result, user }))
                .catch(() => resolve({ result: { score: 0 }, user }));
            }, j * 120);
          })
        );

        const results = await Promise.all(promises);
        if (runId !== globalRunId) return;

        results.sort((a,b) => b.result.score - a.result.score);
        if (!results.length || results[0].result.score === 0) break;

        const top    = results[0];
        const second = results[1] ? results[1].result.score : 0;
        const delta  = top.result.score - second;

        // Reuse the same acceptance logic for each slot
        if (top.result.score >= 0.8){
          if (!cellMatches[i]) cellMatches[i] = [];
          const nm = top.user.name.replace(/(\.jpg|\.png)$/i, "");
          cellMatches[i].push({ userName: nm, userImage: top.user.data, score: top.result.score });
          matchedUserNames.add(top.user.name);
          userImagesArray = userImagesArray.filter(u => u.name !== top.user.name);

          if (matchBox) matchBox.value = namesForCell(i).join(", ");
        } else {
          break;
        }
      }
    }

//---------------------------------------------------------------------
  // FIRST PASS
  //---------------------------------------------------------------------
  let unmatchedCells = [];
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (croppedImagesArray[i]) unmatchedCells.push(i);
  }

  smTotal += unmatchedCells.length;

  const matchedUserNames  = new Set();
  const matchedCellIndices = new Set();

  for (const i of unmatchedCells) {
    if (runId !== globalRunId) return;

     /* Skip only when fully satisfied */
     {
       const need = expectedSlots(window.cachedOrderItems?.[i] || {});
       const have = (cellMatches[i]||[]).filter(m=>m && m.userImage).length;
       if (have >= need) { /* Mark complete only when have >= need */
           {
             const need = expectedSlots(window.cachedOrderItems?.[i] || {});
             const have = (cellMatches[i]||[]).filter(m=>m && m.userImage).length;
             if (have >= need) matchedCellIndices.add(i);
           } continue; }
     }
    const matchBox = document.getElementById("matchCell" + i);
    const metalVal = document.getElementById("metalCell" + i).value || "";

    /* 🔥 Build the pre-filter list FIRST (skipForCharm + metal + title) */
    const validUserImages = userImagesArray.filter(
      (u) =>
        !u.skipForCharm &&
        metalFilterOk(metalVal, u.name) &&
        passesTitlePrefilter(i, u.name)
    );
    const titlesArr = JSON.parse(localStorage.getItem("etsyTitlesByCell") || "[]");
    const etsyTitle = titlesArr[i] || "";
    pfStartCell(i, etsyTitle);

  // Visualize every candidate that survived the pre-filter (before OpenAI calls)
  (function renderPrefilterList(valids){
    let sixMap = {};
    let twoMap = {};
    try { sixMap = JSON.parse(localStorage.getItem("matrixCharm6Words") || "{}"); } catch(_) {}
    try { twoMap = JSON.parse(localStorage.getItem("matrixCharm2Words") || "{}"); } catch(_) {}
    const tagOf = (nm) => {
      const key = String(nm).replace(/\.(jpg|jpeg|png|webp)$/i, "");
      return sixMap[key] || twoMap[key] || "";
    };
    const hitWord = (tag, title) => {
      const words = String(tag)
        .toLowerCase()
        .replace(/[^a-z0-9-\s]/g, " ")
        .replace(/\s+/g, " ")
        .trim()
        .split(" ")
        .filter(Boolean)
        .filter(w => w !== "charm");
      const wordIn = (w) => w && new RegExp(`\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g,'\\\\$&')}\\b`).test(String(title).toLowerCase());
      return words.find(wordIn) || "";
    };
    valids.forEach(u => {
      const tag = tagOf(u.name);
      pfAddCandidate(i, u.name, tag, hitWord(tag, etsyTitle));
    });
    pfMarkSent(i, valids.length);
  })(validUserImages);

    let firstImg = null;   // remembers first earring photo for this cell

    const comparisonPromises = validUserImages.map((user, j) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          if (runId !== globalRunId) return resolve({ result: { score: 0 }, user });
          if (matchedUserNames.has(user.name) || matchedCellIndices.has(i)) {
            return resolve({ result: { score: 0 }, user });
          }
          compareImages(
              user.data,
              firstImg ? firstImg : croppedImagesArray[i],
              i,
              user.name
            )
            .then((result) => resolve({ result, user }))
            .catch((err) => {
              console.error("First‑pass compare error:", i, user.name, err);
              resolve({ result: { score: 0 }, user });
            });
        }, j * 120);
      });
    });

    const results = await Promise.all(comparisonPromises);

    if (runId !== globalRunId) return;        // NEW guard right after await
    results.sort((a, b) => b.result.score - a.result.score);

    if (!results.length || results[0].result.score === 0) {
      M.toast({ html: `Cell ${i}: No valid matches in first pass.` });
    } else {
      const topCandidate = results[0];
      const topScore = topCandidate.result.score;
      const topScorePerc = (topScore * 100).toFixed(2);
      const matchName = topCandidate.user.name.replace(/(\.jpg|\.png)$/i, "");

    if (!matchedUserNames.has(topCandidate.user.name) &&
          ((cellMatches[i]||[]).filter(m=>m && m.userImage).length < expectedSlots(window.cachedOrderItems?.[i] || {})) ) {

        /* Pre‑computed values already in your loop */
        const secondScore = results[1] ? results[1].result.score : 0;
        const scoreDelta  = topScore - secondScore;

        /* ---------- branchA: score ≥ 0.95 ---------- */
        if (topScore >= 0.80) {
          if (matchBox) {
            matchBox.value        = matchName;
            matchBox.style.fontWeight = "400";
            matchBox.style.color  = "black";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          safePushMatch(i,{
            userName  : matchName,
            userImage : topCandidate.user.data,   // ← use topCandidate
            score     : topScore
          });
          matchedUserNames.add(topCandidate.user.name);

           /* Mark complete only when have >= need */
           {
             const need = expectedSlots(window.cachedOrderItems?.[i] || {});
             const have = (cellMatches[i]||[]).filter(m=>m && m.userImage).length;
             if (have >= need) matchedCellIndices.add(i);
           }
          userImagesArray = userImagesArray.filter(
            u => u.name !== topCandidate.user.name
          );

          const _mb = document.getElementById("matchCell" + i);
          if (_mb) {
            _mb.value = (cellMatches[i] || [])
              .filter(m => m && m.userImage)
              .map(m => m.userName)
              .join(", ");
          }

        }

        /* ==============================================================
           MIRROR‑PAIR LOGIC – runs for ANY accepted earring half
        ============================================================== */
        /* Only run when this order actually expects TWO slots          */
         const needSlots = expectedSlots(window.cachedOrderItems?.[i] || {});
         if (needSlots > 1 && earringCells[i] && cellMatches[i] && cellMatches[i].length === 1) {          
         const firstImgFixed = cellMatches[i][0].userImage;
          if (!earringState[i]) earringState[i] = {};
          earringState[i].firstImg = firstImgFixed;

          for (const cand of userImagesArray.slice()) {
            if (cand.skipForCharm) continue;
            if (!metalFilterOk(metalVal, cand.name)) continue;
            if (matchedUserNames.has(cand.name)) continue;
            if (!passesTitlePrefilter(i, cand.name)) continue; // 🔒 enforce title prefilter

            const { score: s1 } = await compareImages(cand.data, firstImgFixed, i, cand.name);
            const flipped       = await flipImageHorizontal(cand.data);
            const { score: s2 } = await compareImages(flipped, firstImgFixed, i, cand.name + "_mirror");
            const bestScore     = Math.max(s1, s2);
            if (bestScore < 0.88) continue;          // twin threshold

             const twinName = cand.name.replace(/(\.jpg|\.png)$/i, "");
             /* safe push — silently skips if we already have enough     */
             if (safePushMatch(i, { userName : twinName,
                                    userImage: cand.data,
                                    score    : bestScore })) {
               matchedUserNames.add(cand.name);   // record only if kept
             }

            /* Mark complete only when have >= need */
           {
             const need = expectedSlots(window.cachedOrderItems?.[i] || {});
             const have = (cellMatches[i]||[]).filter(m=>m && m.userImage).length;
             if (have >= need) matchedCellIndices.add(i);
           }

            userImagesArray = userImagesArray.filter(u => u.name !== cand.name);

            if (matchBox) matchBox.value += `, ${twinName}`;
            M.toast({ html: `Cell ${i}: Mirror match found ⇒ ${twinName}` });
            break;
          }
        }
      }   /* ← closes the !matchedUserNames / !matchedCellIndices wrapper */

        // NEW: fill any remaining slots sequentially for multi-qty items
        await fillRemaining(i, croppedImagesArray[i], document.getElementById("matchCell" + i));
          
        /* update Send&Match progress (first pass) */
        smDone++;
        updateProgressModal(smDone, smTotal);

        // adaptive cooldown scaled to how many candidates we just compared
        await adaptiveCooldown((validUserImages && validUserImages.length) || 1);
      }
    }

    // -----------------------------------------------------------------------
    // SECOND PASS — DISABLED (Aug 2025)
    // -----------------------------------------------------------------------

    // >>> Finalize immediately after First Pass (skip Second Pass entirely)
    {
      // A) mark borders
      for (let i = 0; i < croppedImagesArray.length; i++) {
        evaluateBorder(i);
      }

      // B) wire up click handlers
      attachMatchCellListeners();

      // C) done message
      M.toast({ html: "Finished matching (First Pass only)." });

      // D) enable/disable Match & Print depending on remaining incomplete cells
      if (runId !== globalRunId) return;
      const anyOrangered = detectAnyOrangered();
      if (!anyOrangered) {
        enableMatchPrintFlow();
      } else {
        disableMatchPrintFlow();
      }

      // E) close progress UI
      updateProgressModal(smTotal, smTotal);
      closeProgressModal();

      // F) rebuild unmatched preview and re-enable button
      if (typeof createUnmatchedUserImagesPreview === "function") {
        createUnmatchedUserImagesPreview();
      }
      enableSendMatch();

      // G) bail out so Second Pass is skipped
      return;
    }

  /* ---------- HIGHLIGHT unmatched cells ---------- */
  for (let i = 0; i < croppedImagesArray.length; i++) {
    evaluateBorder(i);
  }

/* call the helper once the second‑pass loop is done */
attachMatchCellListeners();

M.toast({ html: "Finished matching passes." });

if (runId !== globalRunId) return;   // NEW — abort if a newer run started

// (C) Re‑enable "Match & Print" ONLY if detectAnyOrangered() returns false
const anyOrangered = detectAnyOrangered();
if (!anyOrangered) {
  enableMatchPrintFlow();          // enables all 3 buttons
} else {
  disableMatchPrintFlow();         // keeps them disabled
}

/* -- Finished matching -- */
updateProgressModal(smTotal, smTotal);
closeProgressModal();

/* NEW 🔥  Build the unmatched preview NOW */
if (typeof createUnmatchedUserImagesPreview === "function") {
  createUnmatchedUserImagesPreview();
}

/* Re‑enable Send‑Match button for another run */
enableSendMatch();
}  // ← end of sendAndMatch()

/********************************************************
 * openMatchPreviewModal
 ********************************************************/
function openMatchPreviewModal(cellIndex) {
  parkSaveBtn();
  const modalElem = document.getElementById("matchesModal");
  const container = document.getElementById("matchesGridContainer");

  /* ——— clear previous unmatched wrapper so header doesn’t duplicate ——— */
  const oldWrapper = container.querySelector("#unmatchedWrapper");
  if (oldWrapper) oldWrapper.remove();

  container.innerHTML = "";

   /* --- Skip-matching UI (top-right) + relocated Save button --- */
   const skipWrapper = document.createElement("div");
   skipWrapper.style.position = "absolute";
   skipWrapper.style.top = "10px";
   skipWrapper.style.right = "15px";
   skipWrapper.style.display = "flex";
   skipWrapper.style.flexDirection = "column";
   skipWrapper.style.alignItems = "flex-end";
 
   // Grab existing Save button from footer and move it up here (avoid redeclaring const saveBtn)
   const saveBtnMove = document.getElementById("saveMatchesBtn");
   if (saveBtnMove) {
     saveBtnMove.style.position = "static";
     saveBtnMove.style.margin = "0";
   }
 
   const skipTitle = document.createElement("div");
   skipTitle.textContent = "Skip Matching:";
   skipTitle.style.fontWeight = "bold";
   skipTitle.style.fontSize = "0.7em";
   skipTitle.style.marginBottom = "5px";
 
   // Top bar: Save button 30px to the left of the title, vertically aligned
   const topBar = document.createElement("div");
   topBar.style.display = "flex";
   topBar.style.alignItems = "center";
   topBar.style.gap = "30px";              // ← exact 30px spacing
 
   if (saveBtnMove) topBar.appendChild(saveBtnMove);
   topBar.appendChild(skipTitle);
 
   skipWrapper.appendChild(topBar);
 
   // Hide the Cancel button (in case CSS didn’t catch it)
   const cancelBtn = modalElem.querySelector(".modal-close");
   if (cancelBtn) cancelBtn.style.display = "none";

  // --- Materialize checkbox wrapper ---
  const label = document.createElement("label");
  label.style.cursor = "pointer";
  label.style.display = "flex";
  label.style.alignItems = "center";

  const skipInput = document.createElement("input");
  skipInput.type  = "checkbox";
  skipInput.id    = "skipChk" + cellIndex;
  skipInput.classList.add("filled-in");   // renders visible box
  skipInput.checked = !!skipMatches[cellIndex];

  const chkSpan = document.createElement("span"); // draws square outline

  label.appendChild(skipInput);
  label.appendChild(chkSpan);
  skipWrapper.appendChild(label);

  container.appendChild(skipWrapper);

  /* ---------- build modal content (unchanged) ---------- */

  // === Matrix Image Search: use the EXACT same descriptor source as the prefilter panel ===
  const matrixSearch = document.getElementById("matrixSearchBox");
  if (matrixSearch) {
    matrixSearch.value = "";

    // Remove any previous handler when modal reopens
    if (matrixSearch._ms_handler) {
      matrixSearch.removeEventListener("input", matrixSearch._ms_handler);
    }

    function applyFilter(q) {
      const section =
        document.querySelector("#unmatchedWrapper .unmatched-scroller") ||
        document; // be defensive

      const tokens = String(q || "")
        .toLowerCase()
        .replace(/[^a-z0-9-\s]/g, " ")
        .trim()
        .split(/\s+/)
        .filter(Boolean);

      // Re-query every input so it works even if tiles are rebuilt
      const wrappers = section.querySelectorAll("[data-type='unmatched']");
      wrappers.forEach(w => {
        const base = w.dataset.base || ""; // set when building tiles
        // SAME source as prefilter panel:
        const hay = (descriptorWordsFor(base) || []).join(" ").toLowerCase();
        const ok = tokens.length === 0 || tokens.every(t => hay.includes(t));
        w.style.display = ok ? "" : "none";
      });
    }

    matrixSearch._ms_handler = (e) => applyFilter(e.target.value);
    matrixSearch.addEventListener("input", matrixSearch._ms_handler);

    // Optional: if the unmatched list is rebuilt dynamically, keep the current filter applied
    const sec = document.querySelector("#unmatchedWrapper .unmatched-scroller");
    if (sec && !sec._ms_observer) {
      sec._ms_observer = new MutationObserver(() => applyFilter(matrixSearch.value));
      sec._ms_observer.observe(sec, { childList: true });
    }

    // Show all initially
    applyFilter("");
  }


  // helper: create a 55×7 read‑only row that sits in normal flow
  function makeDetail(txt, isBold = false) {
    const row = document.createElement("div");
    row.textContent   = txt;
    row.style.width   = "100px";
    row.style.height  = "12px";
    row.style.fontSize = "0.6em";
    row.style.marginTop = "0px";          // 0px between rows
    row.style.fontWeight = isBold ? "700" : "400";
    row.style.overflow = "hidden";        // keeps long text inside 100px
    return row;
  }

  const etsyDerived = croppedImagesArray[cellIndex];
  const needSlots = expectedSlots(window.cachedOrderItems[cellIndex]);   // NEW

  /* ---------- build matchedImages sized to needSlots ---------- */
  let matchedImages = cellMatches[cellIndex]
    ? [...cellMatches[cellIndex]]
    : [];
  matchedImages = matchedImages.slice(0, needSlots);
  while (matchedImages.length < needSlots) {
    matchedImages.push({ userName:"", userImage:null, score:0 });
  }

  /* ---------- build unmatchedImages (exclude every matched name) ---------- */
  const matchedNames = matchedImages
    .filter(m => m.userName)                         // ignore placeholders
    .map(m => m.userName);

  let unmatchedImages = userImagesArray.filter((uImg) => {
    if (uImg.skipForCharm) return false;
    if (partialMatches[uImg.name]) return false;
    return !matchedNames.includes(stripExtension(uImg.name));
  });

  /* --- live grid values pulled from main screen --- */
  const orderVal = document.getElementById("orderCell"   + cellIndex)?.value || "";
  // ▼▼ populate Customer Notes field ▼▼
  const notesEl = document.getElementById("customerNotes");
  if (notesEl) {
    notesEl.value = window.customerNotesMap?.[orderVal] || "";
  }
  // ▲▲ populate Customer Notes ▲▲
  const qtyVal   = document.getElementById("quantityCell"+ cellIndex)?.value || "";
  const metalVal = document.getElementById("metalCell"   + cellIndex)?.value || "";

  // -----------------------------------------------------------------------
  // A) Etsy Photo
  // -----------------------------------------------------------------------
  const etsyWrapper = document.createElement("div");
  etsyWrapper.style.display = "flex";
  etsyWrapper.style.flexDirection = "column";
  etsyWrapper.style.marginBottom = "20px";
  etsyWrapper.style.gap = "3px";        // ⇠ 3px between every detail row

  const etsyLabel = document.createElement("div");
  etsyLabel.textContent = "Etsy Photo:";
  etsyLabel.style.fontWeight = "bold";
  etsyLabel.style.fontSize = "0.7em";
  etsyLabel.style.marginBottom = "7px";
  etsyWrapper.appendChild(etsyLabel);

  const etsyBox = document.createElement("div");
  etsyBox.style.width = "100px";
  etsyBox.style.height = "100px";
  etsyBox.style.border = "1px solid #000";
  etsyBox.style.overflow = "hidden";

  if (etsyDerived) {
    const etsyImg = document.createElement("img");
    etsyImg.src = etsyDerived;
    etsyImg.alt = `Etsy Photo for cell ${cellIndex}`;
    etsyImg.style.width = "100%";
    etsyImg.style.height = "100%";
    etsyImg.style.objectFit = "cover";
    etsyBox.appendChild(etsyImg);
  } else {
    etsyBox.innerHTML = "No Etsy Photo";
    etsyBox.style.display = "flex";
    etsyBox.style.alignItems = "center";
    etsyBox.style.justifyContent = "center";
    etsyBox.style.fontWeight = "bold";
  }
  etsyWrapper.appendChild(etsyBox);
  etsyBox.style.marginBottom = "0.5px";   // 0.5px space under the image
  container.appendChild(etsyWrapper);
   const orderRow = makeDetail(orderVal);           // Order number
   orderRow.style.fontSize = "0.9em";               // was 0.6em
   orderRow.style.height   = "16px";                // avoid clipping
   etsyWrapper.appendChild(orderRow);
   etsyBox.style.marginBottom = "0.5px";   // 0.5px space under the image
   const isQtyMulti = (window.cachedOrderItems[cellIndex]?.quantity ?? window.cachedOrderItems[cellIndex]?.qty ?? 1) > 1;
   const qtyRow = makeDetail(qtyVal, isQtyMulti);           // Qty
   qtyRow.style.fontSize = "0.9em";   // match order number size
   qtyRow.style.height   = "16px";    // avoid clipping
   etsyWrapper.appendChild(qtyRow);
   const metalRow = makeDetail(metalVal, true);          // Metal
   metalRow.style.fontSize = "0.9em";    // match order number size
   metalRow.style.height   = "16px";
   etsyWrapper.appendChild(metalRow);

  // -----------------------------------------------------------------------
  // B) Matched Photo (shifted 75px right)   ← UPDATED BLOCK
  // -----------------------------------------------------------------------
  const matchedWrapper = document.createElement("div");
  matchedWrapper.style.display = "flex";
  matchedWrapper.style.flexDirection = "column";
  matchedWrapper.style.marginBottom = "20px";
  matchedWrapper.style.marginLeft = "75px";

  const matchedTitle = document.createElement("div");
  matchedTitle.textContent   = "Matched User Photo:";
  matchedTitle.style.fontWeight = "bold";
  matchedTitle.style.fontSize  = "0.7em";
  matchedTitle.style.marginBottom = "7px";
  matchedWrapper.appendChild(matchedTitle);

  /* ---------- build a fixed set of slots ---------- */
  const maxSlots = needSlots;
  const matchedSection = document.createElement("div");
  matchedSection.style.display      = "flex";
  matchedSection.style.flexWrap     = "wrap";
  matchedSection.style.gap          = "10px";
  /* NEW: cap the row at 5 × 100px + 4 × 10px gap = 540px */
  matchedSection.style.maxWidth     = "540px";
  /* keep items left‑aligned so they start a fresh line neatly */
  matchedSection.style.alignContent = "flex-start";

  /* helper: plain filename row, optional bold (matches makeDetail) */
  function makeNameRow(text, pxWidth, isBold = false) {
    const row = document.createElement("div");
    row.textContent   = text;
    row.style.width   = pxWidth + "px";
    row.style.fontSize = "0.6em";
    row.style.lineHeight = "1.2em";
    row.style.marginTop  = "3px";
    row.style.textAlign  = "center";
    row.style.color      = "#000";
    row.style.overflow   = "hidden";
    row.style.textOverflow = "ellipsis";
    row.style.whiteSpace = "nowrap";
    row.style.setProperty("font-weight", isBold ? "700" : "400", "important"); // ← forces bold

    return row;
  }

  /* ============================================================
   * helper: create one 100×100 matched slot + filename row
   * ========================================================== */
  function addMatchedBox(slot, imgData, userName) {
    /* wrapper = image + name */
    const wrapper = document.createElement("div");
    wrapper.style.display = "flex";
    wrapper.style.flexDirection = "column";
    wrapper.style.alignItems = "center";
    wrapper.style.width = "100px";
    wrapper.style.order = slot;
    wrapper.dataset.slot = slot;

    /* 100×100 image box */
    const box = document.createElement("div");
    box.className = "match-box";
    box.dataset.cell = cellIndex;
    box.dataset.slot = slot;
    box.style.width  = "100px";
    box.style.height = "100px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";

    const img = document.createElement("img");
    img.draggable = true;
    img.dataset.cell = cellIndex;
    img.dataset.slot = slot;
    img.addEventListener("dragstart", handleDragStart);

    if (imgData) {
      img.src   = imgData;
      img.title = userName;
    } else {
      img.src   = "placeholder.png";
      img.classList.add("placeholder");
    }

    box.appendChild(img);
    wrapper.appendChild(box);

    /* filename row (plain text, 100px wide) */
    const nameRow = makeNameRow(userName || "", 100, true);   // bold = true
    nameRow.style.setProperty("font-weight", "700", "important");  // always bold
    wrapper.appendChild(nameRow);

    matchedSection.appendChild(wrapper);
  }

  /* existing matches */
  matchedImages.forEach((m, k) => addMatchedBox(k, m.userImage, m.userName));

  /* ensure all slots exist */
  for (let s = matchedImages.length; s < maxSlots; s++) {
    addMatchedBox(s, null, "");
  }

  /* pad with empty slots if still short */
  for (let s = matchedImages.length; s < maxSlots; s++) {
    addMatchedBox(s, null, "");
  }

  matchedWrapper.appendChild(matchedSection);
container.appendChild(matchedWrapper);       // ← keep this line

  // -----------------------------------------------------------------------
  // C) Unmatched Photos (shifted 75px right)
  // -----------------------------------------------------------------------
  const unmatchedWrapper = document.createElement("div");
  unmatchedWrapper.id = "unmatchedWrapper";        // ← add this line
  unmatchedWrapper.style.display = "flex";
  unmatchedWrapper.style.flexDirection = "column";
  unmatchedWrapper.style.marginLeft = "187px"; // shift right

  const unmatchedTitle = document.createElement("div");
  unmatchedTitle.textContent = "Unmatched User Photos:";
  unmatchedTitle.style.fontWeight = "bold";
  unmatchedTitle.style.fontSize = "0.7em";
  unmatchedTitle.style.marginBottom = "7px";
  unmatchedWrapper.appendChild(unmatchedTitle);

  const unmatchedSection = document.createElement("div");
  unmatchedSection.style.display = "flex";
  unmatchedSection.style.flexWrap = "wrap";
  unmatchedSection.style.gap = "5px";
  unmatchedSection.classList.add("unmatched-scroller");   // ← give it its own scroller

  /* -------------------------------------------------------------
   * Either one placeholder, or all unmatched images with filename
   * ----------------------------------------------------------- */
  if (unmatchedImages.length === 0) {
    // --- single placeholder box ---
    const box = document.createElement("div");
    box.style.width  = "66px";
    box.style.height = "66px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.dataset.type = "unmatchedEmpty";
    box.innerHTML = "No Unmatched Photos";
    box.style.fontWeight = "bold";
    box.style.fontSize  = "0.7em";

    makeDropTarget(box);               // allow drop into placeholder
    unmatchedSection.appendChild(box);

  } else {
    // Otherwise show each unmatched image normally
    unmatchedImages.forEach((uImg, idx) => {
      /* wrapper keeps 66×66 box + filename together */
      const wrapper = document.createElement("div");
      wrapper.style.display = "flex";
      wrapper.style.flexDirection = "column";
      wrapper.style.alignItems = "center";
      wrapper.style.width = "66px";
      wrapper.dataset.type  = "unmatched";
      wrapper.dataset.index = idx;
      // Store base filename (no extension) for search lookups
      const base = stripExtension(uImg.name || "");
      wrapper.dataset.base = base;

      /* 66×66 image box */
      const box = document.createElement("div");
      box.style.width  = "66px";
      box.style.height = "66px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";

      const img = document.createElement("img");
      img.src   = uImg.data;
      img.alt   = uImg.name;
      img.style.width  = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";

      makeDraggable(wrapper);
      makeDropTarget(wrapper);
      box.appendChild(img);
      wrapper.appendChild(box);

      /* filename row (plain text, 66px wide) */
      const nameRow = makeNameRow(stripExtension(uImg.name), 66);
      wrapper.appendChild(nameRow);

      unmatchedSection.appendChild(wrapper);
    });
  }  // ← closes the outer else‑branch

  unmatchedWrapper.appendChild(unmatchedSection);
  container.appendChild(unmatchedWrapper);

// -------------------------------------------------------------
  // 1) Initialize the modal (MaterializeCSS)
  // -------------------------------------------------------------
  const instance = M.Modal.init(modalElem);

  // -------------------------------------------------------------
  // 2) “Save” button merges arrays & closes modal
  // -------------------------------------------------------------
  const saveBtn = document.getElementById("saveMatchesBtn");

  // Remove the previously attached handler, if any
  if (saveBtn && currentSaveHandler) saveBtn.removeEventListener("click", currentSaveHandler);

  // Define a fresh handler for THIS modal instance
  currentSaveHandler = function () {

    window.currentCorrectedCellIndex = cellIndex;
    const matchBox = document.getElementById("matchCell" + cellIndex);

    /* ---------------- original Save logic ---------------- */
    // A) Overwrite cellMatches for this cellIndex
    cellMatches[cellIndex] = matchedImages;

    // B) Rebuild userImagesArray after any drag/drop changes
    const newUserArr = [...userImagesArray];

    //    1) remove matched images
    matchedImages.forEach((mImg) => {
      const idx = newUserArr.findIndex(
        (u) => stripExtension(u.name) === mImg.userName
      );
      if (idx >= 0) newUserArr.splice(idx, 1);
    });

    //    2) add newly unmatched images
    unmatchedImages.forEach((u) => {
      const dupIdx = newUserArr.findIndex((x) => x.name === u.name);
      if (dupIdx >= 0) newUserArr.splice(dupIdx, 1);
      newUserArr.push(u);
    });
    userImagesArray = newUserArr;

    // C) Refresh the 4th (match) text box  —— UPDATED
    if (matchBox) {
      matchBox.value = matchedImages
        .filter(m => m && m.userImage)
        .map(m => m.userName)
        .join(", ");

      const realCount = matchedImages.filter(m => m && m.userImage).length;
      const needed    = expectedSlots(window.cachedOrderItems[cellIndex]);

      if (realCount < needed) {                 // still incomplete
        if (!earringCells[cellIndex]) {         // << non‑earring rows: show orangered text
          matchBox.style.fontWeight = "bold";
          matchBox.style.color      = "orangered";
        } else {                                // << earrings: leave text normal
          matchBox.style.fontWeight = "";
          matchBox.style.color      = "";
        }
      } else {                                  // requirement met
        matchBox.style.fontWeight = "";
        matchBox.style.color      = "";
      }
    }

    // D) Update border colour  —— UPDATED
    evaluateBorder(cellIndex);                       // unified border logic

    /*****  NEW – persist Skip status & set border  *****/
    const skipChecked = !!document.getElementById("skipChk" + cellIndex)?.checked;
    skipMatches[cellIndex] = skipChecked;
    toggleSkipBorder(cellIndex, skipChecked);   // green or revert

    // E) Refresh unmatched preview
    if (typeof createUnmatchedUserImagesPreview === "function") {
      createUnmatchedUserImagesPreview();
    }

    // F) Enable/disable Match‑&‑Print flow
    const anyOrangered = detectAnyOrangered();
    if (anyOrangered) {
      disableMatchPrintFlow();

      /***** hide blue highlights + Print button *****/
      hideMatchPrintUI();

    } else {
      enableMatchPrintFlow();
    }

    // G) Close the modal
    instance.close();
  };

  // Attach the fresh handler
  if (saveBtn) saveBtn.addEventListener("click", currentSaveHandler);

  // -------------------------------------------------------------
  // 3) Open the modal
  // -------------------------------------------------------------
  instance.open();

    // -------------------------------------------------------------
  // 4) DRAG & DROP HELPERS
  // -------------------------------------------------------------
  function makeDraggable(elem) {
    elem.setAttribute("draggable", true);
    elem.addEventListener("dragstart", (ev) => {
      ev.dataTransfer.setData(
        "text/plain",
        JSON.stringify({
          sourceType : elem.dataset.type,      // "matched" | "unmatched"
          sourceIndex: elem.dataset.index,     // index in its array
          slot       : elem.dataset.slot || null
        })
      );
    });
  }

  /* -------------------------------------------------------------
   * makeDropTarget  (re‑rev 2025‑04‑19)
   * – treats ANY element with class "match-box" as a matched target,
   *   even if data‑attributes weren’t set on first render
   * – fixes issue where 2nd slot ignored drops
   * ----------------------------------------------------------- */
  function makeDropTarget(elem) {
    elem.addEventListener("dragover", (ev) => ev.preventDefault());

    elem.addEventListener("drop", (ev) => {
      ev.preventDefault();
      const dataText = ev.dataTransfer.getData("text/plain");
      if (!dataText) return;

      let payload;
      try { payload = JSON.parse(dataText); } catch { return; }

      const sourceType  = payload.sourceType;            // "matched" | "unmatched"
      const sourceIndex = Number(payload.sourceIndex);   // origin index
      const targetType  = elem.dataset.type;             // may be undefined on first render
      const targetSlot  = Number(elem.dataset.slot);     // slot for matched boxes
      const isMatchedTarget =
        targetType === "matched" || elem.classList.contains("match-box");

      /* -------------------------------------------------
         A) matched  →  unmatched / unmatchedEmpty
         ------------------------------------------------- */
      if (
        sourceType === "matched" &&
        (targetType === "unmatched" || targetType === "unmatchedEmpty")
      ) {
        const mImg = matchedImages[sourceIndex];

        if (mImg && mImg.userImage) {
          unmatchedImages.push({
            name : mImg.userName + ".jpg",
            data : mImg.userImage,
            score: mImg.score || 0
          });
        }

        matchedImages[sourceIndex] = { userName:"", userImage:null, score:0 };
        refreshSectionsLocal();
        return;
      }

      /* -------------------------------------------------
         B) unmatched  →  matched  (slot‑specific)
         ------------------------------------------------- */
      if (sourceType === "unmatched" && isMatchedTarget) {
        const uImg = unmatchedImages[sourceIndex];
        const slot = isNaN(targetSlot) ? 0 : targetSlot;    // fallback to 0

        /* If slot already occupied, send existing back to unmatched */
        const existing = matchedImages[slot];
        if (existing && existing.userImage) {
          unmatchedImages.push({
            name : existing.userName + ".jpg",
            data : existing.userImage,
            score: existing.score || 0
          });
        }

        matchedImages[slot] = {
          userName : stripExtension(uImg.name),
          userImage: uImg.data,
          score    : 0
        };

        unmatchedImages.splice(sourceIndex, 1);
        refreshSectionsLocal();
      }
    });
  }

  function refreshSectionsLocal() {
    /* ---------------- Matched Section ---------------- */
    matchedSection.innerHTML = "";

    matchedImages.forEach((mImg, i) => {
      /* wrapper keeps 100×100 box + filename together */
      const wrap = document.createElement("div");
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.alignItems = "center";
      wrap.style.width = "100px";
      wrap.style.order = i;

      /* 100×100 image box = actual drag/drop target */
      const box = document.createElement("div");
      box.className  = "match-box";
      box.dataset.type  = "matched";
      box.dataset.index = i;
      box.dataset.slot  = i;            // ★ restore slot id
      box.style.width  = "100px";
      box.style.height = "100px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";

      makeDraggable(box);
      makeDropTarget(box);

      if (!mImg.userImage) {
        box.innerHTML = "No Match Found";
        box.style.fontWeight = "bold";
      } else {
        const img = document.createElement("img");
        img.src  = mImg.userImage;
        img.alt  = mImg.userName;
        img.style.width  = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";
        box.appendChild(img);
      }

      wrap.appendChild(box);

      /* filename row */
      const nameRow = makeNameRow(mImg.userName || "", 100, true);   // bold = true
      wrap.appendChild(nameRow);

      matchedSection.appendChild(wrap);
    });

    /* ---------- Unmatched wrapper (create once, then reuse) ---------- */
    let unmatchedWrapper = container.querySelector("#unmatchedWrapper");

    if (!unmatchedWrapper) {
      /* build it the FIRST time only */
      unmatchedWrapper = document.createElement("div");
      unmatchedWrapper.id               = "unmatchedWrapper";
      unmatchedWrapper.style.display       = "flex";
      unmatchedWrapper.style.flexDirection = "column";
      unmatchedWrapper.style.marginLeft    = "187px";           // same offset

      /* header */
      const unTitle = document.createElement("div");
      unTitle.textContent      = "Unmatched User Photos:";
      unTitle.style.fontWeight = "bold";
      unTitle.style.fontSize   = "0.7em";
      unTitle.style.marginBottom = "7px";
      unmatchedWrapper.appendChild(unTitle);

      /* flex grid container */
      unmatchedSection.style.display  = "flex";
      unmatchedSection.style.flexWrap = "wrap";
      unmatchedSection.style.gap      = "10px";
      unmatchedSection.classList.add("unmatched-scroller");   // ensure scroller on reuse too
      unmatchedWrapper.appendChild(unmatchedSection);

      /* attach once */
      container.appendChild(unmatchedWrapper);
    }

    /* always clear the grid before repopulating */
    unmatchedSection.innerHTML = "";

    /* ---------------- Unmatched Section ---------------- */
    unmatchedSection.innerHTML = "";

    if (unmatchedImages.length === 0) {
      /* one placeholder when none left */
      const box = document.createElement("div");
      box.dataset.type = "unmatchedEmpty";
      box.style.width  = "66px";
      box.style.height = "66px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.fontWeight = "bold";
      box.style.fontSize  = "0.7em";
      box.innerHTML = "No Unmatched Photos";
      makeDropTarget(box);
      unmatchedSection.appendChild(box);
    } else {
      unmatchedImages.forEach((uImg, i) => {
        const box = document.createElement("div");
        box.dataset.type  = "unmatched";
        box.dataset.index = i;
        box.style.width  = "66px";
        box.style.height = "66px";
        box.style.border = "1px solid #000";
        box.style.display = "flex";
        box.style.alignItems = "center";
        box.style.justifyContent = "center";
        box.style.overflow = "hidden";
        box.style.position = "relative";

        const img = document.createElement("img");
        img.src   = uImg.data;
        img.alt   = uImg.name;
        img.style.width  = "100%";
        img.style.height = "100%";
        img.style.objectFit = "cover";

        makeDraggable(box);
        makeDropTarget(box);
        box.appendChild(img);
        unmatchedSection.appendChild(box);
      });
    }
  }

 // Utility: set the Etsy-derived preview box border
 function setEtsyBorder(cellIdx, thickness, color) {
   const previewBox = document.getElementById("previewCell" + cellIdx);
   if (previewBox) {
     previewBox.style.border = thickness + " solid " + color;
   }
 }

 // Another Utility
 function stripExtension(fileName) {
   return fileName.replace(/\.\w+$/, "");
 }

 // Finally, ensure immediate drag-and-drop by calling refreshSectionsLocal
 refreshSectionsLocal();
}

/********************************************************
 * The createUnmatchedUserImagesPreview function
 ********************************************************/
function createUnmatchedUserImagesPreview() {
  const unmatchedContainer = document.getElementById("unmatchedContainer");
  if (!unmatchedContainer) return;
  unmatchedContainer.innerHTML = ""; // Clear old previews

  /* 🔥 Exclude both partial matches **and** any flagged “no‑charm” photos */
  const trulyUnmatchedImages = userImagesArray.filter(userImg => {
    return !userImg.skipForCharm && !partialMatches[userImg.name];
  });

  // 2) Spacing: 66px box width + 5px gap = 71px total step horizontally & vertically
  const imagesPerRow = 3;
  const boxSize = 66;
  const gap = 5;
  const step = boxSize + gap; // = 71

  // 3) Create 66×66 previews for these leftover images
  trulyUnmatchedImages.forEach((userImg, i) => {
    const row = Math.floor(i / imagesPerRow);
    const col = i % imagesPerRow;
    const leftPx = col * step;
    const topPx  = row * step;

    const previewBox = document.createElement("div");
    previewBox.classList.add("preview-box");
    previewBox.style.position = "absolute";
    previewBox.style.left = leftPx + "px";
    previewBox.style.top  = topPx  + "px";
    previewBox.style.width  = boxSize + "px";
    previewBox.style.height = boxSize + "px";

    // Insert the unmatched user image
    previewBox.innerHTML = `
      <img src="${userImg.data}"
           alt="${userImg.name}"
           data-scale="1"
           data-offsetX="0"
           data-offsetY="0"
           style="width:100%; height:100%; object-fit:cover;" />
    `;

    attachPreviewBoxListeners(previewBox);
    unmatchedContainer.appendChild(previewBox);
  });
}
    
    // ---------------------------------------------------------
    // Pull Etsy order details and update grid details
    // ---------------------------------------------------------
    function pullEtsyOrderDetails(orderNumber) {
      console.log("Pulling Etsy order details for order number:", orderNumber);
      var token = localStorage.getItem("access_token");
      return fetch(functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(orderNumber), {
        headers: { "access-token": token }
      })
      .then(function(r) { return r.json(); })
      .then(function(data) {
        console.log("Etsy Order Data:", data);
        return data;
      })
      .catch(function(err) {
        console.error("Error fetching Etsy order details:", err);
        return null;
      });
    }
    
    // Example: update the grid details using pulled Etsy order details
    async function updateImageGrid(data) {
      let items = [];
      if (data.transactions && Array.isArray(data.transactions)) {
        items = data.transactions;
      } else if (Array.isArray(data)) {          
        items = data;
      }
      window.cachedOrderItems = items;
      await fillPreviewBoxes(items);
      // Re-apply any active search after grid rebuild
      if (typeof window.applyOrderSearchFilter === "function") {
        const v = document.getElementById("orderSearchBox")?.value || "";
        window.applyOrderSearchFilter(v);
      }
    }

/* ────────────────────────────────────────────────────────────────────
   Live Etsy Title Search → filters & reflows grid on every keystroke
   ─ uses same layout constants as the builder (cols=9, stepX=125, stepY=165)
   ─ rearranges visible cells sequentially so there are NO gaps
   ──────────────────────────────────────────────────────────────────── */
(function attachLiveSearch(){
  const input = document.getElementById("orderSearchBox");
  if (!input) return;

  // public so updateImageGrid can re-apply after rebuilds
  window.applyOrderSearchFilter = function(q){
    const query = String(q||"").trim().toLowerCase();
    const items = Array.isArray(window.cachedOrderItems) ? window.cachedOrderItems : [];
    const filterIncomplete = !!window.filterIncompleteOnly;

    const COLS  = 9;
    const STEPX = 125, STEPY = 165;
    const rowOffsets = { order:95, qty:107, metal:119, match:131 };
    const ids = ["previewCell","orderCell","quantityCell","metalCell","matchCell"];

    let k = 0; // next visible slot
    for (let i=0; i<items.length; i++){
      const title = String(items[i]?.title || "").toLowerCase();
      const titleHit = !query || title.includes(query);

      // Incomplete if real matches < needed slots
      const needed = expectedSlots(items[i] || {});
      const have   = (cellMatches[i] || []).filter(m => m && m.userImage).length;
      const incompleteHit = have < needed;   // includes "no match at all"

      const hit = titleHit && (!filterIncomplete || incompleteHit);

      // show/hide the 5 pieces for this index
      for (const pre of ids){
        const el = document.getElementById(pre + i);
        if (el) el.style.display = hit ? "" : "none";
      }
      if (!hit) continue;

      // sequential reflow with no gaps
      const row = Math.floor(k / COLS), col = k % COLS;
      const left = col * STEPX, top = row * STEPY;
      const setPos = (elemId, l, t) => {
        const e = document.getElementById(elemId);
        if (e){ e.style.left = l + "px"; e.style.top = t + "px"; }
      };

      setPos("previewCell"+i,  left, top);
      setPos("orderCell"+i,    left, top + rowOffsets.order);
      setPos("quantityCell"+i, left, top + rowOffsets.qty);
      setPos("metalCell"+i,    left, top + rowOffsets.metal);
      setPos("matchCell"+i,    left, top + rowOffsets.match);

      k++;
    }
  };

  // hook up live input
  input.addEventListener("input", () => window.applyOrderSearchFilter(input.value));
  // keep layout tidy if the window or config changes size
  window.addEventListener("resize", () => window.applyOrderSearchFilter(input.value));
})();

  </script>
</body>
</html>