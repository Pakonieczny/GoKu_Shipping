<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Sorting - Single-Click Zoom</title>
  <!-- Materialize CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
<style>
  body {
    background-color: #fff;
    margin: 0;
    height: 100vh;
    position: relative;
    opacity: 0;
    transition: opacity 0s;
  }
  /* Main Buttons */
  #connectEtsyBtn,
  #testOpenAIBtn,
  #openConfigBtn,
  #cropImagesBtn,
  #sendMatchBtn {
    position: absolute;
    left: 20px;
    width: 140px;
    height: 36px;
  }
  #connectEtsyBtn { top: 20px; }
  #testOpenAIBtn { top: 70px; }
  #openConfigBtn { top: 120px; }
  #cropImagesBtn { top: 170px; }
  #sendMatchBtn { top: 220px; }
  
  /* Etsy Order Number input */
  #etsyOrderNumber {
    position: absolute;
    left: 20px;
    top: 270px;
    width: 300px;
    height: 30px;
    border: 1px solid #999;
    padding: 4px;
    outline: none;
    font-size: 0.9em;
  }
  
  /* Image Comparison UI */
  #imageComparisonContainer {
    position: absolute;
    left: 20px;
    top: 310px;
  }
  #photoDragDrop {
    width: 100px;
    height: 100px;
    border: 2px dashed #ccc;
    text-align: center;
    line-height: 100px;
    display: inline-block;
    margin-right: 10px;
  }
  #userImage {
    width: 100px;
    height: 100px;
    border: 1px solid #000;
    display: none;
    vertical-align: top;
  }
  
  /* Container for dynamically generated preview boxes and detail boxes */
  #photoGridContainer {
    position: relative;
    width: 1200px;
    max-height: 700px;
    overflow-y: auto;
    border-left: 1px dashed #ccc;
    border-right: 1px dashed #ccc;
    left: 350px;
    top: 20px;
  }
  /* Preview box styling (110x110) */
  .preview-box {
    position: absolute;
    width: 110px;
    height: 110px;
    border: 1px solid #000;
    background: #fafafa;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    user-select: none;
    font-size: 0.7em;
    text-align: center;
  }
  .preview-box img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transform-origin: center center;
    transition: transform 0.3s ease;
  }
  /* Detail text boxes: 55px x 7px */
  .detail-box {
    position: absolute;
    width: 55px;
    height: 7px;
    font-size: 0.6em !important;
    border: none !important;
    outline: none !important;
    -webkit-appearance: none !important;
    -moz-appearance: none !important;
    appearance: none !important;
    background: #f0f0f0;
    color: #333;
    padding: 0;
    margin: 0;
    box-shadow: none !important;
  }

    #unmatchedContainer {
    position: absolute;
    left: 20px;
    top: 420px; /* ~100px below the #photoDragDrop which starts at top:310px */
    width: 600px;
    /* no fixed height; it will grow as new images are added */

  }
  /* The crucial fix: pointer-events are now enabled on read-only inputs */
  .detail-box:read-only {
    pointer-events: auto !important;
    cursor: pointer !important;
  }
  
  /* Config Modal */
  #configModal.modal {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    transform: translate(-50%, -50%) !important;
    width: 250px !important;
    height: 450px !important;
    max-height: none !important;
    overflow-y: auto !important;
  }
  #configTable thead tr th { font-size: 0.9em; }
  #configTable tbody tr td { font-size: 0.8em; }
  #configTable .left-input,
  #configTable .top-input,
  #configTable .width-input,
  #configTable .height-input { width: 80px !important; }
  .modal {
      opacity: 0 !important;
      transform: translateY(20px) scale(0.95) !important;
      will-change: opacity, transform;
      transition: opacity 300ms ease, transform 300ms ease;
    }
    .modal.open {
      opacity: 1 !important;
      transform: translateY(0) scale(1) !important;
    }

    .modal-overlay {
      opacity: 0;
      will-change: opacity;
      transition: opacity 300ms ease;
    }
    .modal-overlay.show {
      opacity: 1;
    }
</style>
</head>
<body>
  <!-- Main Buttons -->
  <button id="connectEtsyBtn" class="btn waves-effect waves-light">Connect to Etsy</button>
  <button id="testOpenAIBtn" class="btn waves-effect waves-light">Test OpenAI</button>
  <button id="openConfigBtn" class="btn waves-effect waves-light">Open Config</button>
  <button id="cropImagesBtn" class="btn waves-effect waves-light">Crop Images</button>
  <button id="sendMatchBtn" class="btn waves-effect waves-light">Send & Match</button>
  
  <!-- Etsy Order Number input -->
  <input type="text" id="etsyOrderNumber" placeholder="Comma-delimited Etsy Order Numbers" />
  
  <!-- Image Comparison UI -->
  <div id="imageComparisonContainer">
    <div id="photoDragDrop">Drag & Drop</div>
    <img id="userImage" src="" alt="User Image" />
    <div id="unmatchedContainer"></div>
  </div>
  
  <!-- Container for dynamically generated preview boxes and detail boxes -->
  <div id="photoGridContainer">
    <!-- Preview boxes and detail boxes will be created dynamically -->
  </div>
  
  <!-- Config Modal -->
  <div id="configModal" class="modal">
    <div class="modal-content">
      <table class="striped" id="configTable">
        <thead>
          <tr>
            <th>Element</th>
            <th>Left (px)</th>
            <th>Top (px)</th>
            <th>Width (px)</th>
            <th>Height</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="modal-footer">
      <a href="#!" id="saveConfigBtn" class="modal-close waves-effect waves-green btn">
        Save Config
      </a>
    </div>
  </div>
  
  <!-- Matches Modal (Shared, but will be populated with cell-specific matches) -->
  <div id="matchesModal" class="modal">
    <div class="modal-content">
      <h5>Successful Image Matches</h5>
      <div id="matchesGridContainer" style="display: flex; flex-wrap: wrap; gap: 10px;"></div>
    </div>
    <div class="modal-footer">
      <a href="#!" class="modal-close waves-effect waves-green btn">Close</a>
    </div>
  </div>
  
  <!-- jQuery & Materialize JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script>
    // your scripts here ...
  </script>
</body>
</html>

    // Base URL for Netlify functions
    const functionsBaseUrl = window.location.origin + "/.netlify/functions";
    
    // Global arrays to store cropped grid images, user images (both resized to 512x512)
    // And an object to store matches dedicated to each cell (key: cell index, value: array of match objects)
    let croppedImagesArray = [];
    let userImagesArray = []; // { name, data }
    let cellMatches = {};
    let partialMatches = {};

    (function(){
      const urlParams = new URLSearchParams(window.location.search);
      const accessToken = urlParams.get("access_token");
      if(accessToken){
        localStorage.setItem("access_token", accessToken);
        window.history.replaceState({}, document.title, window.location.pathname);
        M.toast({html:"Connection Successful!"});
        console.log("Access token received:", accessToken);
      } else {
        const authCode = urlParams.get("code");
        if(authCode){
          const storedCodeVerifier = localStorage.getItem("etsy_code_verifier");
          if(storedCodeVerifier){
            window.location.href =
              "/.netlify/functions/exchangeToken?code=" +
              encodeURIComponent(authCode) +
              "&code_verifier=" +
              encodeURIComponent(storedCodeVerifier);
          } else {
            console.error("No code verifier found in localStorage.");
          }
        }
      }
    })();
    
    function generateRandomString(length) {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let text = "";
      for (let i = 0; i < length; i++){
        text += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return text;
    }
    
    async function generateCodeChallenge(codeVerifier) {
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest("SHA-256", data);
      let base64String = btoa(String.fromCharCode(...new Uint8Array(digest)));
      return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }
    
    // ---------------------------------------------------------------------
    // (HARD-CODED DEFAULT OFFSETS omitted as requested)
    // ---------------------------------------------------------------------
    
        const configIDs = [
      "connectEtsyBtn",
      "testOpenAIBtn",
      "openConfigBtn",
      "etsyOrderNumber",
      "photoGridContainer",
      "unmatchedContainer",       // <-- new
      "configModal",
      "configTable",
      "saveConfigBtn"
    ];
    
    document.addEventListener("DOMContentLoaded", function() {
      M.AutoInit();
      setTimeout(function() {
        loadPositions();
        document.body.style.opacity = 1;
      }, 200);
    
      // Connect to Etsy
      document.getElementById("connectEtsyBtn").addEventListener("click", async function() {
        try {
          const codeVerifier = generateRandomString(64);
          localStorage.setItem("etsy_code_verifier", codeVerifier);
          const codeChallenge = await generateCodeChallenge(codeVerifier);
          const CLIENT_ID = "k75zdspz4r99txpqdji7i2em";
          const redirectUri = "https://sorting.goldenspike.app";
          const state = "randomState123";
          const scope = "listings_w listings_r transactions_r transactions_w";
          const etsyAuthUrl =
            "https://www.etsy.com/oauth/connect?response_type=code" +
            "&client_id=" + CLIENT_ID +
            "&redirect_uri=" + encodeURIComponent(redirectUri) +
            "&scope=" + encodeURIComponent(scope) +
            "&state=" + state +
            "&code_challenge=" + encodeURIComponent(codeChallenge) +
            "&code_challenge_method=S256";
          window.location.href = etsyAuthUrl;
        } catch (err) {
          console.error("OAuth start error:", err);
          M.toast({ html: "OAuth error: " + err.message });
        }
      });
    
      // Test OpenAI
      document.getElementById("testOpenAIBtn").addEventListener("click", async function() {
        try {
          const testBody = {
            model: "gpt-3.5-turbo",
            messages: [{ role: "user", content: "Hello from the Sorting page!" }]
          };
          const resp = await fetch(functionsBaseUrl + "/openaiProxy", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(testBody)
          });
          if (!resp.ok) {
            throw new Error("OpenAI test call failed with " + resp.status);
          }
          const data = await resp.json();
          if (data.choices && data.choices[0] && data.choices[0].message) {
            M.toast({ html: "OpenAI responded successfully." });
          } else {
            throw new Error("No valid response from OpenAI!");
          }
        } catch (err) {
          M.toast({ html: "OpenAI test failed: " + err.message });
        }
      });
    
      // Load multiple orders when the user presses Enter
      var etsyOrderInput = document.getElementById("etsyOrderNumber");
      etsyOrderInput.addEventListener("keydown", async function(e) {
        if (e.key === "Enter") {
          var inputVal = etsyOrderInput.value.trim();
          if (!inputVal) return;
          var orderNumbers = inputVal.split(",").map(x => x.trim()).filter(x => x);
          orderNumbers = orderNumbers.slice(0, 50);
          await loadBatchEtsyOrders(orderNumbers);
        }
      });
    
      // Crop Images Button
      document.getElementById("cropImagesBtn").addEventListener("click", async function() {
      // Clear any old data and run the cropping process
      croppedImagesArray = [];
      await cropAllImages();
      });

      // Crop Images Button
      document.getElementById("cropImagesBtn").addEventListener("click", async function() {
        croppedImagesArray = [];
        await cropAllImages();
      });
    
      // Send & Match Button (Parallel)
      document.getElementById("sendMatchBtn").addEventListener("click", async function() {
        await sendAndMatch();
      });
    });
    
    // ---------------------------------------------------------
    // Dynamically generate preview boxes and four detail boxes per item
    // (Detail boxes: Order # (bold), Quantity, Metal, and a fourth (match) box initially empty)
    // ---------------------------------------------------------
    async function fillPreviewBoxes(items) {
      const container = document.getElementById("photoGridContainer");
      container.innerHTML = "";
    
      // Store the items globally for later access (e.g. in sendAndMatch)
      window.cachedOrderItems = items;
    
      items.forEach((item, index) => {
        // Use 9 boxes per row
        const row = Math.floor(index / 9);
        const col = index % 9;
        const previewLeft = col * 125; // horizontal gap of 125px
        const previewTop = row * 165;  // vertical gap: 110px preview + 55px for details
    
        // Create preview box (110x110)
        const previewBox = document.createElement("div");
        previewBox.classList.add("preview-box");
        previewBox.id = "previewCell" + index;
        previewBox.style.position = "absolute";
        previewBox.style.left = previewLeft + "px";
        previewBox.style.top = previewTop + "px";
        previewBox.style.width = "110px";
        previewBox.style.height = "110px";
        previewBox.innerHTML = "Loading...";
    
        // Create first detail box: Order # (bold)
        const orderInput = document.createElement("input");
        orderInput.type = "text";
        orderInput.readOnly = true;
        orderInput.id = "orderCell" + index;
        orderInput.classList.add("detail-box");
        orderInput.style.left = previewLeft + "px";
        orderInput.style.top = (previewTop + 95) + "px";
        orderInput.value = item.receipt_id ? item.receipt_id : (item.orderNumber || "No Order #");
        orderInput.style.fontWeight = "bold";
    
        // Create second detail box: Quantity
        const qtyInput = document.createElement("input");
        qtyInput.type = "text";
        qtyInput.readOnly = true;
        qtyInput.id = "quantityCell" + index;
        qtyInput.classList.add("detail-box");
        qtyInput.style.left = previewLeft + "px";
        qtyInput.style.top = (previewTop + 107) + "px";
        qtyInput.value = " Qty: " + (item.quantity != null ? item.quantity : 0);
    
        // Create third detail box: Metal
        const metalInput = document.createElement("input");
        metalInput.type = "text";
        metalInput.readOnly = true;
        metalInput.id = "metalCell" + index;
        metalInput.classList.add("detail-box");
        metalInput.style.left = previewLeft + "px";
        metalInput.style.top = (previewTop + 119) + "px";
        let metalSel = "";
        if (item.variations && Array.isArray(item.variations)) {
          const acceptedMetalNames = ["metal", "metal choice", "metal - engraving", "metal colour", "color", "metal choice / engraving option"];
          const metalVar = item.variations.find(v => v.formatted_name && acceptedMetalNames.includes(v.formatted_name.trim().toLowerCase()));
          if (metalVar && metalVar.formatted_value) {
            metalSel = metalVar.formatted_value;
          }
        }
        metalInput.value = " Metal: " + (metalSel || "No Metal");
    
        // Create fourth detail box: Match info (initially empty)
        const matchInput = document.createElement("input");
        matchInput.type = "text";
        matchInput.readOnly = true;
        matchInput.id = "matchCell" + index;
        matchInput.classList.add("detail-box");
        matchInput.style.left = previewLeft + "px";
        matchInput.style.top = (previewTop + 131) + "px";
        matchInput.value = "";
        // Attach event listener dedicated to this preview cell to open modal with its matches.
        matchInput.addEventListener("click", function() {
          showMatchesModal(index);
        });
    
        container.appendChild(previewBox);
        container.appendChild(orderInput);
        container.appendChild(qtyInput);
        container.appendChild(metalInput);
        container.appendChild(matchInput);
    
        // Load image for the preview box
        fetchListingImages(item.listing_id)
          .then(imageData => {
            if (imageData && imageData.length > 0) {
              return getLocalImageData(imageData[0].url_fullxfull);
            } else {
              throw "No image data";
            }
          })
          .then(localImageData => {
            previewBox.innerHTML = `<img src="${localImageData}" alt="Listing ${item.listing_id}" data-scale="1" data-offsetX="0" data-offsetY="0" />`;
            // Attach event listeners to this preview box
            attachPreviewBoxListeners(previewBox);
          })
          .catch(err => {
            console.warn("Error loading image for cell " + index + ":", err);
            previewBox.innerHTML = "Img Error";
          });
      });
    }
    
    // ---------------------------------------------------------
    // Attach event listeners for wheel zoom, drag, and single-click to a preview box
    // ---------------------------------------------------------
    function attachPreviewBoxListeners(box) {
      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0, dragStartY = 0;
      let lastX = 0, lastY = 0;
      const dragThreshold = 3;
    
      // Wheel zoom
      box.addEventListener("wheel", function(ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        if (ev.deltaY < 0) {
          currentScale *= 1.1;
        } else {
          currentScale /= 1.1;
          if (currentScale <= 1) {
            currentScale = 1;
            offX = 0;
            offY = 0;
          }
        }
        if (currentScale > 8) currentScale = 8;
        img.dataset.scale = currentScale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = "translate(" + offX + "px, " + offY + "px) scale(" + currentScale + ")";
      });
    
      // Mouse down: start drag
      box.addEventListener("mousedown", function(ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX;
        dragStartY = ev.clientY;
        lastX = ev.clientX;
        lastY = ev.clientY;
      });
    
      // Mouse move: panning if dragging
      box.addEventListener("mousemove", function(ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        offX += dx;
        offY += dy;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = "translate(" + offX + "px, " + offY + "px) scale(" + scaleNow + ")";
        lastX = ev.clientX;
        lastY = ev.clientY;
      });
    
      // Mouse up / leave: end drag
      box.addEventListener("mouseup", function() { isMouseDown = false; });
      box.addEventListener("mouseleave", function() { isMouseDown = false; });
    
      // Single-click: Zoom if not dragging
      box.addEventListener("click", function(ev) {
        if (isDragging) { isDragging = false; return; }
        const img = box.querySelector("img");
        if (!img) return;
        const rect = box.getBoundingClientRect();
        const boxCenterX = rect.left + box.clientWidth / 2;
        const boxCenterY = rect.top + box.clientHeight / 2;
        const dx = ev.clientX - boxCenterX;
        const dy = ev.clientY - boxCenterY;
        const scale = 5;
        const fudgeY = 10;
        const offsetX = -scale * dx;
        const offsetY = -scale * dy + fudgeY;
        img.dataset.scale = scale;
        img.dataset.offsetX = offsetX;
        img.dataset.offsetY = offsetY;
        img.style.transform = "translate(" + offsetX + "px, " + offsetY + "px) scale(" + scale + ")";
      });
    }
    
      // =====================================================
      // (A) cropAllImages() 
      // =====================================================
      async function cropAllImages() {
        const previewBoxes = document.querySelectorAll(".preview-box");
        for (let i = 0; i < previewBoxes.length; i++) {
          const cell = previewBoxes[i];
          const img = cell.querySelector("img");
          if (img && img.src && img.src !== "") {
            try {
              const cropped = await cropImageFromPreview(cell, 512, 512);
              croppedImagesArray[i] = cropped;
              M.toast({ html: "Cell " + i + ": Cropped successfully." });
            } catch (err) {
              console.error("Cropping failed for cell", i, err);
              M.toast({ html: "Cell " + i + ": Cropping error" });
            }
          }
        }
      }

      // =====================================================
      // (B) cropImageFromPreview()
      // =====================================================
      function cropImageFromPreview(cell, canvasWidth, canvasHeight) {
        return new Promise((resolve, reject) => {
          const imgElem = cell.querySelector("img");
          if (!imgElem) {
            reject("No image element found");
            return;
          }
          
          const cellRect = cell.getBoundingClientRect();
          const imgRect = imgElem.getBoundingClientRect();

          const visibleLeft = Math.max(cellRect.left, imgRect.left);
          const visibleTop = Math.max(cellRect.top, imgRect.top);
          const visibleRight = Math.min(cellRect.right, imgRect.right);
          const visibleBottom = Math.min(cellRect.bottom, imgRect.bottom);

          if (visibleRight <= visibleLeft || visibleBottom <= visibleTop) {
            reject("No visible intersection");
            return;
          }

          const visibleWidth = visibleRight - visibleLeft;
          const visibleHeight = visibleBottom - visibleTop;

          const sourceImage = new Image();
          sourceImage.crossOrigin = "Anonymous"; 
          sourceImage.onload = function() {
            const ratioX = sourceImage.naturalWidth / imgRect.width;
            const ratioY = sourceImage.naturalHeight / imgRect.height;

            const srcX = (visibleLeft - imgRect.left) * ratioX;
            const srcY = (visibleTop - imgRect.top) * ratioY;
            const srcWidth = visibleWidth * ratioX;
            const srcHeight = visibleHeight * ratioY;

            const canvas = document.createElement("canvas");
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(sourceImage, srcX, srcY, srcWidth, srcHeight, 0, 0, canvasWidth, canvasHeight);
            resolve(canvas.toDataURL());
          };
          sourceImage.onerror = function(e) {
            reject(e);
          };
          sourceImage.src = imgElem.src;
        });
      }

    // ---------------------------------------------------------
    // Load orders and fill preview boxes from Etsy data
    // ---------------------------------------------------------
    async function loadBatchEtsyOrders(orderNumbers) {
      try {
        M.toast({ html: "Loading " + orderNumbers.length + " order(s)..." });
        const token = localStorage.getItem("access_token") || "";
        let combinedItems = [];
        for (let i = 0; i < orderNumbers.length; i++) {
          const ord = orderNumbers[i];
          const url = functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(ord);
          const resp = await fetch(url, { headers: { "access-token": token } });
          if (!resp.ok) {
            console.warn("Order fetch failed for " + ord + ", status=" + resp.status);
            continue;
          }
          const data = await resp.json();
          if (data.transactions && Array.isArray(data.transactions)) {
            combinedItems.push(...data.transactions);
          } else {
            console.warn("No transactions for order " + ord);
          }
        }
        await fillPreviewBoxes(combinedItems);
      } catch (err) {
        console.error("Error loading batch orders:", err);
        M.toast({ html: "Error: " + err.message });
      }
    }
    
    async function fetchListingImages(listingId) {
      const token = localStorage.getItem("access_token") || "";
      const resp = await fetch(functionsBaseUrl + "/etsyImages?listingId=" + listingId, {
        headers: { "access-token": token }
      });
      if (!resp.ok) {
        console.warn("Image fetch HTTP error:", resp.status);
        return [];
      }
      const data = await resp.json();
      return data.results || [];
    }
    
    async function getLocalImageData(imageUrl) {
      try {
        const response = await fetch(functionsBaseUrl + "/imageProxy?url=" + encodeURIComponent(imageUrl));
        const blob = await response.blob();
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      } catch (err) {
        console.error("Error in getLocalImageData:", err);
        throw err;
      }
    }
    
    function loadPositions() {
  configIDs.forEach(function(id) {
    const el = document.getElementById(id);
    if (!el) return;
    const def = {};
    const left = localStorage.getItem("pos-" + id + "-left") || def.left || 0;
    const top  = localStorage.getItem("pos-" + id + "-top")  || def.top  || 0;
    const w    = localStorage.getItem("pos-" + id + "-width")  || def.width  || 0;
    const h    = localStorage.getItem("pos-" + id + "-height") || def.height || 0;

    el.style.position = "absolute";
    el.style.left = left + "px";
    el.style.top = top + "px";
    if (parseInt(w, 10) > 0) el.style.width = w + "px";
    if (parseInt(h, 10) > 0) el.style.height = h + "px";
  });
}
    loadPositions();
    
    function populateConfigTable() {
  const tbody = document.querySelector("#configTable tbody");
  tbody.innerHTML = "";

  configIDs.forEach(function(id) {
    const el = document.getElementById(id);
    if (!el) return;
    const cs = window.getComputedStyle(el);
    const leftVal = parseInt(cs.left, 10) || 0;
    const topVal = parseInt(cs.top, 10) || 0;
    const widthVal = parseInt(cs.width, 10) || 0;
    const heightVal = parseInt(cs.height, 10) || 0;

    const row = document.createElement("tr");
    row.innerHTML = `
      <td>${id}</td>
      <td><input type="number" value="${leftVal}" data-id="${id}" class="left-input"></td>
      <td><input type="number" value="${topVal}" data-id="${id}" class="top-input"></td>
      <td><input type="number" value="${widthVal}" data-id="${id}" class="width-input"></td>
      <td><input type="number" value="${heightVal}" data-id="${id}" class="height-input"></td>
    `;
    tbody.appendChild(row);

    // Listeners to immediately update positions as user types
    row.querySelector(".left-input").addEventListener("input", function() {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.left = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".top-input").addEventListener("input", function() {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.top = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".width-input").addEventListener("input", function() {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.width = parseInt(this.value, 10) + "px";
    });
    row.querySelector(".height-input").addEventListener("input", function() {
      const target = document.getElementById(this.dataset.id);
      if (target) target.style.height = parseInt(this.value, 10) + "px";
    });
  });
}
    
    document.getElementById("openConfigBtn").addEventListener("click", function() {
      populateConfigTable();
      M.Modal.getInstance(document.getElementById("configModal")).open();
    });
    
    document.getElementById("saveConfigBtn").addEventListener("click", function() {
      configIDs.forEach(function(id) {
        const el = document.getElementById(id);
        if (!el) return;
        const cs = window.getComputedStyle(el);
        localStorage.setItem("pos-" + id + "-left", parseInt(cs.left, 10) || 0);
        localStorage.setItem("pos-" + id + "-top", parseInt(cs.top, 10) || 0);
        localStorage.setItem("pos-" + id + "-width", parseInt(cs.width, 10) || 0);
        localStorage.setItem("pos-" + id + "-height", parseInt(cs.height, 10) || 0);
      });
      M.toast({ html: "Positions saved!" });
    });
    
/////////////////////////////
// 1) Drag-and-Drop + Resize Logic
/////////////////////////////

// Drag & Drop setup for photoDragDrop supporting multiple files
const photoDragDropElem = document.getElementById("photoDragDrop");

// Allows dropping items onto photoDragDrop without the browser blocking the event.
photoDragDropElem.addEventListener("dragover", function(e) {
  e.preventDefault();
});

// Handle dropped files
photoDragDropElem.addEventListener("drop", function(e) {
  e.preventDefault();
  const files = e.dataTransfer.files;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const reader = new FileReader();
    reader.onload = async function(e) {
      const imageData = e.target.result;
      try {
        // Resize the image before adding it to userImagesArray
        const resizedData = await resizeUserImage(imageData);
        userImagesArray.push({ name: file.name, data: resizedData });

        M.toast({ html: "User image " + userImagesArray.length + " captured and resized." });

        // If it's the first user image, show a preview in #userImage
        if (userImagesArray.length === 1) {
          const userImageElem = document.getElementById("userImage");
          userImageElem.src = resizedData;
          userImageElem.style.display = "inline-block";
        }
      } catch(err) {
        console.error("Error resizing user image:", err);
        M.toast({ html: "Error processing one of the user images." });
      }
    };
    reader.readAsDataURL(file);
  }
});

// Resize user images to 512x512 so they're consistent for matching
function resizeUserImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = function() {
      const canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, 512, 512);
      resolve(canvas.toDataURL());
    };
    img.onerror = function(err) { reject(err); };
    img.src = dataUrl;
  });
}

  // -----------------------------------------
// Fully bracketed sendAndMatch function
// -----------------------------------------
async function sendAndMatch() {
  if (userImagesArray.length === 0) {
    M.toast({ html: "No user images available! Please drop user images first." });
    return;
  }
  if (!croppedImagesArray || croppedImagesArray.length === 0) {
    M.toast({ html: "No cropped grid images available! Please crop images first." });
    return;
  }

  // --------------------------------------------------------------
  // FIRST PASS: Accept only matches ≥ 0.98 (removes user image).
  // --------------------------------------------------------------
  let unmatchedCells = [];
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (croppedImagesArray[i]) {
      unmatchedCells.push(i);
    }
  }

  for (const i of unmatchedCells) {
    const matchBox = document.getElementById("matchCell" + i);

    // Compare all user images, staggered by j * 250
    const comparisonPromises = userImagesArray.map((user, j) => {
      return new Promise(resolve => {
        setTimeout(() => {
          compareImages(user.data, croppedImagesArray[i], i, user.name)
            .then(result => resolve({ result, user }))
            .catch(err => {
              console.error("First-pass compare error:", i, user.name, err);
              resolve({ result: { score: 0 }, user });
            });
        }, j * 250);
      });
    });

    const results = await Promise.all(comparisonPromises);
    results.sort((a, b) => b.result.score - a.result.score);

    if (!results.length || results[0].result.score === 0) {
      M.toast({ html: `Cell ${i}: No valid matches in first pass.` });
    } else {
      // Take top candidate
      const topCandidate = results[0];
      const topScore = topCandidate.result.score;
      const topScorePerc = (topScore * 100).toFixed(2);
      const matchName = topCandidate.user.name.replace(/(\.jpg|\.png)$/i, "");

      // If there's more than one candidate, do a delta check
      if (results.length > 1) {
        const secondScore = results[1].result.score;
        const delta = topScore - secondScore;
        // If difference ≥ 15% and top ≥ 0.88 => auto-accept
        if (topScore >= 0.88 && delta >= 0.15) {
          M.toast({
            html: `Cell ${i}: Delta ≥ 15% & top ≥ 88% => Accepting ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        // Otherwise, the standard first-pass threshold: top ≥ 0.98
        else if (topScore >= 0.98) {
          M.toast({
            html: `Cell ${i}: First-pass match ≥ 98% => ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
      } else {
        // If there's only one result, just check if ≥ 0.98
        if (topScore >= 0.98) {
          M.toast({
            html: `Cell ${i}: First-pass match ≥ 98% => ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
      }
    }
    // Short cooldown
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  // -----------------------------------------------------------------------
  // SECOND PASS: For all cells still unmatched, do a multi-branch if/else.
  // -----------------------------------------------------------------------
  unmatchedCells = [];
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (croppedImagesArray[i]) {
      unmatchedCells.push(i);
    }
  }

  for (const i of unmatchedCells) {
    const matchBox = document.getElementById("matchCell" + i);

    // Compare all user images in parallel, staggered
    const comparisonPromises = userImagesArray.map((user, j) => {
      return new Promise(resolve => {
        setTimeout(() => {
          compareImages(user.data, croppedImagesArray[i], i, user.name)
            .then(result => resolve({ result, user }))
            .catch(err => {
              console.error("Second-pass compare error:", i, user.name, err);
              resolve({ result: { score: 0 }, user });
            });
        }, j * 250);
      });
    });

    const results = await Promise.all(comparisonPromises);
    results.sort((a, b) => b.result.score - a.result.score);

    if (!results.length || results[0].result.score === 0) {
      M.toast({ html: `Cell ${i}: No valid matches found in second pass.` });
    } else {
      const topCandidate = results[0];
      const topScore = topCandidate.result.score;
      const topScorePerc = (topScore * 100).toFixed(2);
      const matchName = topCandidate.user.name.replace(/(\.jpg|\.png)$/i, "");
      M.toast({
        html: `Cell ${i}: Best candidate => ${matchName} (${topScorePerc}%)`
      });

      if (results.length > 1) {
        // There's a second candidate
        const secondScore = results[1].result.score;
        const delta = topScore - secondScore;

        if (topScore >= 0.88 && delta >= 0.15) {
          M.toast({
            html: `Cell ${i}: Delta ≥ 15% & top ≥ 88% => Accepting ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        else if (topScore === 1.0) {
          // EXACT 100%
          M.toast({ html: `Cell ${i}: PERFECT MATCH => ${matchName} (100%)` });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        else if (topScore >= 0.98) {
          // NEAR-PERFECT => remove user image
          if (partialMatches[topCandidate.user.name]) {
            const oldCellIndex = partialMatches[topCandidate.user.name].cellIndex;
            const oldBox = document.getElementById("matchCell" + oldCellIndex);
            if (oldBox) {
              oldBox.value = "";
              oldBox.style.fontWeight = "";
              oldBox.style.color = "";
            }
            if (cellMatches[oldCellIndex]) {
              cellMatches[oldCellIndex] = cellMatches[oldCellIndex].filter(
                (m) => m.userName !== topCandidate.user.name
              );
            }
            delete partialMatches[topCandidate.user.name];
          }
          M.toast({
            html: `Cell ${i}: NEAR-PERFECT (≥ 98%) => ${matchName} (${topScorePerc}%). Removing image.`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        else if (topScore >= 0.88) {
          // PARTIAL MATCH => keep user image
          M.toast({
            html: `Cell ${i}: PARTIAL MATCH >= 88% => ${matchName} (${topScorePerc}%).`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "bold";
            matchBox.style.color = "orangered";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          croppedImagesArray[i] = null;
          partialMatches[topCandidate.user.name] = { cellIndex: i, score: topScore };
        } else {
          M.toast({ html: `Cell ${i}: Score ${topScorePerc}% < 88%. No match.` });
        }
      } else {
        // There's only one result
        if (topScore === 1.0) {
          M.toast({ html: `Cell ${i}: PERFECT MATCH => ${matchName} (100%)` });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        else if (topScore >= 0.98) {
          M.toast({
            html: `Cell ${i}: NEAR-PERFECT (≥ 98%) => ${matchName} (${topScorePerc}%). Removing image.`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
          croppedImagesArray[i] = null;
        }
        else if (topScore >= 0.88) {
          M.toast({
            html: `Cell ${i}: PARTIAL MATCH >= 88% => ${matchName} (${topScorePerc}%).`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "bold";
            matchBox.style.color = "orangered";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });
          croppedImagesArray[i] = null;
          partialMatches[topCandidate.user.name] = { cellIndex: i, score: topScore };
        } else {
          M.toast({ html: `Cell ${i}: Score ${topScorePerc}% < 88%. No match.` });
        }
      }
    }
    // Short cooldown
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  // (A) After the second pass, highlight any STILL-unmatched cells 
  //     with a 3px orange border
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (croppedImagesArray[i]) {
      // Means cell i was never matched
      const previewBox = document.getElementById("previewCell" + i);
      if (previewBox) {
        previewBox.style.border = "3px solid orangered";  // or "orangeade"
      }
    }
  }

  // (B) Dynamically add click listeners to the 4th (match) box 
  //     after second pass is finished
  for (let i = 0; i < croppedImagesArray.length; i++) {
    const matchInput = document.getElementById("matchCell" + i);
    if (!matchInput) continue;
    matchInput.addEventListener("click", function() {
      openMatchPreviewModal(i);
    });
  }

  // (C) If leftover user images remain unmatched, create 66×66 previews
  if (userImagesArray.length > 0) {
    createUnmatchedUserImagesPreview();
  }

  M.toast({ html: "Finished matching passes." });
}
// -----------------------------------------

function openMatchPreviewModal(cellIndex) {
  const modalElem = document.getElementById("matchesModal");
  const container = document.getElementById("matchesGridContainer");
  container.innerHTML = "";

  // 1) Build local arrays for matched vs. unmatched images
  let matchedImages = cellMatches[cellIndex] || [];
  // "unmatched" => leftover images not partial or fully matched
  let unmatchedImages = userImagesArray.filter((uImg) => {
    // Exclude partial matches
    if (partialMatches[uImg.name]) return false;
    // Exclude anything that appears in matchedImages:
    const isMatched = matchedImages.some((m) => m.userName === stripExtension(uImg.name));
    return !isMatched;
  });

  // 2) Create wrappers for 100×100 matched (top) + 66×66 unmatched (bottom)
  const wrapper = document.createElement("div");
  wrapper.style.display = "flex";
  wrapper.style.flexDirection = "column";

  // (A) Matched images section
  const matchedSection = document.createElement("div");
  matchedSection.style.display = "flex";
  matchedSection.style.flexWrap = "wrap";
  matchedSection.style.gap = "10px";

  // Populate matched images as 100×100
  matchedImages.forEach((mImg, index) => {
    const box = document.createElement("div");
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";

    // Mark it as drop target
    box.dataset.type = "matched";
    box.dataset.index = index;

    const img = document.createElement("img");
    img.src = mImg.userImage;
    img.alt = mImg.userName;
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";

    makeDropTarget(box);
    box.appendChild(img);
    matchedSection.appendChild(box);
  });

  // (B) Unmatched images section
  const unmatchedSection = document.createElement("div");
  unmatchedSection.style.display = "flex";
  unmatchedSection.style.flexWrap = "wrap";
  unmatchedSection.style.gap = "5px";
  unmatchedSection.style.marginTop = "20px"; // 20px below matched

  // Populate unmatched images as 66×66
  unmatchedImages.forEach((uImg, index) => {
    const box = document.createElement("div");
    box.style.width = "66px";
    box.style.height = "66px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";

    // Mark as "unmatched"
    box.dataset.type = "unmatched";
    box.dataset.index = index;

    const img = document.createElement("img");
    img.src = uImg.data;
    img.alt = uImg.name;
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";

    makeDraggable(box);
    box.appendChild(img);
    unmatchedSection.appendChild(box);
  });

  // Assemble both sections
  wrapper.appendChild(matchedSection);
  wrapper.appendChild(unmatchedSection);
  container.appendChild(wrapper);

  // 3) Initialize the modal with an onCloseEnd callback
  //    so that when user clicks "Close", we push changes to global arrays.
  const instance = M.Modal.init(modalElem, {
    onCloseEnd: function() {
      // (A) Save matchedImages array back to cellMatches
      cellMatches[cellIndex] = matchedImages;

      // (B) Rebuild userImagesArray to reflect the final unmatchedImages
      //     We'll remove any images that appear in matchedImages
      //     and then re-add unmatchedImages. That ensures a 1:1 sync.
      const newUserArr = [...userImagesArray];
      // Remove anything that is now matched
      matchedImages.forEach((mImg) => {
        // find a user image in newUserArr with .name that matches mImg.userName
        // if found, remove it
        const idx = newUserArr.findIndex((u) => stripExtension(u.name) === mImg.userName);
        if (idx >= 0) newUserArr.splice(idx, 1);
      });
      // remove partial matches from the unmatched list if needed, or skip
      // next, remove everything from unmatched that might also exist in newUserArr
      // to avoid duplicates
      unmatchedImages.forEach((u) => {
        const dupIdx = newUserArr.findIndex((x) => x.name === u.name);
        if (dupIdx >= 0) newUserArr.splice(dupIdx, 1);
      });
      // now add the final unmatched array items
      unmatchedImages.forEach((u) => {
        newUserArr.push(u);
      });

      userImagesArray = newUserArr;

      // (C) Update the 4th read-only text box with the first matched image’s name (if any)
      //     e.g., "matchCell" + cellIndex
      const matchBox = document.getElementById("matchCell" + cellIndex);
      if (matchBox) {
        if (matchedImages.length > 0) {
          // Use the first matched image's userName
          matchBox.value = matchedImages[0].userName;
          matchBox.style.fontWeight = "";  // optional reset
          matchBox.style.color = "";
        } else {
          // No matches => empty
          matchBox.value = "";
        }
      }

      // (D) Re-run createUnmatchedUserImagesPreview() so the main 66x66 container updates
      if (typeof createUnmatchedUserImagesPreview === "function") {
        createUnmatchedUserImagesPreview();
      }
    }
  });
  // Finally open
  instance.open();

  // === Drag & Drop helpers ===
  function makeDraggable(elem) {
    elem.setAttribute("draggable", true);
    elem.addEventListener("dragstart", (ev) => {
      ev.dataTransfer.setData("text/plain", JSON.stringify({
        sourceType: elem.dataset.type,
        sourceIndex: elem.dataset.index
      }));
    });
  }

  function makeDropTarget(elem) {
    elem.addEventListener("dragover", (ev) => {
      ev.preventDefault();
    });
    elem.addEventListener("drop", (ev) => {
      ev.preventDefault();
      const data = ev.dataTransfer.getData("text/plain");
      if (!data) return;
      let parsed;
      try {
        parsed = JSON.parse(data);
      } catch (err) {
        return;
      }

      if (parsed.sourceType === "unmatched" && elem.dataset.type === "matched") {
        // We are dropping an unmatched onto a matched => swap
        const unmatchedIndex = parseInt(parsed.sourceIndex, 10);
        const matchedIndex = parseInt(elem.dataset.index, 10);

        const unmatchedImg = unmatchedImages[unmatchedIndex]; 
        const matchedImg   = matchedImages[matchedIndex];

        // Swap them
        matchedImages[matchedIndex] = {
          userName: stripExtension(unmatchedImg.name),
          userImage: unmatchedImg.data,
          score: 0.0
        };
        unmatchedImages[unmatchedIndex] = {
          name: matchedImg.userName + ".jpg",
          data: matchedImg.userImage
        };

        // Re-render the local matched + unmatched sections 
        refreshSections();
      }
    });
  }

  function refreshSections() {
    container.innerHTML = "";
    wrapper.innerHTML = "";
    matchedSection.innerHTML = "";
    unmatchedSection.innerHTML = "";

    // Rebuild matched (100x100)
    matchedImages.forEach((mImg, i) => {
      const box = document.createElement("div");
      box.style.width = "100px";
      box.style.height = "100px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";
      box.style.position = "relative";
      box.dataset.type = "matched";
      box.dataset.index = i;

      const _img = document.createElement("img");
      _img.src = mImg.userImage;
      _img.alt = mImg.userName;
      _img.style.width = "100%";
      _img.style.height = "100%";
      _img.style.objectFit = "cover";

      makeDropTarget(box);
      box.appendChild(_img);
      matchedSection.appendChild(box);
    });

    // Rebuild unmatched (66x66)
    unmatchedImages.forEach((uImg, i) => {
      const box = document.createElement("div");
      box.style.width = "66px";
      box.style.height = "66px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";
      box.style.position = "relative";
      box.dataset.type = "unmatched";
      box.dataset.index = i;

      const _img = document.createElement("img");
      _img.src = uImg.data;
      _img.alt = uImg.name;
      _img.style.width = "100%";
      _img.style.height = "100%";
      _img.style.objectFit = "cover";

      makeDraggable(box);
      box.appendChild(_img);
      unmatchedSection.appendChild(box);
    });

    wrapper.appendChild(matchedSection);
    unmatchedSection.style.marginTop = "20px";
    wrapper.appendChild(unmatchedSection);
    container.appendChild(wrapper);
  }

  // Utility
  function stripExtension(fileName) {
    return fileName.replace(/\.\w+$/, "");
  }
}

// -----------------------------------------
// The createUnmatchedUserImagesPreview function
// (Called at the end of sendAndMatch() if leftover userImages remain)
// -----------------------------------------
function createUnmatchedUserImagesPreview() {
  const unmatchedContainer = document.getElementById("unmatchedContainer");
  if (!unmatchedContainer) return;
  unmatchedContainer.innerHTML = ""; // Clear old previews

  // 1) Filter out any images that are partially matched:
  //    If partialMatches has an entry keyed by userImg.name, that means partial match
  const trulyUnmatchedImages = userImagesArray.filter(userImg => {
    return !partialMatches[userImg.name];
  });

  // 2) Spacing: 66px box width + 5px gap = 71px total step horizontally & vertically
  const imagesPerRow = 3;
  const boxSize = 66;
  const gap = 5;
  const step = boxSize + gap; // = 71

  // 3) Create 66×66 previews for these leftover images
  trulyUnmatchedImages.forEach((userImg, i) => {
    const row = Math.floor(i / imagesPerRow);
    const col = i % imagesPerRow;
    const leftPx = col * step;
    const topPx = row * step;

    const previewBox = document.createElement("div");
    previewBox.classList.add("preview-box");
    previewBox.style.position = "absolute";
    previewBox.style.left = leftPx + "px";
    previewBox.style.top = topPx + "px";
    previewBox.style.width = boxSize + "px";
    previewBox.style.height = boxSize + "px";

    // Insert the unmatched user image
    previewBox.innerHTML = `
      <img src="${userImg.data}"
           alt="${userImg.name}"
           data-scale="1"
           data-offsetX="0"
           data-offsetY="0"
           style="width:100%; height:100%; object-fit:cover;" />
    `;

    // Attach the same wheel-zoom, single-click zoom, & drag-panning
    attachPreviewBoxListeners(previewBox);

    unmatchedContainer.appendChild(previewBox);
  });
}

    // Modified compareImages: 
// Updated text instructions to request more precise similarity scores.

async function compareImages(userImage, croppedGridImage, cellIndex, userImageName, signal = undefined) {
  const payload = {
    model: "gpt-4o",
    messages: [
      {
        role: "user",
        content: [
          { 
            type: "text", 
            text: 
              "1. The Similarity Score is to be strictly measured on the similarity of the jewelry charm / pendant between the 2 images " +
              "2. Focus on the charm outline and silhouette and compare the cutouts or holes within the charm " +
              "3. Focus on the engraving existance, design, shapes on top of the charm itself " +
              "4. Return a similarity score that combines the outline and silhouette score + the similarity score for engraving size, existance, location, orientation etc.. " + 
              "5. If you detect an animal charm then strictly focus on the position, size and orientation of the head, eyes, beak, mouth, ears, legs, wings etc.. " +
              "6. Ignore and disregard all background and accessories around and attached to charm such as necklaces, chains, hoops, rings, clothing, or skin " +
              "7. Return a numeric similarity score between 0.0000 and 1.0000 with EXACTLY four decimal places, for example 0.8937, 0.9231, or 1.675, and no additional text " +
              "8. Examine all details on top and inside each engraved charm " +
              "9. Emphasize the pose and direction the charm is facing " 
          },
          { type: "image_url", image_url: { url: userImage, detail: "high" } },
          { type: "image_url", image_url: { url: croppedGridImage, detail: "high" } }
        ]
      }
    ],
    max_tokens: 5000
  };

  try {
    const response = await fetch(functionsBaseUrl + "/openaiProxy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal: signal
    });
    const data = await response.json();
    console.log("Response for cell " + cellIndex + ", user image " + userImageName + ":", data);

    const scoreText = data.choices[0].message.content.trim();
    const score = parseFloat(scoreText);
    
    if (isNaN(score)) {
      console.error("Cell " + cellIndex + " (" + userImageName + "): Invalid score (" + scoreText + ")");
      return { score: 0, name: null };
    }

    // Optionally show a toast if it's ≥ 0.85
    if (score >= 0.88) {
      M.toast({ html: "Cell " + cellIndex + " (" + userImageName + "): Score " + score });
    }

    return { score: score, name: (score >= 0.88) ? userImageName : null };
  } catch (error) {
    console.error("Error comparing cell " + cellIndex + " (" + userImageName + "):", error);
    if (error.name === "AbortError") {
      return { score: 0, name: null };
    }
    M.toast({ html: "Cell " + cellIndex + " (" + userImageName + "): Comparison error" });
    return { score: 0, name: null };
  }
}
    
    // ---------------------------------------------------------
    // Pull Etsy order details and update grid details
    // ---------------------------------------------------------
    function pullEtsyOrderDetails(orderNumber) {
      console.log("Pulling Etsy order details for order number:", orderNumber);
      var token = localStorage.getItem("access_token");
      return fetch(functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(orderNumber), {
        headers: { "access-token": token }
      })
      .then(function(r) { return r.json(); })
      .then(function(data) {
        console.log("Etsy Order Data:", data);
        return data;
      })
      .catch(function(err) {
        console.error("Error fetching Etsy order details:", err);
        return null;
      });
    }
    
    // Example: update the grid details using pulled Etsy order details
    async function updateImageGrid(data) {
      let items = [];
      if (data.transactions && Array.isArray(data.transactions)) {
        items = data.transactions;
      } else if (Array.isArray(data)) {
        items = data;
      }
      window.cachedOrderItems = items;
      await fillPreviewBoxes(items);
    }
    
    // ---------------------------------------------------------
    // New function to display matches for a specific preview cell in a modal.
    // ---------------------------------------------------------
    function showMatchesModal(cellIndex) {
      const modalElem = document.getElementById("matchesModal");
      const container = document.getElementById("matchesGridContainer");
      container.innerHTML = "";
      
      const matches = cellMatches[cellIndex] || [];
      if (matches.length === 0) {
        container.innerHTML = "<p>No matches found for this photo.</p>";
      } else {
        matches.forEach((match) => {
          const box = document.createElement("div");
          box.classList.add("preview-box");
          box.style.width = "110px";
          box.style.height = "110px";
          box.style.border = "1px solid #000";
          box.style.background = "#fafafa";
          box.style.display = "flex";
          box.style.alignItems = "center";
          box.style.justifyContent = "center";
          box.style.overflow = "hidden";
          
          const img = document.createElement("img");
          img.src = match.userImage;
          img.alt = "Match for cell " + cellIndex;
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = "cover";
          
          box.appendChild(img);
          container.appendChild(box);
        });
      }
      
      const instance = M.Modal.getInstance(modalElem);
      if (instance) {
        instance.open();
      } else {
        M.Modal.init(modalElem);
        M.Modal.getInstance(modalElem).open();
      }
    }
  </script>
</body>
</html>