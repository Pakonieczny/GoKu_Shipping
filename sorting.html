<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Sorting - Single-Click Zoom</title>
  <!-- Materialize CSS -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
  />
  <style>
    body {
      background-color: #fff;
      margin: 0;
      height: 100vh;
      position: relative;
      opacity: 0;
      transition: opacity 0s;
    }
    /* Main Buttons */
    #connectEtsyBtn,
    #testOpenAIBtn,
    #openConfigBtn,
    #cropImagesBtn,
    #sendMatchBtn {
      position: absolute;
      left: 20px;
      width: 140px;
      height: 36px;
    }
    #connectEtsyBtn {
      top: 20px;
    }
    #testOpenAIBtn {
      top: 70px;
    }
    #openConfigBtn {
      top: 120px;
    }
    #cropImagesBtn {
      top: 170px;
    }
    #sendMatchBtn {
      top: 220px;
    }

    /* Etsy Order Number input */
    #etsyOrderNumber {
      position: absolute;
      left: 20px;
      top: 270px;
      width: 300px;
      height: 30px;
      border: 1px solid #999;
      padding: 4px;
      outline: none;
      font-size: 0.9em;
    }

    /* Image Comparison UI */
    #imageComparisonContainer {
      position: absolute;
      left: 20px;
      top: 310px;
    }
    #photoDragDrop {
      width: 100px;
      height: 100px;
      border: 2px dashed #ccc;
      text-align: center;
      line-height: 100px;
      display: inline-block;
      margin-right: 10px;
    }
    #userImage {
      width: 100px;
      height: 100px;
      border: 1px solid #000;
      display: none;
      vertical-align: top;
    }

    /* Container for dynamically generated preview boxes and detail boxes */
    #photoGridContainer {
      position: relative;
      width: 1200px;
      max-height: 700px;
      overflow-y: auto;
      border-left: 1px dashed #ccc;
      border-right: 1px dashed #ccc;
      left: 350px;
      top: 20px;
    }
    /* Preview box styling (110x110) */
    .preview-box {
      position: absolute;
      width: 110px;
      height: 110px;
      border: 1px solid #000;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      user-select: none;
      font-size: 0.7em;
      text-align: center;
    }
    .preview-box img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform-origin: center center;
      transition: transform 0.3s ease;
    }
    /* Detail text boxes: 55px x 7px */
    .detail-box {
      position: absolute;
      width: 55px;
      height: 7px;
      font-size: 0.6em !important;
      border: none !important;
      outline: none !important;
      -webkit-appearance: none !important;
      -moz-appearance: none !important;
      appearance: none !important;
      background: #f0f0f0;
      color: #333;
      padding: 0;
      margin: 0;
      box-shadow: none !important;
    }

    #unmatchedContainer {
      position: absolute;
      left: 20px;
      top: 420px; /* ~100px below #photoDragDrop which starts at top:310px */
      width: 600px;
    }

    /* pointer-events enabled on read-only inputs */
    .detail-box:read-only {
      pointer-events: auto !important;
      cursor: pointer !important;
    }

    /* Config Modal */
    #configModal.modal {
      position: fixed !important;
      top: 50% !important;
      left: 50% !important;
      transform: translate(-50%, -50%) !important;
      width: 250px !important;
      height: 450px !important;
      max-height: none !important;
      overflow-y: auto !important;
    }
    #configTable thead tr th {
      font-size: 0.9em;
    }
    #configTable tbody tr td {
      font-size: 0.8em;
    }
    #configTable .left-input,
    #configTable .top-input,
    #configTable .width-input,
    #configTable .height-input {
      width: 80px !important;
    }
    .modal {
      opacity: 0 !important;
      transform: translateY(20px) scale(0.95) !important;
      will-change: opacity, transform;
      transition: opacity 300ms ease, transform 300ms ease;
    }
    .modal.open {
      opacity: 1 !important;
      transform: translateY(0) scale(1) !important;
    }
    .modal-overlay {
      opacity: 0;
      will-change: opacity;
      transition: opacity 300ms ease;
    }
    .modal-overlay.show {
      opacity: 1;
    }
  </style>
</head>
<body>
  <!-- Main Buttons -->
  <button id="connectEtsyBtn" class="btn waves-effect waves-light">Connect to Etsy</button>
  <button id="openConfigBtn" class="btn waves-effect waves-light">Open Config</button>
  <button id="mpBackBtn" class="btn waves-effect waves-light">Back</button>
  <button id="mpNextBtn" class="btn waves-effect waves-light">Next</button>
  <button id="sendMatchBtn" class="btn waves-effect waves-light">Send & Match</button>
  <button id="matchPrintBtn" class="btn waves-effect waves-light" style="top: 270px;" 
  onclick="initMatchAndPrintFlow()">Match & Print</button>

  <!-- Etsy Order Number input -->
  <input
    type="text"
    id="etsyOrderNumber"
    placeholder="Comma-delimited Etsy Order Numbers"
  />

  <!-- Image Comparison UI -->
  <div id="imageComparisonContainer">
    <div id="photoDragDrop">Drag & Drop</div>
    <div id="unmatchedContainer"></div>
  </div>

  <!-- Container for dynamically generated preview boxes and detail boxes -->
  <div id="photoGridContainer">
    <!-- Preview boxes and detail boxes will be created dynamically -->
  </div>

  <!-- Config Modal -->
  <div id="configModal" class="modal">
    <div class="modal-content">
      <table class="striped" id="configTable">
        <thead>
          <tr>
            <th>Element</th>
            <th>Left (px)</th>
            <th>Top (px)</th>
            <th>Width (px)</th>
            <th>Height</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="modal-footer">
      <a
        href="#!"
        id="saveConfigBtn"
        class="modal-close waves-effect waves-green btn"
      >
        Save Config
      </a>
    </div>
  </div>

  <!-- Matches Modal -->
  <div id="matchesModal" class="modal">
    <div class="modal-content">
      <h5>Successful Image Matches</h5>
      <div
        id="matchesGridContainer"
        style="display: flex; flex-wrap: wrap; gap: 10px;"
      ></div>
    </div>
    <div class="modal-footer">
      <!-- “Save” button that will perform the array updates and then close the modal -->
      <a href="#!" id="saveMatchesBtn" class="waves-effect waves-green btn">Save</a>
      <!-- “Cancel” button that closes the modal without saving changes -->
      <a href="#!" class="modal-close waves-effect waves-red btn">Cancel</a>
    </div>
  </div>

    <!-- 1) Firebase (compat mode) – must be above your main sorting code -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <!-- jQuery & Materialize JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"
  ></script>

  <!-- Everything is in this single <script> block -->
  <script>
/********************************************************
 * Base URL & Global Variables
 ********************************************************/
const functionsBaseUrl = window.location.origin + "/.netlify/functions";

let croppedImagesArray = [];
let userImagesArray = [];
let cellMatches = {};
let partialMatches = {};
let matchPrintFlowInProgress = false;

/********************************************************
 * Firebase Initialization (REQUIRED)
 ********************************************************/
const firebaseConfig = {
  apiKey: "YourApiKeyHere",
  authDomain: "YourAuthDomainHere",
  projectId: "gokudatabase",
  storageBucket: "gokudatabase.firebasestorage.app",
  messagingSenderId: "1078662308113",
  appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();

/********************************************************
 * Etsy Auth, Code Challenge, configIDs
 ********************************************************/
(function () {
  const urlParams = new URLSearchParams(window.location.search);
  const accessToken = urlParams.get("access_token");
  if (accessToken) {
    localStorage.setItem("access_token", accessToken);
    window.history.replaceState({}, document.title, window.location.pathname);
    M.toast({ html: "Connection Successful!" });
    console.log("Access token received:", accessToken);
  } else {
    const authCode = urlParams.get("code");
    if (authCode) {
      const storedCodeVerifier = localStorage.getItem("etsy_code_verifier");
      if (storedCodeVerifier) {
        window.location.href =
          "/.netlify/functions/exchangeToken?code=" +
          encodeURIComponent(authCode) +
          "&code_verifier=" +
          encodeURIComponent(storedCodeVerifier);
      } else {
        console.error("No code verifier found in localStorage.");
      }
    }
  }
})();

function generateRandomString(length) {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let text = "";
  for (let i = 0; i < length; i++) {
    text += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return text;
}

async function generateCodeChallenge(codeVerifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(codeVerifier);
  const digest = await crypto.subtle.digest("SHA-256", data);
  let base64String = btoa(String.fromCharCode(...new Uint8Array(digest)));
  return base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}

// ADDED these two lines so you can reposition/resize them in the Config modal
const configIDs = [
  "connectEtsyBtn",
  "testOpenAIBtn",
  "openConfigBtn",
  "mpBackBtn",
  "mpNextBtn",
  "etsyOrderNumber",
  "photoGridContainer",
  "unmatchedContainer",
  "configModal",
  "configTable",
  "saveConfigBtn",
  "photoDragDrop",
  "sendMatchBtn",
  "matchPrintBtn"
];

/********************************************************
 * DOMContentLoaded: Disable buttons & attach logic
 ********************************************************/
document.addEventListener("DOMContentLoaded", function () {
  M.AutoInit();

  // Disable "Send & Match", "Match & Print", "Back", "Next" on load
  disableSendMatch();
  disableMatchPrintFlow();

  setTimeout(function () {
    loadPositions();
    document.body.style.opacity = 1;
  }, 200);

  // Connect Etsy
  document.getElementById("connectEtsyBtn").addEventListener("click", async function () {
    try {
      const codeVerifier = generateRandomString(64);
      localStorage.setItem("etsy_code_verifier", codeVerifier);
      const codeChallenge = await generateCodeChallenge(codeVerifier);
      const CLIENT_ID = "k75zdspz4r99txpqdji7i2em";
      const redirectUri = "https://sorting.goldenspike.app";
      const state = "randomState123";
      const scope = "listings_w listings_r transactions_r transactions_w";
      const etsyAuthUrl =
        "https://www.etsy.com/oauth/connect?response_type=code" +
        "&client_id=" + CLIENT_ID +
        "&redirect_uri=" + encodeURIComponent(redirectUri) +
        "&scope=" + encodeURIComponent(scope) +
        "&state=" + state +
        "&code_challenge=" + encodeURIComponent(codeChallenge) +
        "&code_challenge_method=S256";
      window.location.href = etsyAuthUrl;
    } catch (err) {
      console.error("OAuth start error:", err);
      M.toast({ html: "OAuth error: " + err.message });
    }
  });

  // Load multiple orders on Enter (partial snippet)
  const etsyOrderInput = document.getElementById("etsyOrderNumber");
etsyOrderInput.addEventListener("keydown", async function (e) {
  if (e.key === "Enter") {

    // ── NEW: reset all arrays & states as if app just opened ──
    croppedImagesArray = [];
    userImagesArray = [];
    cellMatches = {};
    partialMatches = {};
    
    // Optionally also clear out the grid container in the UI
    document.getElementById("photoGridContainer").innerHTML = "";

    disableSendMatch();
    disableMatchPrintFlow();
    removeAllBlueHighlights();

    const inputVal = etsyOrderInput.value.trim();
    if (!inputVal) return;

    let orderNumbers = inputVal
      .split(",")
      .map((x) => x.trim())
      .filter((x) => x);
    orderNumbers = orderNumbers.slice(0, 50);

    await loadBatchEtsyOrders(orderNumbers);
  }
});

  // Attach "Send & Match" logic
  document.getElementById("sendMatchBtn").addEventListener("click", async function () {
    try {
      console.log("Starting to crop images...");
      croppedImagesArray = [];
      await cropAllImages();
      console.log("Done cropping. Pausing 250ms...");
      await new Promise(r => setTimeout(r, 250));
      console.log("Now sending & matching...");
      await sendAndMatch();
    } catch (err) {
      console.error("Error in combined Crop + Send & Match:", err);
    }
  });

  // “Save” inside “Successful Image Matches” modal
  document.getElementById("saveMatchesBtn")?.addEventListener("click", () => {
    disableMatchPrintFlow();
    if (typeof window.currentCorrectedCellIndex === "number") {
    removeHighlightForCell(window.currentCorrectedCellIndex);
  }
    const anyOrangered = detectAnyOrangered();
    if (!anyOrangered) {
      enableMatchPrintFlow();
    }
  });

  // ===== NEW LINE: Start listening for QR scans from sort-scan.html =====
  startScannedSortingListener();
});



/********************************************************
 * Disabling / Enabling “Send & Match”
 ********************************************************/
function disableSendMatch() {
  const btn = document.getElementById("sendMatchBtn");
  btn.disabled = true;
  btn.style.opacity = "0.5";
}
function enableSendMatch() {
  const btn = document.getElementById("sendMatchBtn");
  btn.disabled = false;
  btn.style.opacity = "1";
}

/********************************************************
 * startScannedSortingListener (NEW partial snippet)
 ********************************************************/
async function startScannedSortingListener() {
  try {
    const docRef = db.collection("Brites_Orders").doc("ScannedSortingOrder");
    docRef.onSnapshot((docSnap) => {
      if (!docSnap.exists) {
        console.log("No 'ScannedSortingOrder' doc in Firestore yet.");
        return;
      }
      const docData = docSnap.data();
      if (!docData["Order Number"]) {
        console.log("No 'Order Number' in 'ScannedSortingOrder' doc.");
        return;
      }
      const scannedVal = docData["Order Number"];
      console.log("Scanned Sorting code =>", scannedVal);

      const input = document.getElementById("etsyOrderNumber");
      if (!input) return;
      input.value = scannedVal;

      // [NEW: reset states as if app just opened]
      disableSendMatch();
      disableMatchPrintFlow();
      removeAllBlueHighlights();

      // Programmatically fire an Enter key
      const enterEvent = new KeyboardEvent("keydown", { key: "Enter" });
      input.dispatchEvent(enterEvent);
    });
  } catch (err) {
    console.error("Error starting scannedSortingListener:", err);
  }
}

/********************************************************
 * Enable Back and Next (NEW)
 ********************************************************/
function enableBackNext() {
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");
  if (backBtn) {
    backBtn.disabled = false;
    backBtn.style.opacity = "1";
  }
  if (nextBtn) {
    nextBtn.disabled = false;
    nextBtn.style.opacity = "1";
  }
}

/********************************************************
 * Disabling / Enabling “Match & Print” Flow
 * (i.e. Match & Print button, plus Back and Next)
 ********************************************************/
function disableMatchPrintFlow() {
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  matchPrintBtn.disabled = true;
  matchPrintBtn.style.opacity = "0.5";

  const backBtn = document.getElementById("mpBackBtn");
  backBtn.disabled = true;
  backBtn.style.opacity = "0.5";

  const nextBtn = document.getElementById("mpNextBtn");
  nextBtn.disabled = true;
  nextBtn.style.opacity = "0.5";

  //removeAllBlueHighlights();
}

function enableMatchPrintFlow() {
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");

  matchPrintBtn.disabled = false;
  matchPrintBtn.style.opacity = "1";

  backBtn.disabled = false;
  backBtn.style.opacity = "1";

  nextBtn.disabled = false;
  nextBtn.style.opacity = "1";
}


/********************************************************
 * removeAllBlueHighlights():
 * remove any 3px blue border and the “Print” button overlay
 ********************************************************/
function removeAllBlueHighlights() {
  const previewBoxes = document.querySelectorAll(".preview-box");
  previewBoxes.forEach((pb, i) => {
    pb.style.border = "1px solid #000";
    const matchBox = document.getElementById("matchCell" + i);
    if (matchBox) {
      matchBox.style.fontWeight = "";
    }
  });
  const existingPrintBtn = document.querySelector("button.overlay-print-btn");
  if (existingPrintBtn) {
    existingPrintBtn.remove();
  }
}

// ───── PUT THE NEW HELPER FUNCTION HERE ─────
function removeHighlightForCell(cellIndex) {
  const previewBox = document.getElementById("previewCell" + cellIndex);
  if (previewBox) {
    // If it’s orangered, revert to black:
    if ((previewBox.style.border || "").includes("orangered")) {
      previewBox.style.border = "1px solid #000";
    }
    // If the matchCell text is orangered, revert it:
    const matchBox = document.getElementById("matchCell" + cellIndex);
    if (matchBox && matchBox.style.color === "orangered") {
      matchBox.style.color = "";
      matchBox.style.fontWeight = "";
    }
  }
}


/********************************************************
 * detectAnyOrangered():
 * returns true if any .preview-box is 3px orangered
 * or if #matchCellX is style.color="orangered"
 ********************************************************/
function detectAnyOrangered() {
  let foundOrangered = false;
  const previewBoxes = document.querySelectorAll(".preview-box");
  previewBoxes.forEach((pb) => {
    if ((pb.style.border || "").includes("3px solid orangered")) {
      foundOrangered = true;
    }
  });
  for (let i = 0; i < croppedImagesArray.length; i++) {
    const matchBox = document.getElementById("matchCell" + i);
    if (!matchBox) continue;
    if (matchBox.style.color === "orangered") {
      foundOrangered = true;
    }
  }
  return foundOrangered;
}


/********************************************************
 * “Match & Print” main logic
 ********************************************************/
document.getElementById("matchPrintBtn").addEventListener("click", initMatchAndPrintFlow);

function initMatchAndPrintFlow() {
  console.log("Match & Print pressed.");

  // 1) Gather .preview-box elements and build uniqueOrders array
  const previewBoxes = document.querySelectorAll(".preview-box");
  const uniqueOrders = [];
  previewBoxes.forEach((pb, i) => {
    const orderCell = document.getElementById("orderCell" + i);
    if (orderCell && orderCell.value && !uniqueOrders.includes(orderCell.value)) {
      uniqueOrders.push(orderCell.value);
    }
  });

  // 2) If there are no orders, bail out
  if (!uniqueOrders.length) {
    M.toast({ html: "No orders found to highlight." });
    enableSendMatch();  // re-enable “Send & Match”
    return;
  }

  // 3) Forcefully remove all old 3px blue outlines and old “Print” buttons
  //    so we start fresh from cell0
  removeAllHighlightsAndPrintButtons();

  // 4) currentIndex => start at 0
  let currentIndex = 0;

  // 5) Also disable “Send & Match” while in “Match & Print”
  disableSendMatch();

  // 6) If you want “Back” and “Next” to be enabled now, do it here
  //    e.g. enableMatchPrintFlow() or enableBackNext() if you have that
  enableBackNext();

  // 7) We'll store a reference to the “Print” button so we can remove it when switching orders
  let currentPrintBtn = null;

  // ------------------------------------------------------------------------
  // removeAllHighlightsAndPrintButtons => forcibly remove leftover 3px lines + "Print" buttons
  // ------------------------------------------------------------------------
  function removeAllHighlightsAndPrintButtons() {
    previewBoxes.forEach((pb, i) => {
      pb.style.border = "1px solid #000"; // reset to black
      const matchBox = document.getElementById("matchCell" + i);
      if (matchBox) {
        matchBox.style.fontWeight = "";
      }
    });
    // remove any leftover “Print” button in the DOM
    const leftoverPrintBtns = document.querySelectorAll(".overlay-print-btn");
    leftoverPrintBtns.forEach((btn) => btn.remove());
  }

  // ------------------------------------------------------------------------
  // highlightOrder => highlight all preview cells for a particular order
  // ------------------------------------------------------------------------
function highlightOrder(orderNum) {
  // Always remove leftover highlights + leftover “Print” button first
  removeAllHighlightsAndPrintButtons();

  // We'll keep track of which cell in this order gets the Print button
  let chosenIndexForPrintBtn = -1;

  // Loop over all preview boxes
  previewBoxes.forEach((pb, i) => {
    const orderCell = document.getElementById("orderCell" + i);
    if (orderCell && orderCell.value === orderNum) {
      pb.style.border = "3px solid blue";

      const matchBox = document.getElementById("matchCell" + i);
      if (matchBox) {
        matchBox.style.fontWeight = "bold";
      }

      // If we haven't assigned a print-button cell yet, assign it now
      if (chosenIndexForPrintBtn < 0) {
        chosenIndexForPrintBtn = i;
      }
    }
  });

  // AFTER the loop, we add a Print button only to whichever cell index we picked
  if (chosenIndexForPrintBtn >= 0) {
    const chosenBox = document.getElementById("previewCell" + chosenIndexForPrintBtn);
    createPrintButtonOverBox(chosenBox, chosenIndexForPrintBtn);
  }
}

  // ------------------------------------------------------------------------
  // createPrintButtonOverBox => place a “Print” button on top of the given preview box
  // ------------------------------------------------------------------------
  function createPrintButtonOverBox(previewBox, cellIndex) {
    const rect = previewBox.getBoundingClientRect();
    const btn = document.createElement("button");
    btn.textContent = "Print";
    btn.classList.add("overlay-print-btn");
    btn.style.position = "absolute";
    btn.style.width = "50px";
    btn.style.height = "25px";
    btn.style.background = "rgba(0,0,0,0.5)";
    btn.style.color = "#fff";
    btn.style.border = "none";
    btn.style.left = (rect.left + 30) + "px";
    btn.style.top = (rect.top + 40) + "px";
    btn.style.zIndex = "9999";
    btn.style.cursor = "pointer";

    btn.addEventListener("click", () => openIframePrinterForListing(cellIndex));
    document.body.appendChild(btn);
    return btn;
  }

  // ------------------------------------------------------------------------
  // Immediately highlight cell0 => “uniqueOrders[currentIndex]”
  // so the user sees a 3px blue outline and a "Print" button on cell0 right away
  // ------------------------------------------------------------------------
  highlightOrder(uniqueOrders[currentIndex]);

  // ------------------------------------------------------------------------
  // Hook up “Next” and “Back” logic
  // ------------------------------------------------------------------------
  const backBtn = document.getElementById("mpBackBtn");
  const nextBtn = document.getElementById("mpNextBtn");

  backBtn.onclick = () => {
    if (currentIndex <= 0) {
      M.toast({ html: "Already at the first order." });
      return;
    }
    currentIndex--;
    highlightOrder(uniqueOrders[currentIndex]);
  };

  nextBtn.onclick = () => {
    currentIndex++;
    if (currentIndex >= uniqueOrders.length) {
      M.toast({ html: "Congrats, You’re Done!" });
      removeAllHighlightsAndPrintButtons(); // remove leftover blue lines + “Print” button
      enableSendMatch(); // re-enable “Send & Match” or do whatever you want here
      return;
    }
    highlightOrder(uniqueOrders[currentIndex]);
  };
}


/********************************************************
 * openIframePrinterForListing(cellIndex)
 ********************************************************/
function openIframePrinterForListing(cellIndex) {
  console.log("Opening QR Printer for cell:", cellIndex);

  if (!window.cachedOrderItems) {
    console.warn("No cachedOrderItems found.");
    return;
  }

  // 1) Grab the clicked item
  const item = window.cachedOrderItems[cellIndex];
  if (!item) {
    console.warn("No item found for cellIndex:", cellIndex);
    return;
  }

  // 2) Extract the ship date (or default to "N/A")
  const dispatchDate = item.dispatch_date || "N/A";

  // 3) Filter out all items for this same order
  const orderID = item.receipt_id;
  console.log("Filtering items for order:", orderID);
  const itemsForOrder = window.cachedOrderItems.filter(one => one.receipt_id === orderID);

  // 4) Build an object for QR Printer
  const dataToPrint = {
    dispatchDate,
    items: itemsForOrder,
    userTypedOrderNum: item.typedOrderNumber || "UnknownOrder" // or whatever variable holds the typed Etsy order number
  };
  
  localStorage.setItem("qrPrintAll", JSON.stringify(dataToPrint));

  // 5) Save that object in localStorage
  localStorage.setItem("qrPrintAll", JSON.stringify(dataToPrint));

  // 6) CREATE A HIDDEN 1×1 IFRAME (NO OVERLAY)
  const hiddenIframe = document.createElement("iframe");
  hiddenIframe.style.position = "absolute";
  hiddenIframe.style.width = "1px";
  hiddenIframe.style.height = "1px";
  hiddenIframe.style.opacity = "0";
  hiddenIframe.style.border = "0";
  hiddenIframe.src = "QR Printer.html";
  document.body.appendChild(hiddenIframe);
}
    /********************************************************
     * fillPreviewBoxes, attachPreviewBoxListeners,
     * loadPositions, cropImageFromPreview, etc...
     ********************************************************/
    function loadPositions() {
      configIDs.forEach(function (id) {
        const el = document.getElementById(id);
        if (!el) return;
        const def = {};
        const left = localStorage.getItem("pos-" + id + "-left") || def.left || 0;
        const top = localStorage.getItem("pos-" + id + "-top") || def.top || 0;
        const w = localStorage.getItem("pos-" + id + "-width") || def.width || 0;
        const h = localStorage.getItem("pos-" + id + "-height") || def.height || 0;

        el.style.position = "absolute";
        el.style.left = left + "px";
        el.style.top = top + "px";
        if (parseInt(w, 10) > 0) el.style.width = w + "px";
        if (parseInt(h, 10) > 0) el.style.height = h + "px";
      });
    }

    // --------------- (Your code for config table, openConfigBtn, saveConfigBtn, etc.) --------------
    document.getElementById("openConfigBtn").addEventListener("click", function () {
      populateConfigTable();
      M.Modal.getInstance(document.getElementById("configModal")).open();
    });

    document.getElementById("saveConfigBtn").addEventListener("click", function () {
      configIDs.forEach(function (id) {
        const el = document.getElementById(id);
        if (!el) return;
        const cs = window.getComputedStyle(el);
        localStorage.setItem("pos-" + id + "-left", parseInt(cs.left, 10) || 0);
        localStorage.setItem("pos-" + id + "-top", parseInt(cs.top, 10) || 0);
        localStorage.setItem("pos-" + id + "-width", parseInt(cs.width, 10) || 0);
        localStorage.setItem("pos-" + id + "-height", parseInt(cs.height, 10) || 0);
      });
      M.toast({ html: "Positions saved!" });
    });

    function populateConfigTable() {
      const tbody = document.querySelector("#configTable tbody");
      tbody.innerHTML = "";

      configIDs.forEach(function (id) {
        const el = document.getElementById(id);
        if (!el) return;
        const cs = window.getComputedStyle(el);
        const leftVal = parseInt(cs.left, 10) || 0;
        const topVal = parseInt(cs.top, 10) || 0;
        const widthVal = parseInt(cs.width, 10) || 0;
        const heightVal = parseInt(cs.height, 10) || 0;

        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${id}</td>
          <td><input type="number" value="${leftVal}" data-id="${id}" class="left-input"></td>
          <td><input type="number" value="${topVal}" data-id="${id}" class="top-input"></td>
          <td><input type="number" value="${widthVal}" data-id="${id}" class="width-input"></td>
          <td><input type="number" value="${heightVal}" data-id="${id}" class="height-input"></td>
        `;
        tbody.appendChild(row);

        row.querySelector(".left-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.left = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".top-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.top = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".width-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.width = parseInt(this.value, 10) + "px";
        });
        row.querySelector(".height-input").addEventListener("input", function () {
          const target = document.getElementById(this.dataset.id);
          if (target) target.style.height = parseInt(this.value, 10) + "px";
        });
      });
    }

// --------------- Drag-and-drop logic ---------------
const photoDragDropElem = document.getElementById("photoDragDrop");

photoDragDropElem.addEventListener("dragover", function (e) {
  e.preventDefault();
});

photoDragDropElem.addEventListener("drop", async function (e) {
  e.preventDefault();
  const files = e.dataTransfer.files;

  // We'll track how many new quadrant images we actually add
  let newlyAddedCount = 0;

  for (let i = 0; i < files.length; i++) {
    const file = files[i];

    // Optional: skip if a file with this exact name is already in userImagesArray and is analyzed
    // (Prevents re-dragging the same file from re-adding it)
    if (
      userImagesArray.some(
        (imgObj) => imgObj.name === file.name && imgObj.analyzed === true
      )
    ) {
      console.log("Skipping file already analyzed:", file.name);
      continue;
    }

    // Convert the dropped file to a DataURL
    const fileDataUrl = await readAsDataURL(file);

    // Always treat the entire file as a 2×2 composite
    // => Extract four quadrants, crop each to 512×512, store them in userImagesArray
    const subImages = await extractFourQuadrants(fileDataUrl);
    for (let q = 0; q < subImages.length; q++) {
      const cropped = await cropTo512(subImages[q]);

      // Add each quadrant as its own entry in userImagesArray
      userImagesArray.push({
        name: file.name + "_Q" + q,
        data: cropped,
        analyzed: false,
      });
      newlyAddedCount++;
    }

    M.toast({
      html:
        "File " +
        file.name +
        ": Extracted 4 quadrant images (each 512×512)."
    });
  }

  // After we've processed all dropped files, analyze them if we got new images
  if (newlyAddedCount > 0) {
    await analyzeUserImagesViaOpenAI();
  }
});

// Reads a File object into a DataURL
async function readAsDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

// extractFourQuadrants: always treat image as 2×2
async function extractFourQuadrants(baseDataUrl) {
  // 1) Load the DataURL into an <img>
  const img = await loadImage(baseDataUrl);

  const w = img.naturalWidth;
  const h = img.naturalHeight;
  const halfW = w / 2;
  const halfH = h / 2;

  // Quadrants: top-left, top-right, bottom-left, bottom-right
  const coords = [
    { x: 0,       y: 0 },
    { x: halfW,   y: 0 },
    { x: 0,       y: halfH },
    { x: halfW,   y: halfH }
  ];

  const results = [];
  for (let i = 0; i < coords.length; i++) {
    const canvas = document.createElement("canvas");
    canvas.width = halfW;
    canvas.height = halfH;

    const ctx = canvas.getContext("2d");
    ctx.drawImage(
      img,
      coords[i].x, coords[i].y, halfW, halfH,
      0, 0, halfW, halfH
    );
    results.push(canvas.toDataURL("image/png"));
  }
  return results;
}

// cropTo512: forcibly resize each quadrant to 512×512
async function cropTo512(dataUrl) {
  const loaded = await loadImage(dataUrl);
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(loaded, 0, 0, 512, 512);
  return canvas.toDataURL("image/png");
}

// Utility: load a DataURL into <img> so we can measure width/height
function loadImage(dataUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "Anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}


// --------------- Single-Photo Analysis ---------------
async function openAIAnalyzePhoto(base64Image) {
  const payload = {
    model: "gpt-4o",
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text:
              "1. There's a number in the TOP RIGHT CORNER of the image. Return that number as topRightNumber.\n" +
              "2. The charm color is either gold/yellow, silver/grey, or rose gold/pink. Return as color.\n" +
              '3. Return JSON only. E.g. {"topRightNumber":"42","color":"Gold"}',
          },
          {
            type: "image_url",
            image_url: { url: base64Image, detail: "high" },
          },
        ],
      },
    ],
    max_tokens: 3000,
  };

  console.log("Sending payload to OpenAI:", payload);

  try {
    const response = await fetch(functionsBaseUrl + "/openaiProxy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });
    console.log("Received API response status:", response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Error response text from API:", errorText);
      throw new Error(`Request failed with status ${response.status}`);
    }

    const data = await response.json();
    console.log("OpenAI API response data:", data);

    let rawText = data.choices?.[0]?.message?.content?.trim();
    if (!rawText) {
      console.error("API response does not contain a valid 'choices' array:", data);
      return { topRightNumber: null, color: null };
    }

    console.log("Raw API text response:", rawText);

    // Remove any markdown formatting
    rawText = rawText.replace(/^```(\w+)?/, "").replace(/```$/, "").trim();

    let parsed;
    try {
      parsed = JSON.parse(rawText);
    } catch (e) {
      console.error("Error parsing JSON from API response:", rawText);
      parsed = {};
    }

    return {
      topRightNumber: parsed.topRightNumber || null,
      color: parsed.color || null,
    };
  } catch (err) {
    console.error("Error in openAIAnalyzePhoto API call:", err);
    return { topRightNumber: null, color: null };
  }
}

// --------------- Master Analysis Function ---------------
async function analyzeUserImagesViaOpenAI() {
  // Only pick images that have NOT yet been analyzed
  const imagesToAnalyze = userImagesArray.filter(imgObj => !imgObj.analyzed);

  if (imagesToAnalyze.length === 0) {
    console.log("No new images to analyze.");
    return;
  }

  // Process each image sequentially with a 250ms delay
  for (let i = 0; i < imagesToAnalyze.length; i++) {
    const imgObj = imagesToAnalyze[i];
    await new Promise(resolve => setTimeout(resolve, 250));

    try {
      const result = await openAIAnalyzePhoto(imgObj.data);

      const color = (result.color || "Unknown").toLowerCase();
      const number = result.topRightNumber || "XX";

      let finalColor = "UnknownColor";
      if (color.includes("yellow")) finalColor = "Gold";
      else if (color.includes("pink")) finalColor = "RoseGold";
      else if (color.includes("grey") || color.includes("silver")) finalColor = "Silver";
      else if (color.includes("gold")) finalColor = "Gold";

      // Build the new file name and mark as analyzed.
      imgObj.name = `${finalColor}_${number}.jpg`;
      imgObj.analyzed = true;
      console.log("Analysis complete for image:", imgObj.name);

    } catch (err) {
      console.warn("Analysis failed for an image:", err);
      // Keep the image unchanged if error occurred
    }
  }

  // Save final updates to local storage
  localStorage.setItem("userImagesArray", JSON.stringify(userImagesArray));

  // Show a toast message
  M.toast({ html: "User Image Analysis Has Been Completed" });

  // IMPORTANT: re-engage "Send & Match" here
  enableSendMatch();
}

    /********************************************************
     * fillPreviewBoxes, attachPreviewBoxListeners, etc.
     ********************************************************/
    async function fillPreviewBoxes(items) {
  const container = document.getElementById("photoGridContainer");
  container.innerHTML = "";

  window.cachedOrderItems = items; // store globally

  // Groups for keyword detection:
  const groupA = ["stud", "studs", "stud earrings", "earring", "earrings", "ring", "rings"];
  const groupB = [
    "necklace", "necklaces", "huggie", "huggies", "huggie earrings",
    "hoop", "hoops", "hoop earrings", "bracelet", "bracelets",
    "extender", "extenders", "chain", "chains"
  ];

  items.forEach((item, index) => {
    // 1) Parse the listing title for these words
    item.keywords = [];
    if (item.title) {
      const lowerTitle = item.title.toLowerCase();
      groupA.forEach((phrase) => {
        if (lowerTitle.includes(phrase)) {
          item.keywords.push(phrase);
        }
      });
      groupB.forEach((phrase) => {
        if (lowerTitle.includes(phrase)) {
          item.keywords.push(phrase);
        }
      });
    }

    const row = Math.floor(index / 9);
    const col = index % 9;
    const previewLeft = col * 125;
    const previewTop = row * 165;

    const previewBox = document.createElement("div");
    previewBox.classList.add("preview-box");
    previewBox.id = "previewCell" + index;
    previewBox.style.position = "absolute";
    previewBox.style.left = previewLeft + "px";
    previewBox.style.top = previewTop + "px";
    previewBox.style.width = "110px";
    previewBox.style.height = "110px";
    previewBox.innerHTML = "Loading...";

    const orderInput = document.createElement("input");
    orderInput.type = "text";
    orderInput.readOnly = true;
    orderInput.id = "orderCell" + index;
    orderInput.classList.add("detail-box");
    orderInput.style.left = previewLeft + "px";
    orderInput.style.top = previewTop + 95 + "px";
    orderInput.value = item.receipt_id
      ? item.receipt_id
      : item.orderNumber || "No Order #";
    orderInput.style.fontWeight = "bold";

    const qtyInput = document.createElement("input");
    qtyInput.type = "text";
    qtyInput.readOnly = true;
    qtyInput.id = "quantityCell" + index;
    qtyInput.classList.add("detail-box");
    qtyInput.style.left = previewLeft + "px";
    qtyInput.style.top = previewTop + 107 + "px";
    qtyInput.value = " Qty: " + (item.quantity != null ? item.quantity : 0);

    const metalInput = document.createElement("input");
    metalInput.type = "text";
    metalInput.readOnly = true;
    metalInput.id = "metalCell" + index;
    metalInput.classList.add("detail-box");
    metalInput.style.left = previewLeft + "px";
    metalInput.style.top = previewTop + 119 + "px";
    let metalSel = "";
    if (item.variations && Array.isArray(item.variations)) {
      const acceptedMetalNames = [
        "metal",
        "metal choice",
        "metal - engraving",
        "metal colour",
        "color",
        "metal choice / engraving option",
      ];
      const metalVar = item.variations.find(
        (v) =>
          v.formatted_name &&
          acceptedMetalNames.includes(v.formatted_name.trim().toLowerCase())
      );
      if (metalVar && metalVar.formatted_value) {
        metalSel = metalVar.formatted_value;
      }
    }
    metalInput.value = " Metal: " + (metalSel || "No Metal");

    const matchInput = document.createElement("input");
    matchInput.type = "text";
    matchInput.readOnly = true;
    matchInput.id = "matchCell" + index;
    matchInput.classList.add("detail-box");
    matchInput.style.left = previewLeft + "px";
    matchInput.style.top = previewTop + 131 + "px";
    matchInput.value = "";

    container.appendChild(previewBox);
    container.appendChild(orderInput);
    container.appendChild(qtyInput);
    container.appendChild(metalInput);
    container.appendChild(matchInput);

    // Fetch & show listing image
    fetchListingImages(item.listing_id)
      .then((imageData) => {
        if (imageData && imageData.length > 0) {
          return getLocalImageData(imageData[0].url_fullxfull);
        } else {
          throw "No image data";
        }
      })
      .then((localImageData) => {
        previewBox.innerHTML = `<img src="${localImageData}" alt="Listing ${
          item.listing_id
        }" data-scale="1" data-offsetX="0" data-offsetY="0" />`;
        attachPreviewBoxListeners(previewBox);
      })
      .catch((err) => {
        console.warn("Error loading image for cell " + index + ":", err);
        previewBox.innerHTML = "Img Error";
      });
  });
}

    function attachPreviewBoxListeners(box) {
      let isDragging = false;
      let isMouseDown = false;
      let dragStartX = 0,
        dragStartY = 0;
      let lastX = 0,
        lastY = 0;
      const dragThreshold = 3;

      box.addEventListener("wheel", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        ev.preventDefault();
        let currentScale = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        if (ev.deltaY < 0) {
          currentScale *= 1.1;
        } else {
          currentScale /= 1.1;
          if (currentScale <= 1) {
            currentScale = 1;
            offX = 0;
            offY = 0;
          }
        }
        if (currentScale > 8) currentScale = 8;
        img.dataset.scale = currentScale;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `translate(${offX}px, ${offY}px) scale(${currentScale})`;
      });

      box.addEventListener("mousedown", function (ev) {
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        if (scaleNow <= 1) return;
        ev.preventDefault();
        isMouseDown = true;
        isDragging = false;
        dragStartX = ev.clientX;
        dragStartY = ev.clientY;
        lastX = ev.clientX;
        lastY = ev.clientY;
      });

      box.addEventListener("mousemove", function (ev) {
        if (!isMouseDown) return;
        ev.preventDefault();
        const dxAll = Math.abs(ev.clientX - dragStartX);
        const dyAll = Math.abs(ev.clientY - dragStartY);
        if (dxAll > dragThreshold || dyAll > dragThreshold) isDragging = true;
        const img = box.querySelector("img");
        if (!img) return;
        const scaleNow = parseFloat(img.dataset.scale) || 1;
        let offX = parseFloat(img.dataset.offsetX) || 0;
        let offY = parseFloat(img.dataset.offsetY) || 0;
        const dx = ev.clientX - lastX;
        const dy = ev.clientY - lastY;
        offX += dx;
        offY += dy;
        img.dataset.offsetX = offX;
        img.dataset.offsetY = offY;
        img.style.transform = `translate(${offX}px, ${offY}px) scale(${scaleNow})`;
        lastX = ev.clientX;
        lastY = ev.clientY;
      });

      box.addEventListener("mouseup", function () {
        isMouseDown = false;
      });
      box.addEventListener("mouseleave", function () {
        isMouseDown = false;
      });

      box.addEventListener("click", function (ev) {
        if (isDragging) {
          isDragging = false;
          return;
        }
        const img = box.querySelector("img");
        if (!img) return;
        const rect = box.getBoundingClientRect();
        const boxCenterX = rect.left + box.clientWidth / 2;
        const boxCenterY = rect.top + box.clientHeight / 2;
        const dx = ev.clientX - boxCenterX;
        const dy = ev.clientY - boxCenterY;
        const scale = 5;
        const fudgeY = 10;
        const offsetX = -scale * dx;
        const offsetY = -scale * dy + fudgeY;
        img.dataset.scale = scale;
        img.dataset.offsetX = offsetX;
        img.dataset.offsetY = offsetY;
        img.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      });
    }

    /********************************************************
     * cropAllImages, cropImageFromPreview
     ********************************************************/
    async function cropAllImages() {
      const previewBoxes = document.querySelectorAll(".preview-box");
      for (let i = 0; i < previewBoxes.length; i++) {
        const cell = previewBoxes[i];
        const img = cell.querySelector("img");
        if (img && img.src && img.src !== "") {
          try {
            const cropped = await cropImageFromPreview(cell, 512, 512);
            croppedImagesArray[i] = cropped;
            M.toast({ html: "Cell " + i + ": Cropped successfully." });
          } catch (err) {
            console.error("Cropping failed for cell", i, err);
            M.toast({ html: "Cell " + i + ": Cropping error" });
          }
        }
      }
    }

    function cropImageFromPreview(cell, canvasWidth, canvasHeight) {
      return new Promise((resolve, reject) => {
        const imgElem = cell.querySelector("img");
        if (!imgElem) {
          reject("No image element found");
          return;
        }

        const cellRect = cell.getBoundingClientRect();
        const imgRect = imgElem.getBoundingClientRect();

        const visibleLeft = Math.max(cellRect.left, imgRect.left);
        const visibleTop = Math.max(cellRect.top, imgRect.top);
        const visibleRight = Math.min(cellRect.right, imgRect.right);
        const visibleBottom = Math.min(cellRect.bottom, imgRect.bottom);

        if (visibleRight <= visibleLeft || visibleBottom <= visibleTop) {
          reject("No visible intersection");
          return;
        }

        const visibleWidth = visibleRight - visibleLeft;
        const visibleHeight = visibleBottom - visibleTop;

        const sourceImage = new Image();
        sourceImage.crossOrigin = "Anonymous";
        sourceImage.onload = function () {
          const ratioX = sourceImage.naturalWidth / imgRect.width;
          const ratioY = sourceImage.naturalHeight / imgRect.height;

          const srcX = (visibleLeft - imgRect.left) * ratioX;
          const srcY = (visibleTop - imgRect.top) * ratioY;
          const srcWidth = visibleWidth * ratioX;
          const srcHeight = visibleHeight * ratioY;

          const canvas = document.createElement("canvas");
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(
            sourceImage,
            srcX,
            srcY,
            srcWidth,
            srcHeight,
            0,
            0,
            canvasWidth,
            canvasHeight
          );
          resolve(canvas.toDataURL());
        };
        sourceImage.onerror = function (e) {
          reject(e);
        };
        sourceImage.src = imgElem.src;
      });
    }

/********************************************************
 * loadBatchEtsyOrders, fetchListingImages, getLocalImageData
 ********************************************************/

async function loadBatchEtsyOrders(orderNumbers) {
  try {
    M.toast({ html: "Loading " + orderNumbers.length + " order(s)..." });
    const token = localStorage.getItem("access_token") || "";
    let combinedItems = [];

    for (let i = 0; i < orderNumbers.length; i++) {
      const ord = orderNumbers[i];
      const url = functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(ord);
      const resp = await fetch(url, { headers: { "access-token": token } });
      if (!resp.ok) {
        console.warn("Order fetch failed for " + ord + ", status=" + resp.status);
        continue;
      }

      const data = await resp.json();
      console.log("Etsy Order Data:", data);

      // -- NEW CODE: attach the typed order # to each transaction --
      if (data.transactions && Array.isArray(data.transactions)) {
        data.transactions.forEach((t) => {
          t.typedOrderNumber = ord;
        });
      } else {
        console.warn("No transactions for order " + ord);
      }

      // ------------------------------------------------
      // APPLY THE SAME METHODOLOGY AS index.html
      // ------------------------------------------------
      if (data.transactions && data.transactions.length > 0) {
        const firstTrans = data.transactions[0];
        if (firstTrans.expected_ship_date) {
          // Convert from Unix to a nice, short date
          const sTS = new Date(firstTrans.expected_ship_date * 1000);
          const sDay = ("0" + sTS.getDate()).slice(-2);
          const monthNamesF = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
          const sMonth = monthNamesF[sTS.getMonth()];
          const sYear = sTS.getFullYear();

          // e.g. "25 Sep 2025"
          const formattedShipDate = sDay + " " + sMonth + " " + sYear;

          // Attach this to ALL transactions, so our code sees `t.dispatch_date`
          data.transactions.forEach((t) => {
            t.dispatch_date = formattedShipDate;
          });
        }
      }

      // If there’s an array of transactions, merge them in
      if (data.transactions && Array.isArray(data.transactions)) {
        combinedItems.push(...data.transactions);
      } else {
        console.warn("No transactions for order", ord);
      }
    }

    // Then fill the UI with combined results
    await fillPreviewBoxes(combinedItems);

  } catch (err) {
    console.error("Error loading batch orders:", err);
    M.toast({ html: "Error: " + err.message });
  }
}

async function fetchListingImages(listingId) {
  const token = localStorage.getItem("access_token") || "";
  const resp = await fetch(functionsBaseUrl + "/etsyImages?listingId=" + listingId, {
    headers: { "access-token": token },
  });
  if (!resp.ok) {
    console.warn("Image fetch HTTP error:", resp.status);
    return [];
  }
  const data = await resp.json();
  return data.results || [];
}

async function getLocalImageData(imageUrl) {
  try {
    const response = await fetch(
      functionsBaseUrl + "/imageProxy?url=" + encodeURIComponent(imageUrl)
    );
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (err) {
    console.error("Error in getLocalImageData:", err);
    throw err;
  }
}

    /********************************************************
 * compareImages, sendAndMatch, partialMatches, etc.
 ********************************************************/
async function compareImages(userImage, croppedGridImage, cellIndex, userImageName, signal = undefined) {
  const payload = {
    model: "gpt-4o",
    messages: [
      {
        role: "user",
        content: [
          {
            type: "text",
            text:
              "1. The Similarity Score is to be strictly measured on the similarity of the jewelry charm / pendant between the 2 images " +
              "2. Focus on the charm outline and silhouette and compare the cutouts or holes within the charm " +
              "3. Focus on the engraving existance, design, shapes on top of the charm itself " +
              "4. Return a similarity score that combines the outline and silhouette score + the similarity score for engraving size, existance, location, orientation etc.. " +
              "5. If you detect an animal charm then strictly focus on the position, size and orientation of the head, eyes, beak, mouth, ears, legs, wings etc.. " +
              "6. Ignore and disregard all background and accessories around and attached to charm such as necklaces, chains, hoops, rings, clothing, or skin " +
              "7. Return a numeric similarity score between 0.0000 and 1.0000 with EXACTLY four decimal places, for example 0.8937, 0.9231, or 1.675, and no additional text " +
              "8. Examine all details on top and inside each engraved charm " +
              "9. Emphasize the pose and direction the charm is facing ",
          },
          { type: "image_url", image_url: { url: userImage, detail: "high" } },
          { type: "image_url", image_url: { url: croppedGridImage, detail: "high" } },
        ],
      },
    ],
    max_tokens: 5000,
  };

  try {
    const response = await fetch(functionsBaseUrl + "/openaiProxy", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      signal,
    });
    if (!response.ok) {
      throw new Error("OpenAI compareImages call failed with " + response.status);
    }
    const data = await response.json();

    let similarityText = data.choices[0].message.content.trim();
    similarityText = similarityText.replace(/[^\d.]/g, ""); // keep only digits & dots

    let score = parseFloat(similarityText);
    if (isNaN(score)) {
      score = 0.0;
    }
    return { score };
  } catch (err) {
    console.error("Error comparing images with OpenAI:", err);
    return { score: 0.0 };
  }
}

/********************************************************
 * sendAndMatch with metal filter logic
 ********************************************************/
async function sendAndMatch() {
  // (A) Disable "Match & Print" at the start
  const matchPrintBtn = document.getElementById("matchPrintBtn");
  matchPrintBtn.disabled = true;
  matchPrintBtn.style.opacity = "0.5"; // greyed out

  if (userImagesArray.length === 0) {
    M.toast({ html: "No user images available! Please drop user images first." });
    return;
  }
  if (!croppedImagesArray || croppedImagesArray.length === 0) {
    M.toast({ html: "No cropped grid images available! Please crop images first." });
    return;
  }

  // --------------------------------------------------
  // NEW HELPER: checks if a user image name is allowed
  // based on the 3rd read-only text box metal content.
  // --------------------------------------------------
  function metalFilterOk(metalVal, userName) {
    // Lowercase everything for consistent comparison
    const metalLow = metalVal.toLowerCase();
    const nameLow = userName.toLowerCase();

    // If the metalVal includes "silver"
    if (metalLow.includes("silver")) {
      return nameLow.includes("silver");
    }
    // If the metalVal includes "rosegold"
    else if (metalLow.includes("rosegold")) {
      return (nameLow.includes("rose") || nameLow.includes("rosegold"));
    }
    // If the metalVal includes "rose"
    else if (metalLow.includes("rose")) {
      return (nameLow.includes("rose") || nameLow.includes("rosegold"));
    }
    // If the metalVal includes "gold"
    else if (metalLow.includes("gold")) {
      return nameLow.includes("gold");
    }
    // Otherwise, no specific metal => allow any
    return true;
  }

  //---------------------------------------------------------------------
  // FIRST PASS
  //---------------------------------------------------------------------
  let unmatchedCells = [];
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (croppedImagesArray[i]) {
      unmatchedCells.push(i);
    }
  }

  // These sets track matched user images & matched Etsy cells
  const matchedUserNames = new Set();
  const matchedCellIndices = new Set();

  for (const i of unmatchedCells) {
    // Already matched? skip
    if (matchedCellIndices.has(i)) continue;
    const matchBox = document.getElementById("matchCell" + i);

    // Grab the metal from the 3rd read-only text box
    const metalVal = document.getElementById("metalCell" + i).value || "";

    // Filter user images: keep only those that pass "metalFilterOk"
    const validUserImages = userImagesArray.filter((u) => metalFilterOk(metalVal, u.name));

    // Compare all valid user images in parallel, staggered
    const comparisonPromises = validUserImages.map((user, j) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          // If user/cell is matched, skip
          if (matchedUserNames.has(user.name) || matchedCellIndices.has(i)) {
            return resolve({ result: { score: 0 }, user });
          }
          compareImages(user.data, croppedImagesArray[i], i, user.name)
            .then((result) => resolve({ result, user }))
            .catch((err) => {
              console.error("First-pass compare error:", i, user.name, err);
              resolve({ result: { score: 0 }, user });
            });
        }, j * 250);
      });
    });

    const results = await Promise.all(comparisonPromises);
    results.sort((a, b) => b.result.score - a.result.score);

    if (!results.length || results[0].result.score === 0) {
      M.toast({ html: `Cell ${i}: No valid matches in first pass.` });
    } else {
      const topCandidate = results[0];
      const topScore = topCandidate.result.score;
      const topScorePerc = (topScore * 100).toFixed(2);
      const matchName = topCandidate.user.name.replace(/(\.jpg|\.png)$/i, "");

      if (!matchedUserNames.has(topCandidate.user.name) && !matchedCellIndices.has(i)) {
        const secondScore = results[1]?.result.score ?? 0;
        const delta = topScore - secondScore;

        if (topScore >= 0.98) {
          M.toast({
            html: `Cell ${i}: First-pass match ≥ 98% => ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });

          matchedUserNames.add(topCandidate.user.name);
          matchedCellIndices.add(i);

          // Remove user so it can't match again
          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);

        } else if (topScore >= 0.88 && delta >= 0.15) {
          M.toast({
            html: `Cell ${i}: Delta ≥ 15% & top ≥ 88% => Accepting ${matchName} (${topScorePerc}%)`
          });
          if (matchBox) {
            matchBox.value = matchName;
            matchBox.style.fontWeight = "";
            matchBox.style.color = "";
          }
          if (!cellMatches[i]) cellMatches[i] = [];
          cellMatches[i].push({
            userName: matchName,
            userImage: topCandidate.user.data,
            score: topScore
          });

          matchedUserNames.add(topCandidate.user.name);
          matchedCellIndices.add(i);

          userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);
        }
        // else => no acceptance in first pass
      }
    }

    // 2s cooldown
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  // -----------------------------------------------------------------------
  // SECOND PASS
  // -----------------------------------------------------------------------
  unmatchedCells = [];
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (!matchedCellIndices.has(i)) {
      unmatchedCells.push(i);
    }
  }

  for (const i of unmatchedCells) {
    const matchBox = document.getElementById("matchCell" + i);
    const metalVal = document.getElementById("metalCell" + i).value || "";
    const validUserImages = userImagesArray.filter((u) => metalFilterOk(metalVal, u.name));

    const comparisonPromises = validUserImages.map((user, j) => {
      return new Promise((resolve) => {
        setTimeout(() => {
          if (matchedUserNames.has(user.name) || matchedCellIndices.has(i)) {
            return resolve({ result: { score: 0 }, user });
          }
          compareImages(user.data, croppedImagesArray[i], i, user.name)
            .then((result) => resolve({ result, user }))
            .catch((err) => {
              console.error("Second-pass compare error:", i, user.name, err);
              resolve({ result: { score: 0 }, user });
            });
        }, j * 250);
      });
    });

    const results = await Promise.all(comparisonPromises);
    results.sort((a, b) => b.result.score - a.result.score);

    if (!results.length || results[0].result.score === 0) {
      M.toast({ html: `Cell ${i}: No valid matches found in second pass.` });
    } else {
      const topCandidate = results[0];
      const topScore = topCandidate.result.score;
      const topScorePerc = (topScore * 100).toFixed(2);
      const matchName = topCandidate.user.name.replace(/(\.jpg|\.png)$/i, "");

      M.toast({
        html: `Cell ${i}: Best candidate => ${matchName} (${topScorePerc}%)`
      });

      if (topScore === 1.0 || topScore >= 0.98) {
        if (matchBox) {
          matchBox.value = matchName;
          matchBox.style.fontWeight = "";
          matchBox.style.color = "";
        }
        if (!cellMatches[i]) cellMatches[i] = [];
        cellMatches[i].push({
          userName: matchName,
          userImage: topCandidate.user.data,
          score: topScore
        });

        matchedUserNames.add(topCandidate.user.name);
        matchedCellIndices.add(i);

        userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);

      } else if (topScore >= 0.88) {
        matchBox.value = matchName;
        matchBox.style.fontWeight = "bold";
        matchBox.style.color = "orangered";

        if (!cellMatches[i]) cellMatches[i] = [];
        cellMatches[i].push({
          userName: matchName,
          userImage: topCandidate.user.data,
          score: topScore
        });

        matchedUserNames.add(topCandidate.user.name);
        matchedCellIndices.add(i);

        userImagesArray = userImagesArray.filter(u => u.name !== topCandidate.user.name);

      } else {
        M.toast({ html: `Cell ${i}: Score ${topScorePerc}% < 88%. No match.` });
      }
    }
    // 2s cooldown
    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  // (A) Highlight cells that truly have NO matches
  for (let i = 0; i < croppedImagesArray.length; i++) {
    if (!cellMatches[i] || cellMatches[i].length === 0) {
      const previewBox = document.getElementById("previewCell" + i);
      if (previewBox) {
        previewBox.style.border = "3px solid orangered";
      }
    }
  }

  // (B) Add click listeners for the 4th (match) box after second pass
  for (let i = 0; i < croppedImagesArray.length; i++) {
    const matchInput = document.getElementById("matchCell" + i);
    if (!matchInput) continue;
    matchInput.removeEventListener("click", onMatchClick);
    matchInput.addEventListener("click", onMatchClick);

    function onMatchClick() {
      openMatchPreviewModal(i);
    }
  }

  M.toast({ html: "Finished matching passes." });

  // (C) Re-enable "Match & Print" ONLY if detectAnyOrangered() returns false
  const anyOrangered = detectAnyOrangered();
if (!anyOrangered) {
  enableMatchPrintFlow(); // this function sets all 3 buttons to enabled
} else {
  disableMatchPrintFlow(); // this function sets all 3 buttons to disabled
}
}

/********************************************************
 * detectAnyOrangered():
 * Checks all .preview-box for “3px solid orangered” border,
 * and all #matchCellX for “orangered” text color.
 * Returns true if found, else false.
 ********************************************************/
function detectAnyOrangered() {
  let foundOrangered = false;

  // A) Check 3px orangered border
  const previewBoxes = document.querySelectorAll(".preview-box");
  previewBoxes.forEach((pb) => {
    if ((pb.style.border || "").includes("3px solid orangered")) {
      foundOrangered = true;
    }
  });

  // B) Check orangered text color in matchCell
  for (let i = 0; i < croppedImagesArray.length; i++) {
    const matchBox = document.getElementById("matchCell" + i);
    if (!matchBox) continue;
    if (matchBox.style.color === "orangered") {
      foundOrangered = true;
    }
  }
  return foundOrangered;
}

/********************************************************
 * openMatchPreviewModal (unchanged except where noted)
 ********************************************************/
function openMatchPreviewModal(cellIndex) {
  const modalElem = document.getElementById("matchesModal");
  const container = document.getElementById("matchesGridContainer");
  container.innerHTML = "";

  // 1) Grab the Etsy-derived photo from croppedImagesArray
  const etsyDerived = croppedImagesArray[cellIndex];

  // 2) Build local matched array & unmatched array
  let matchedImages = cellMatches[cellIndex] || [];
  if (matchedImages.length > 1) {
    matchedImages = [matchedImages[0]]; // keep only the first match
  }

  let unmatchedImages = userImagesArray.filter((uImg) => {
    if (partialMatches[uImg.name]) return false;
    // Filter out images that are already matched
    return !(
      matchedImages.length > 0 &&
      stripExtension(uImg.name) === matchedImages[0].userName
    );
  });

  // If matchedImages is empty, push a placeholder
  if (matchedImages.length === 0) {
    matchedImages.push({ userName: "", userImage: null, score: 0 });
  }

  // -----------------------------------------------------------------------
  // A) Etsy Photo
  // -----------------------------------------------------------------------
  const etsyWrapper = document.createElement("div");
  etsyWrapper.style.display = "flex";
  etsyWrapper.style.flexDirection = "column";
  etsyWrapper.style.marginBottom = "20px";

  const etsyLabel = document.createElement("div");
  etsyLabel.textContent = "Etsy Photo:";
  etsyLabel.style.fontWeight = "bold";
  etsyLabel.style.fontSize = "0.7em";
  etsyLabel.style.marginBottom = "7px";
  etsyWrapper.appendChild(etsyLabel);

  const etsyBox = document.createElement("div");
  etsyBox.style.width = "100px";
  etsyBox.style.height = "100px";
  etsyBox.style.border = "1px solid #000";
  etsyBox.style.overflow = "hidden";

  if (etsyDerived) {
    const etsyImg = document.createElement("img");
    etsyImg.src = etsyDerived;
    etsyImg.alt = `Etsy Photo for cell ${cellIndex}`;
    etsyImg.style.width = "100%";
    etsyImg.style.height = "100%";
    etsyImg.style.objectFit = "cover";
    etsyBox.appendChild(etsyImg);
  } else {
    etsyBox.innerHTML = "No Etsy Photo";
    etsyBox.style.display = "flex";
    etsyBox.style.alignItems = "center";
    etsyBox.style.justifyContent = "center";
    etsyBox.style.fontWeight = "bold";
  }
  etsyWrapper.appendChild(etsyBox);
  container.appendChild(etsyWrapper);

  // -----------------------------------------------------------------------
  // B) Matched Photo (shifted 75px right)
  // -----------------------------------------------------------------------
  const matchedWrapper = document.createElement("div");
  matchedWrapper.style.display = "flex";
  matchedWrapper.style.flexDirection = "column";
  matchedWrapper.style.marginBottom = "20px";
  matchedWrapper.style.marginLeft = "75px";

  const matchedTitle = document.createElement("div");
  matchedTitle.textContent = "Matched User Photo:";
  matchedTitle.style.fontWeight = "bold";
  matchedTitle.style.fontSize = "0.7em";
  matchedTitle.style.marginBottom = "7px";
  matchedWrapper.appendChild(matchedTitle);

  const matchedSection = document.createElement("div");
  matchedSection.style.display = "flex";
  matchedSection.style.flexWrap = "wrap";
  matchedSection.style.gap = "10px";

  matchedImages.forEach((mImg, idx) => {
    const box = document.createElement("div");
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";

    box.dataset.type = "matched";
    box.dataset.index = idx;

    if (!mImg.userImage) {
      box.innerHTML = "No Match Found";
      box.style.fontWeight = "bold";
      makeDropTarget(box); // so user can drop a new matched photo here
    } else {
      const img = document.createElement("img");
      img.src = mImg.userImage;
      img.alt = mImg.userName;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";

      makeDraggable(box);
      makeDropTarget(box);
      box.appendChild(img);
    }

    matchedSection.appendChild(box);
  });

  matchedWrapper.appendChild(matchedSection);
  container.appendChild(matchedWrapper);

  // -----------------------------------------------------------------------
  // C) Unmatched Photos (shifted 75px right)
  // -----------------------------------------------------------------------
  const unmatchedWrapper = document.createElement("div");
  unmatchedWrapper.style.display = "flex";
  unmatchedWrapper.style.flexDirection = "column";
  unmatchedWrapper.style.marginLeft = "75px"; // shift right

  const unmatchedTitle = document.createElement("div");
  unmatchedTitle.textContent = "Unmatched User Photos:";
  unmatchedTitle.style.fontWeight = "bold";
  unmatchedTitle.style.fontSize = "0.7em";
  unmatchedTitle.style.marginBottom = "7px";
  unmatchedWrapper.appendChild(unmatchedTitle);

  const unmatchedSection = document.createElement("div");
  unmatchedSection.style.display = "flex";
  unmatchedSection.style.flexWrap = "wrap";
  unmatchedSection.style.gap = "5px";

  // If unmatchedImages is empty, create ONE 66×66 box
  if (unmatchedImages.length === 0) {
    const box = document.createElement("div");
    box.style.width = "66px";
    box.style.height = "66px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";

    box.dataset.type = "unmatchedEmpty";
    box.innerHTML = "No Unmatched Photos";
    box.style.fontWeight = "bold";
    box.style.fontSize = "0.7em";

    makeDropTarget(box); // allow user to drop a matched photo here
    unmatchedSection.appendChild(box);

  } else {
    // Otherwise show each unmatched image normally
    unmatchedImages.forEach((uImg, idx) => {
      const box = document.createElement("div");
      box.style.width = "66px";
      box.style.height = "66px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";
      box.style.position = "relative";

      box.dataset.type = "unmatched";
      box.dataset.index = idx;

      const img = document.createElement("img");
      img.src = uImg.data;
      img.alt = uImg.name;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";

      makeDraggable(box);
      box.appendChild(img);
      unmatchedSection.appendChild(box);
    });
  }

  unmatchedWrapper.appendChild(unmatchedSection);
  container.appendChild(unmatchedWrapper);

  // -------------------------------------------------------------
  // 1) Initialize the modal WITHOUT onCloseEnd
  // -------------------------------------------------------------
  const instance = M.Modal.init(modalElem);

  // -------------------------------------------------------------
  // 2) "Save" button merges arrays & closes modal
  // -------------------------------------------------------------
document.getElementById("saveMatchesBtn").addEventListener("click", () => {

    window.currentCorrectedCellIndex = cellIndex;

  // A) Overwrite cellMatches for this cellIndex
  cellMatches[cellIndex] = matchedImages;

  // B) Rebuild userImagesArray after any drag/drop changes
  const newUserArr = [...userImagesArray];

  // 1) Remove matched images from user array
  matchedImages.forEach((mImg) => {
    const idx = newUserArr.findIndex(
      (u) => stripExtension(u.name) === mImg.userName
    );
    if (idx >= 0) newUserArr.splice(idx, 1);
  });

  // 2) Re-add any newly unmatched images
  unmatchedImages.forEach((u) => {
    const dupIdx = newUserArr.findIndex((x) => x.name === u.name);
    if (dupIdx >= 0) newUserArr.splice(dupIdx, 1);
    newUserArr.push(u);
  });

  userImagesArray = newUserArr;

  // C) Refresh the matchCell text
  const matchBox = document.getElementById("matchCell" + cellIndex);
  if (matchBox) {
    if (matchedImages.length > 0 && matchedImages[0].userImage) {
      matchBox.value = matchedImages[0].userName;
      matchBox.style.fontWeight = "";
      matchBox.style.color = "";
    } else {
      matchBox.value = "";
    }
  }

  // D) After saving, if the matched user photo has a real photo,
  //    always change border to 1px black. Otherwise, set 3px orangered.
  if (
    matchedImages.length > 0 &&
    matchedImages[0].userImage
  ) {
    setEtsyBorder(cellIndex, "1px", "black");
  } else {
    setEtsyBorder(cellIndex, "3px", "orangered");
  }

  // If you have a function to refresh unmatched user images
  if (typeof createUnmatchedUserImagesPreview === "function") {
    createUnmatchedUserImagesPreview();
  }

  // (NEW) Check whether there's orangered and enable/disable the flow
  const anyOrangered = detectAnyOrangered();
  if (anyOrangered) {
    disableMatchPrintFlow(); // disable "Match & Print," "Back," "Next"
  } else {
    enableMatchPrintFlow();  // enable them if no orangered
  }

  // E) Close the modal
  instance.close();
});

  // -------------------------------------------------------------
  // 3) Open the modal
  // -------------------------------------------------------------
  instance.open();

  // -------------------------------------------------------------
  // 4) DRAG & DROP HELPERS
  // -------------------------------------------------------------
  function makeDraggable(elem) {
    elem.setAttribute("draggable", true);
    elem.addEventListener("dragstart", (ev) => {
      ev.dataTransfer.setData(
        "text/plain",
        JSON.stringify({
          sourceType: elem.dataset.type,
          sourceIndex: elem.dataset.index
        })
      );
    });
  }

  function makeDropTarget(elem) {
    elem.addEventListener("dragover", (ev) => {
      ev.preventDefault();
    });

    elem.addEventListener("drop", (ev) => {
      ev.preventDefault();
      const data = ev.dataTransfer.getData("text/plain");
      if (!data) return;
      let parsed;
      try {
        parsed = JSON.parse(data);
      } catch (err) {
        return;
      }

      // 1) "matched" => "unmatched" or "unmatchedEmpty"
      if (
        parsed.sourceType === "matched" &&
        (elem.dataset.type === "unmatched" ||
          elem.dataset.type === "unmatchedEmpty")
      ) {
        const sourceIdx = parseInt(parsed.sourceIndex, 10);
        const matchedImg = matchedImages[sourceIdx];

        // Add that matchedImg into the unmatched array
        unmatchedImages.push({
          name: matchedImg.userName + ".jpg",
          data: matchedImg.userImage
        });

        // Remove from matchedImages
        matchedImages.splice(sourceIdx, 1);

        // If matched is empty, add a placeholder
        if (matchedImages.length === 0) {
          matchedImages.push({ userName: "", userImage: null, score: 0 });
        }

        refreshSectionsLocal();
      }

      // 2) "unmatched" => "matched"
      else if (
        parsed.sourceType === "unmatched" &&
        elem.dataset.type === "matched"
      ) {
        const sourceIdx = parseInt(parsed.sourceIndex, 10);
        const unmatchedImg = unmatchedImages[sourceIdx];

        // SINGLE MATCH LOGIC:
        // Remove the existing matched image or placeholder
        if (matchedImages.length > 0) {
          // If the existing "matched" is just a placeholder, remove it
          if (!matchedImages[0].userImage) {
            matchedImages.splice(0, 1);
          } else {
            // Otherwise push existing matched image to unmatched
            unmatchedImages.push({
              name: matchedImages[0].userName + ".jpg",
              data: matchedImages[0].userImage,
              score: matchedImages[0].score || 0
            });
            matchedImages.splice(0, 1);
          }
        }

        // Now add the newly dragged image
        matchedImages.push({
          userName: stripExtension(unmatchedImg.name),
          userImage: unmatchedImg.data,
          score: 0
        });

        // Remove from unmatched
        unmatchedImages.splice(sourceIdx, 1);

        refreshSectionsLocal();
      }
    });
  }

function refreshSectionsLocal() {
  matchedSection.innerHTML = "";
  unmatchedSection.innerHTML = "";

  // Rebuild matched
  matchedImages.forEach((mImg, i) => {
    const box = document.createElement("div");
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";
    box.dataset.type = "matched";
    box.dataset.index = i;

    if (!mImg.userImage) {
      box.innerHTML = "No Match Found";
      box.style.fontWeight = "bold";
      makeDropTarget(box);
    } else {
      const img = document.createElement("img");
      img.src = mImg.userImage;
      img.alt = mImg.userName;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";

      makeDraggable(box);
      makeDropTarget(box);
      box.appendChild(img);
    }
    matchedSection.appendChild(box);
  });

  // If matched box is currently empty => set border orangered 3px
  // otherwise black 1px
  if (!matchedImages[0].userImage) {
    setEtsyBorder(cellIndex, "3px", "orangered");
  } else {
    setEtsyBorder(cellIndex, "1px", "black");
  }

  // Rebuild unmatched
  if (unmatchedImages.length === 0) {
    const box = document.createElement("div");
    box.style.width = "66px";
    box.style.height = "66px";
    box.style.border = "1px solid #000";
    box.style.display = "flex";
    box.style.alignItems = "center";
    box.style.justifyContent = "center";
    box.style.overflow = "hidden";
    box.style.position = "relative";

    box.style.fontWeight = "bold";
    box.style.fontSize = "0.7em";

    box.dataset.type = "unmatchedEmpty";
    box.innerHTML = "No Unmatched Photos";

    makeDropTarget(box);
    unmatchedSection.appendChild(box);

  } else {
    unmatchedImages.forEach((uImg, i) => {
      const box = document.createElement("div");
      box.style.width = "66px";
      box.style.height = "66px";
      box.style.border = "1px solid #000";
      box.style.display = "flex";
      box.style.alignItems = "center";
      box.style.justifyContent = "center";
      box.style.overflow = "hidden";
      box.style.position = "relative";
      box.dataset.type = "unmatched";
      box.dataset.index = i;

      const img = document.createElement("img");
      img.src = uImg.data;
      img.alt = uImg.name;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = "cover";

      makeDraggable(box);
      makeDropTarget(box);
      box.appendChild(img);
      unmatchedSection.appendChild(box);
    });
  }
}

 // Utility: set the Etsy-derived preview box border
 function setEtsyBorder(cellIdx, thickness, color) {
   const previewBox = document.getElementById("previewCell" + cellIdx);
   if (previewBox) {
     previewBox.style.border = thickness + " solid " + color;
   }
 }

 // Another Utility
 function stripExtension(fileName) {
   return fileName.replace(/\.\w+$/, "");
 }

 // Finally, ensure immediate drag-and-drop by calling refreshSectionsLocal
 refreshSectionsLocal();
}

/********************************************************
 * The createUnmatchedUserImagesPreview function
 ********************************************************/
function createUnmatchedUserImagesPreview() {
  const unmatchedContainer = document.getElementById("unmatchedContainer");
  if (!unmatchedContainer) return;
  unmatchedContainer.innerHTML = ""; // Clear old previews

  // 1) Filter out any images that are partially matched:
  //    If partialMatches has an entry keyed by userImg.name, that means partial match
  const trulyUnmatchedImages = userImagesArray.filter(userImg => {
    return !partialMatches[userImg.name];
  });

  // 2) Spacing: 66px box width + 5px gap = 71px total step horizontally & vertically
  const imagesPerRow = 3;
  const boxSize = 66;
  const gap = 5;
  const step = boxSize + gap; // = 71

  // 3) Create 66×66 previews for these leftover images
  trulyUnmatchedImages.forEach((userImg, i) => {
    const row = Math.floor(i / imagesPerRow);
    const col = i % imagesPerRow;
    const leftPx = col * step;
    const topPx = row * step;

    const previewBox = document.createElement("div");
    previewBox.classList.add("preview-box");
    previewBox.style.position = "absolute";
    previewBox.style.left = leftPx + "px";
    previewBox.style.top = topPx + "px";
    previewBox.style.width = boxSize + "px";
    previewBox.style.height = boxSize + "px";

    // Insert the unmatched user image
    previewBox.innerHTML = `
      <img src="${userImg.data}"
           alt="${userImg.name}"
           data-scale="1"
           data-offsetX="0"
           data-offsetY="0"
           style="width:100%; height:100%; object-fit:cover;" />
    `;

    // Attach the same wheel-zoom, single-click zoom, & drag-panning
    attachPreviewBoxListeners(previewBox);

    unmatchedContainer.appendChild(previewBox);
  });
}
    
    // ---------------------------------------------------------
    // Pull Etsy order details and update grid details
    // ---------------------------------------------------------
    function pullEtsyOrderDetails(orderNumber) {
      console.log("Pulling Etsy order details for order number:", orderNumber);
      var token = localStorage.getItem("access_token");
      return fetch(functionsBaseUrl + "/etsyOrderProxy?orderId=" + encodeURIComponent(orderNumber), {
        headers: { "access-token": token }
      })
      .then(function(r) { return r.json(); })
      .then(function(data) {
        console.log("Etsy Order Data:", data);
        return data;
      })
      .catch(function(err) {
        console.error("Error fetching Etsy order details:", err);
        return null;
      });
    }
    
    // Example: update the grid details using pulled Etsy order details
    async function updateImageGrid(data) {
      let items = [];
      if (data.transactions && Array.isArray(data.transactions)) {
        items = data.transactions;
      } else if (Array.isArray(data)) {          
        items = data;
      }
      window.cachedOrderItems = items;
      await fillPreviewBoxes(items);
    }

  </script>
</body>
</html>