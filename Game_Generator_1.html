<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game-Generator-1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
  
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; --accent: #2b6cff; --success: #7fdb96; --danger: #fca5a5; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 350px 1fr; gap:14px; max-width: 1600px; margin: 0 auto;}
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:16px; }
    h1{ font-size:18px; margin:0 0 14px 0; color: #fff;}
    h2{ font-size:14px; margin:0 0 10px 0; color: var(--muted);}
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    select, input, textarea { width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; outline: none; font-family: inherit; }
    textarea { line-height: 1.4; }
    .row{ display:flex; gap:8px; align-items: center; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); font-weight: 600; transition: all 0.2s;}
    .btn:hover{ background: #1a1e2b; }
    .btnPrimary { background: var(--accent); color: #fff; border-color: #1a4bbf; }
    .btnPrimary:hover { background: #1a4bbf; }
    .btnDanger { color: var(--danger); border-color: #7a3838; background: #3d1c1c; }
    .btnDanger:hover { background: #5c2424; }
    .btnSmall{ padding:6px 10px; border-radius:8px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    
    .drop-zone {
      border: 2px dashed #3a4262; border-radius: 14px; padding: 16px; background: #0e1220;
      transition: all 0.2s ease; display: flex; flex-direction: column; gap: 10px; margin-bottom: 14px;
    }
    .drop-zone.hover { border-color: var(--success); background: #13221c; }
    .drop-header { display: flex; justify-content: space-between; align-items: center; }
    .drop-header strong { font-size: 14px; color: #fff; }
    .drop-header span { font-size: 11px; color: var(--muted); background: #1a1e2b; padding: 3px 8px; border-radius: 999px; }
    
    .file-list { display: flex; flex-direction: column; gap: 6px; }
    .file-item { 
      display: flex; justify-content: space-between; align-items: center; 
      background: #0b0d12; border: 1px solid var(--line); padding: 8px 12px; border-radius: 8px; font-size: 12px;
    }
    .file-name { word-break: break-all; margin-right: 10px; }
    .file-actions { display: flex; gap: 6px; }

    /* Review Panel Styles */
    .review-panel { 
        margin-top: 20px; border: 1px dashed var(--accent); border-radius: 14px; 
        padding: 16px; background: rgba(43, 108, 255, 0.05); display: none; 
    }
    .review-panel.active { display: block; }
    .review-list { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 10px; }
    .review-item { 
        display: flex; justify-content: space-between; align-items: center; 
        background: var(--card); border: 1px solid var(--accent); padding: 8px 12px; border-radius: 8px; font-size: 12px;
    }

    /* Progress UI */
    .status-bar { margin-top: 10px; padding: 10px; border-radius: 10px; background: #0e1220; border: 1px solid var(--line); font-size: 12px; color: var(--success); display: none;}
    .status-bar.active { display: block; }

    /* Visual Feedback for AI Updates */
    @keyframes pulse-border {
      0% { border-color: var(--line); box-shadow: 0 0 0 rgba(127, 219, 150, 0); }
      50% { border-color: var(--success); box-shadow: 0 0 10px rgba(127, 219, 150, 0.4); }
      100% { border-color: var(--line); box-shadow: 0 0 0 rgba(127, 219, 150, 0); }
    }
    .pulse-update {
      animation: pulse-border 2s ease-out;
    }

    /* Game Asset Library Styles */
    .asset-library { margin-top: 20px; border: 1px dashed var(--success); border-radius: 14px; padding: 16px; background: rgba(127, 219, 150, 0.05); display: none; }
    .asset-library.active { display: block; }
    .asset-item { display: flex; align-items: center; justify-content: space-between; padding: 10px; border-bottom: 1px solid var(--line); font-size: 12px; transition: background 0.2s; }
    .asset-item:hover { background: var(--card); }
    .asset-item:last-child { border-bottom: none; }
    .asset-item label { display: flex; align-items: center; gap: 10px; cursor: pointer; margin: 0; color: var(--text); flex: 1; font-weight: 500;}
    .asset-date { color: var(--muted); font-size: 11px; }
    input[type="checkbox"].asset-checkbox { width: 16px; height: 16px; accent-color: var(--success); cursor: pointer; margin: 0; }
    
    /* CodeMirror Custom Overrides */
    .CodeMirror { height: auto; min-height: 300px; border-radius: 8px; font-family: monospace; font-size: 13px; margin-top: 10px; z-index: 0; }
    .CodeMirror-scroll { max-height: 600px; }
  </style>
</head>

<body>
  <div class="wrap">
    
    <div class="card">
      <h1>Game Generator Projects</h1>
      
      <label>Active Project</label>
      <select id="projectSelect">
        <option value="">Loading projects...</option>
      </select>

      <div style="margin-top: 20px; border-top: 1px solid var(--line); padding-top: 20px;">
        <label>Create New Project</label>
        <div class="row">
          <input type="text" id="newProjectName" placeholder="e.g. SpaceShooter_v1" />
          <button class="btn btnPrimary" id="createProjectBtn">Create</button>
        </div>
      </div>

      <div id="globalStatus" class="status-bar">System ready.</div>
      <div id="progressContainer" style="display: none; margin-top: 10px; background: var(--line); border-radius: 8px; height: 8px; overflow: hidden;">
        <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.2s ease;"></div>
      </div>
    </div>

    <div class="card" id="mainPanel" style="opacity: 0.5; pointer-events: none;">
      <div class="row" style="justify-content: space-between; margin-bottom: 20px;">
        <h1>Project Assets Manager</h1>
        <div class="row">
            <button class="btn btnPrimary" id="generateGameBtn" disabled>Generate Game Zip</button>
        </div>
      </div>

      <div id="dropZones">
      </div>

      <div id="reviewPanel" class="review-panel">
        <div class="row" style="justify-content: space-between;">
            <h2 style="color: var(--accent); margin:0;">AI Changes Review (Copies)</h2>
            <button class="btn btnSmall" id="clearReviewBtn">Dismiss All</button>
        </div>
        <div id="reviewFileList" class="review-list"></div>
      </div>

      <div id="assetLibrary" class="asset-library">
        <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
            <h2 style="color: var(--success); margin:0;">Game Assets Library</h2>
            <span style="font-size: 11px; color: var(--muted);">Select files to include in your next AI prompt</span>
        </div>
        <div id="assetList" style="display:flex; flex-direction:column; max-height: 250px; overflow-y:auto; border: 1px solid var(--line); border-radius: 8px; background: #0b0d12;">
            </div>
      </div>

      <div style="margin-top: 30px; border-top: 1px solid var(--line); padding-top: 20px;">
        <h2>AI Context Window</h2>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <div id="aiChatLog" style="height: 400px; overflow-y: auto; background: #0b0d12; border: 1px solid var(--line); border-radius: 10px; padding: 14px; font-size: 13px; font-family: monospace; display: flex; flex-direction: column; gap: 12px; white-space: pre-wrap; line-height: 1.5;">
            <div style="color: var(--muted);">AI Context ready. Enter instructions below to modify the active project.</div>
          </div>
          
          <textarea id="aiPromptInput" placeholder="e.g., 'Change the player movement speed in main.js to 500 and update the index.html title...'" style="min-height: 80px; resize: vertical;"></textarea>
          
          <div class="row" style="justify-content: flex-end;">
            <button class="btn btnPrimary" id="sendToAiBtn">Apply AI Update</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 30px; border-top: 1px solid var(--line); padding-top: 20px;">
        <h2>AI Context Code Review</h2>
        <div id="aiCodeReviewLog" style="height: 400px; overflow-y: auto; background: #0b0d12; border: 1px solid var(--line); border-radius: 10px; padding: 14px; font-size: 13px; font-family: monospace; display: flex; flex-direction: column; gap: 12px; white-space: pre-wrap; line-height: 1.5;">
          <div style="color: var(--muted);">Code diff updates will appear here after an AI run.</div>
        </div>
      </div>

    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getStorage, ref, uploadBytesResumable, uploadString, getDownloadURL, listAll, deleteObject, getMetadata } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const ROOT = "game-generator-1/projects";
    
    // Config matches your Listing Generator
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };

    const app = initializeApp(firebaseConfig);
    const storage = getStorage(app);
    const auth = getAuth(app);

    // AI INSTRUCTION CATEGORY UPDATED
    const FILE_CATEGORIES = [
      { id: "instructions", title: "AI System Instructions", accepts: "text/plain,.txt", folder: "ai_system_instructions" },
      { id: "assets", title: "Game Assets (Images/Audio)", accepts: "image/*,audio/*,.png,.jpg,.jpeg,.mp3,.wav", folder: "assets" },
      { id: "object_zip", title: "Animated/Textured Object ZIP Package", accepts: ".zip", folder: "object_zips" },
      { id: "models", title: "Models, Logic & HTML", accepts: ".obj,.glb,.fbx,.js,.mtl,.html", folder: "models" },
      { id: "json", title: "JSON Configs", accepts: ".json", folder: "json" },
      { id: "reference", title: "Reference Project ZIP", accepts: ".zip", folder: "reference_zip" }
    ];

    let currentProject = null;

    // --- UI Elements ---
    const projectSelect = document.getElementById('projectSelect');
    const newProjectName = document.getElementById('newProjectName');
    const createProjectBtn = document.getElementById('createProjectBtn');
    const mainPanel = document.getElementById('mainPanel');
    const dropZonesContainer = document.getElementById('dropZones');
    const globalStatus = document.getElementById('globalStatus');
    const generateGameBtn = document.getElementById('generateGameBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');

    // AI UI Elements
    const aiPromptInput = document.getElementById('aiPromptInput');
    const sendToAiBtn = document.getElementById('sendToAiBtn');
    const aiChatLog = document.getElementById('aiChatLog');
    const aiCodeReviewLog = document.getElementById('aiCodeReviewLog');

    // Review UI Elements
    const reviewPanel = document.getElementById('reviewPanel');
    const reviewFileList = document.getElementById('reviewFileList');
    const clearReviewBtn = document.getElementById('clearReviewBtn');

    function setStatus(msg) {
        globalStatus.textContent = msg;
        globalStatus.classList.add('active');
        setTimeout(() => globalStatus.classList.remove('active'), 4000);
    }

    // --- Auth Initialization ---
    async function ensureAuth() {
      if (auth.currentUser) return auth.currentUser;
      try { await signInAnonymously(auth); } catch(e) { console.error("Auth failed", e); }
      return new Promise(resolve => {
        const unsub = onAuthStateChanged(auth, u => {
          if (u) { unsub(); resolve(u); }
        });
      });
    }

    // --- Project Management ---
    async function loadProjects() {
      await ensureAuth();
      const listRef = ref(storage, ROOT);
      try {
        const res = await listAll(listRef);
        projectSelect.innerHTML = res.prefixes.length > 0 ? '' : '<option value="">No projects found</option>';
        
        res.prefixes.forEach(folderRef => {
          const opt = document.createElement('option');
          opt.value = folderRef.name;
          opt.textContent = folderRef.name;
          projectSelect.appendChild(opt);
        });

        if (res.prefixes.length > 0) {
          selectProject(projectSelect.value);
        }
      } catch (e) {
        console.error("Error loading projects", e);
        projectSelect.innerHTML = '<option value="">Error loading</option>';
      }
    }

    createProjectBtn.addEventListener('click', async () => {
      const name = newProjectName.value.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
      if (!name) return alert("Enter a valid project name.");
      
      setStatus(`Creating project: ${name}...`);
      await ensureAuth();
      
      const dummyRef = ref(storage, `${ROOT}/${name}/meta.json`);
      const blob = new Blob([JSON.stringify({ created: new Date() })], { type: 'application/json' });
      await uploadBytesResumable(dummyRef, blob);
      
      newProjectName.value = '';
      await loadProjects();
      projectSelect.value = name;
      selectProject(name);
    });

    projectSelect.addEventListener('change', (e) => selectProject(e.target.value));

    function selectProject(name) {
      if (!name) return;
      currentProject = name;
      mainPanel.style.opacity = '1';
      mainPanel.style.pointerEvents = 'all';
      
      generateGameBtn.disabled = false; 

      setStatus(`Switched to project: ${name}`);
      renderDropZones();
      refreshAllFiles();
      refreshReviewList();
      refreshAssetLibrary();
      aiChatLog.innerHTML = `<div style="color: var(--muted);">AI Context ready for project: ${name}. Enter instructions below.</div>`;
      aiCodeReviewLog.innerHTML = `<div style="color: var(--muted);">Code diff updates will appear here after an AI run.</div>`;
    }

    // --- Drag & Drop UI & Logic ---
    function renderDropZones() {
      dropZonesContainer.innerHTML = '';
      
      FILE_CATEGORIES.forEach(cat => {
        const zone = document.createElement('div');
        zone.className = 'drop-zone';
        zone.id = `zone_${cat.id}`;
        
        zone.innerHTML = `
          <div class="drop-header">
            <strong>${cat.title}</strong>
            <span>Accepts: ${cat.accepts}</span>
          </div>
          <div class="file-list" id="list_${cat.id}">
             <div style="font-size:11px; color:var(--muted);">Loading files...</div>
          </div>
          <input type="file" accept="${cat.accepts}" id="input_${cat.id}" style="display:none;" />
          <button class="btn btnSmall" onclick="document.getElementById('input_${cat.id}').click()" style="width: max-content;">+ Upload File</button>
        `;

        zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('hover'); });
        zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
        zone.addEventListener('drop', async (e) => {
          e.preventDefault();
          zone.classList.remove('hover');
          handleFiles(e.dataTransfer.files, cat);
        });

        const fileInput = zone.querySelector(`#input_${cat.id}`);
        fileInput.addEventListener('change', (e) => {
          handleFiles(e.target.files, cat);
          fileInput.value = ''; 
        });

        dropZonesContainer.appendChild(zone);
      });
    }

    async function handleFiles(files, categoryConfig, specificName = null) {
      if (!files || files.length === 0) return;
      await ensureAuth();

      const validExts = categoryConfig.accepts.split(',');
      const isWildcard = categoryConfig.accepts.includes('*');
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        const parts = file.name.split('.');
        const hasExtension = parts.length > 1;
        const fileExt = hasExtension ? '.' + parts.pop().toLowerCase() : '';
        
        if (hasExtension && !validExts.includes(fileExt) && !isWildcard) {
           alert(`Invalid file: ${file.name}. Expected ${categoryConfig.accepts}`);
           continue;
        }

        const fileName = specificName || file.name.replace(/[^a-zA-Z0-9_.-]/g, '_');
        const path = `${ROOT}/${currentProject}/${categoryConfig.folder}/${fileName}`;
        const targetRef = ref(storage, path);
        
        setStatus(`Uploading ${fileName}...`);
        
        try {
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(targetRef, file);
            task.on('state_changed', null, reject, resolve);
          });
        } catch(e) {
          console.error("Upload failed", e);
          alert(`Upload failed for ${fileName}`);
        }
      }
      
      setStatus(`Uploads complete.`);
      refreshFileList(categoryConfig);
    }

    // --- File Listing & Actions ---
    async function refreshAllFiles() {
      FILE_CATEGORIES.forEach(cat => refreshFileList(cat));
    }

    async function refreshFileList(categoryConfig) {
      if (!currentProject) return;
      const listContainer = document.getElementById(`list_${categoryConfig.id}`);
      if (!listContainer) return;
      
      const folderRef = ref(storage, `${ROOT}/${currentProject}/${categoryConfig.folder}`);
      
      try {
        const res = await listAll(folderRef);
        listContainer.innerHTML = '';
        
        if (res.items.length === 0) {
            listContainer.innerHTML = `<div style="font-size:11px; color:var(--muted);">No files uploaded. Drag & Drop here.</div>`;
            return;
        }

        res.items.forEach(itemRef => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'file-item';
          itemDiv.id = `item_${itemRef.name.replace(/[^a-zA-Z0-9]/g, '_')}`; // For animations
          
          itemDiv.innerHTML = `
            <div class="file-name">${itemRef.name}</div>
            <div class="file-actions">
               <input type="file" style="display:none;" id="replace_${itemRef.name.replace(/\./g,'_')}" accept="${categoryConfig.accepts}">
               <button class="btn btnSmall" onclick="document.getElementById('replace_${itemRef.name.replace(/\./g,'_')}').click()">Replace</button>
               <button class="btn btnSmall btnDanger" id="del_${itemRef.name.replace(/\./g,'_')}">Delete</button>
            </div>
          `;

          itemDiv.querySelector(`[id="del_${itemRef.name.replace(/\./g,'_')}"]`).addEventListener('click', async () => {
             if(confirm(`Delete ${itemRef.name}?`)) {
                 setStatus(`Deleting ${itemRef.name}...`);
                 await deleteObject(itemRef);
                 refreshFileList(categoryConfig);
                 setStatus(`Deleted.`);
             }
          });

          itemDiv.querySelector(`[id="replace_${itemRef.name.replace(/\./g,'_')}"]`).addEventListener('change', (e) => {
              handleFiles(e.target.files, categoryConfig, itemRef.name);
          });

          listContainer.appendChild(itemDiv);
        });

        if (categoryConfig.id === 'assets' || categoryConfig.id === 'models' || categoryConfig.id === 'object_zip') refreshAssetLibrary();

      } catch (e) {
        console.error(`Error loading files for ${categoryConfig.id}`, e);
        listContainer.innerHTML = `<div style="font-size:11px; color:var(--danger);">Error fetching files.</div>`;
      }
    }

// --- Game Assets Library Rendering ---
async function refreshAssetLibrary() {
        if (!currentProject) return;
        const libraryContainer = document.getElementById('assetLibrary');
        const listContainer = document.getElementById('assetList');
        
        const assetsRef = ref(storage, `${ROOT}/${currentProject}/assets`);
        const modelsRef = ref(storage, `${ROOT}/${currentProject}/models`);
        const objectZipsRef = ref(storage, `${ROOT}/${currentProject}/object_zips`);

        try {
            const [assetsRes, modelsRes, objectZipsRes] = await Promise.all([
                listAll(assetsRef).catch(() => ({items:[]})),
                listAll(modelsRef).catch(() => ({items:[]})),
                listAll(objectZipsRef).catch(() => ({items:[]}))
            ]);
            
            const allItems = [...assetsRes.items, ...modelsRes.items, ...objectZipsRes.items];

            if (allItems.length === 0) {
                libraryContainer.classList.remove('active');
                listContainer.innerHTML = '';
                return;
            }

            let htmlBuffer = '';

            for (const itemRef of allItems) {
                const meta = await getMetadata(itemRef);
                const url = await getDownloadURL(itemRef);
                const dateStr = new Date(meta.timeCreated).toLocaleString();
                const dataPath = `${itemRef.parent.name}/${itemRef.name}`;

                htmlBuffer += `
                    <div class="asset-item">
                        <label>
                            <input type="checkbox" class="asset-checkbox" 
                                data-path="${dataPath}" 
                                data-url="${url}" 
                                data-type="${meta.contentType || ''}" 
                                data-name="${itemRef.name}">
                            <span>✨ ${itemRef.name}</span>
                        </label>
                        <span class="asset-date">${itemRef.parent.name.toUpperCase()} • ${dateStr}</span>
                    </div>
                `;
            }
            
            listContainer.innerHTML = htmlBuffer;
            libraryContainer.classList.add('active');

        } catch (e) { 
            console.error("Asset library error", e); 
        }
    }

    // --- AI Review Persistence Logic ---
    async function refreshReviewList() {
        if (!currentProject) return;
        const reviewFolderRef = ref(storage, `${ROOT}/${currentProject}/review`);

        try {
            const res = await listAll(reviewFolderRef);
            if (res.items.length === 0) {
                reviewPanel.classList.remove('active');
                return;
            }

            reviewPanel.classList.add('active');
            reviewFileList.innerHTML = '';

            for (const itemRef of res.items) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'review-item';
                itemDiv.innerHTML = `
                    <div class="file-name">✨ ${itemRef.name}</div>
                    <div class="file-actions">
                        <button class="btn btnSmall" id="dl_rev_${itemRef.name.replace(/\./g,'_')}">Download</button>
                        <button class="btn btnSmall btnDanger" id="del_rev_${itemRef.name.replace(/\./g,'_')}">Delete Copy</button>
                    </div>
                `;

                itemDiv.querySelector(`#dl_rev_${itemRef.name.replace(/\./g,'_')}`).onclick = async () => {
                    const url = await getDownloadURL(itemRef);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `PREVIEW_${itemRef.name}`;
                    a.click();
                };

                itemDiv.querySelector(`#del_rev_${itemRef.name.replace(/\./g,'_')}`).onclick = async () => {
                    await deleteObject(itemRef);
                    refreshReviewList();
                };

                reviewFileList.appendChild(itemDiv);
            }
        } catch (e) { console.error("Review list error", e); }
    }

    clearReviewBtn.onclick = async () => {
        const reviewFolderRef = ref(storage, `${ROOT}/${currentProject}/review`);
        const res = await listAll(reviewFolderRef);
        await Promise.all(res.items.map(item => deleteObject(item)));
        refreshReviewList();
    };

    // --- AI Context Window Logic & Loop ---
    function appendToChatLog(sender, message, type = 'normal') {
      const msgDiv = document.createElement('div');
      const color = sender === 'AI' ? 'var(--success)' : (type === 'error' ? 'var(--danger)' : 'var(--text)');
      msgDiv.innerHTML = `<strong style="color: ${color}">${sender}:</strong> ${message}`;
      aiChatLog.appendChild(msgDiv);
      aiChatLog.scrollTop = aiChatLog.scrollHeight;
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

sendToAiBtn.addEventListener('click', async () => {
      const prompt = aiPromptInput.value.trim();
      if (!prompt || !currentProject) return;

      aiPromptInput.value = '';
      sendToAiBtn.disabled = true;
      appendToChatLog('You', prompt);
      
      try {
        // 1. Read Reference ZIP and Map Structure
        appendToChatLog('System', 'Mapping project structure from Reference ZIP...', 'muted');
        let projectStructure = "Project Directory Map:\n";
        const refFolder = ref(storage, `${ROOT}/${currentProject}/reference_zip`);
        let zipFound = false;
        
        try {
          const refList = await listAll(refFolder);
          if (refList.items.length > 0) {
            const refUrl = await getDownloadURL(refList.items[0]);
            const refRes = await fetch(refUrl);
            const refBlob = await refRes.blob();
            
            const zip = new JSZip();
            await zip.loadAsync(refBlob);
            projectStructure += Object.keys(zip.files).join('\n');
            zipFound = true;
          }
        } catch (e) {
          console.warn("Could not read Reference ZIP for structure.", e);
        }

        if (!zipFound) {
            projectStructure += "(No Reference ZIP uploaded yet)";
        }

        // 2. Gather explicitly targeted files
        appendToChatLog('System', 'Gathering logic file "2", HTML file "23", and config "assets.json"...', 'muted');
        const projectFiles = {};
        const targetFiles = [
          { folder: 'models', name: '2' },
          { folder: 'models', name: '23' },
          { folder: 'json', name: 'assets.json' }
        ];

        for (const target of targetFiles) {
          const fileRef = ref(storage, `${ROOT}/${currentProject}/${target.folder}/${target.name}`);
          try { 
            const url = await getDownloadURL(fileRef);
            const fetched = await fetch(url + '&v=' + Date.now(), { cache: 'no-store' });
            if (fetched.ok) {
                projectFiles[`${target.folder}/${target.name}`] = await fetched.text(); 
            }
          } catch (e) { 
             console.warn(`Skipped ${target.name} - not found in Firebase storage.`); 
          } 
        }

        if (Object.keys(projectFiles).length === 0) {
          throw new Error("Could not find '2', '23', or 'assets.json'. Please upload them first.");
        }

        // Gather Selected Assets & Extract Custom Object Zips on the fly
        const selectedAssetNodes = document.querySelectorAll('.asset-checkbox:checked');
        const selectedAssets = Array.from(selectedAssetNodes).map(cb => ({
            name: cb.dataset.name,
            path: cb.dataset.path,
            url: cb.dataset.url,
            type: cb.dataset.type
        }));

        let assetString = "";
        let zipContextString = "";

        if (selectedAssets.length > 0) {
            assetString = "\n\nCRITICAL: The user has explicitly selected the following files. You MUST use these exact file paths/keys in your code when referencing them:\n";
            for (const a of selectedAssets) {
                assetString += `- ${a.path}\n`;
                
                // UNZIP LOGIC FOR OBJECT ZIPS IN SELECTED ASSETS
                if (a.path.includes('object_zips') && a.name.toLowerCase().endsWith('.zip')) {
                    appendToChatLog('System', `Extracting contents of Object Package ${a.name}...`, 'muted');
                    try {
                        const zipUrl = await getDownloadURL(ref(storage, `${ROOT}/${currentProject}/${a.path}`));
                        const zipRes = await fetch(zipUrl);
                        const zipBlob = await zipRes.blob();
                        const zipObj = new JSZip();
                        await zipObj.loadAsync(zipBlob);
                        
                        let parsedModels = [];
                        let parsedTextures = [];
                        let parsedAnimInfo = "";
                        
                        for (const relativePath of Object.keys(zipObj.files)) {
                            const file = zipObj.files[relativePath];
                            if (file.dir || relativePath.includes('__MACOSX')) continue;
                            
                            const lowerPath = relativePath.toLowerCase();
                            if (lowerPath.endsWith('.obj') || lowerPath.endsWith('.glb') || lowerPath.endsWith('.fbx')) {
                                parsedModels.push(relativePath);
                            } else if (lowerPath.endsWith('.jpg') || lowerPath.endsWith('.png') || lowerPath.endsWith('.jpeg')) {
                                parsedTextures.push(relativePath);
                            } else if (lowerPath.endsWith('.txt')) {
                                parsedAnimInfo += `\n--- Content of ${relativePath} ---\n`;
                                parsedAnimInfo += await file.async('string');
                            }
                        }
                        
                        zipContextString += `\n\n=== PARSED ZIP PACKAGE CONTENTS: ${a.name} ===\n`;
                        zipContextString += `3D Models Included: ${parsedModels.join(', ')}\n`;
                        zipContextString += `Textures Included: ${parsedTextures.join(', ')}\n`;
                        zipContextString += `Animation ID Reference File: ${parsedAnimInfo}\n`;
                        zipContextString += `AI INSTRUCTION: Automatically infer the PBR texture maps (Albedo, Normal, etc.) based on the texture file suffixes and apply them to the material using createMaterial(). Use the Animation ID Reference to trigger the correct animations via gameState.playAnimation().\n`;
                        
                    } catch (e) {
                        console.warn(`Failed to parse object zip ${a.name}`, e);
                        appendToChatLog('System', `Warning: Could not parse ${a.name}`, 'error');
                    }
                }
            }
        }

        // 2.5 Gather AI System Instructions
        appendToChatLog('System', 'Fetching AI System Instructions...', 'muted');
        let aiInstructionsText = "No AI System Instructions provided.";
        const instructionsFolderRef = ref(storage, `${ROOT}/${currentProject}/ai_system_instructions`);
        try {
            const instList = await listAll(instructionsFolderRef);
            if (instList.items.length > 0) {
                const instUrl = await getDownloadURL(instList.items[0]);
                const instRes = await fetch(instUrl + '&v=' + Date.now(), { cache: 'no-store' });
                if (instRes.ok) {
                    aiInstructionsText = await instRes.text();
                }
            }
        } catch (e) {
            console.warn("Could not fetch AI System Instructions.", e);
        }

        // 3. Combine Structure Map, Instructions & Selected Assets with the User Prompt
        const enhancedPrompt = `Here is the full project structure for reference:\n${projectStructure}${assetString}${zipContextString}

        === AI SYSTEM INSTRUCTIONS ===
        ${aiInstructionsText}
        ==============================

        CRITICAL PROCESSING STEPS:
        1. Before starting analysis, you must first strictly read and interpret the "AI SYSTEM INSTRUCTIONS" provided above.
        2. Next, read, interpret, and understand the purpose and context of the explicitly targeted files ("2", "23", and "assets.json"), their relationship to the other files in the project map, and their function specifically in the context of the "AI SYSTEM INSTRUCTIONS".

        CRITICAL SYSTEM RULE: The main logic file is named "2" and the main HTML file is named "23", both located in the "models" folder. You MUST use the exact name "2" instead of "WorldController.js" and "23" instead of "document.html" in all your code, updates, references, and output paths. Never save or output a file named "WorldController.js" or "document.html".

        ASSET CONFIGURATION RULE: You must ensure "assets.json" (in the "json" folder) is updated to include any new assets requested by the user. If an asset the user mentions is not yet mapped in "assets.json", you MUST map it and return the updated "assets.json" file in your payload. When updating "assets.json", assign sequential numbers for the "key" property. CRITICAL: The "title" property for each mapped asset MUST be transposed exactly as its original file name, with no changes (e.g., {"key":"34","type":"object","title":"plane.obj"}). If you add or update an asset in "assets.json", you MUST also update file "2" to properly reference, load, or instantiate that new asset key so it is recognized and works within the system.

        RESPONSE RULE - CRITICAL OPTIMIZATION:
        To save time and tokens, YOU MUST NEVER OUTPUT THE FULL CONTENT OF A FILE. You must ONLY output the specific lines being changed using a SEARCH/REPLACE block format inside the "content" field of your JSON response. 
        Format your "content" string EXACTLY like this for every change:

        <<<<<<< SEARCH
        [exact code from the original file to be replaced, including a few lines of context before and after]
        =======
        [the new code to replace it with]
        >>>>>>> REPLACE

        Rules for SEARCH/REPLACE blocks:
        1. The SEARCH section MUST match the existing code in the file exactly, line for line, preserving whitespace and indentation. 
        2. Include enough context lines to ensure a unique match.
        3. You can include multiple SEARCH/REPLACE blocks for a single file.
        4. If adding a completely new file (not editing an existing one), output the full code without SEARCH/REPLACE tags.

        In your 'message' response, provide a highly detailed changelog breaking down exactly which files you modified and summarize the logic shifts.

        User Request: ${prompt}`;

        // 4. Prepare Storage references and clean up old runs
        const projectPath = `${ROOT}/${currentProject}`;
        const responseFileRef = ref(storage, `${projectPath}/ai_response.json`);
        const errorFileRef = ref(storage, `${projectPath}/ai_error.json`);
        
        try { await deleteObject(responseFileRef); } catch(e) {}
        try { await deleteObject(errorFileRef); } catch(e) {}

        // 5. Trigger Gemini Background Proxy
        appendToChatLog('System', 'Sending targeted files and map to AI...', 'muted');
        setStatus('AI is processing files (This may take a minute)...');
        
        await fetch('/.netlify/functions/geminiCodeProxy-background', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: enhancedPrompt, files: projectFiles, projectPath, selectedAssets })
        });

        // 6. Poll Firebase Storage for the result file
        let result = null;
        let attempts = 0;
        
        while (!result && attempts < 60) {
          await sleep(30000); 
          attempts++;

          let hasErrorFile = false;
          let errorMessage = "AI Generation Failed";
          try {
            const errUrl = await getDownloadURL(errorFileRef);
            const errRes = await fetch(errUrl);
            const errData = await errRes.json();
            errorMessage = errData.error || errorMessage;
            hasErrorFile = true;
          } catch(e) {}

          if (hasErrorFile) throw new Error(errorMessage);

          try {
            const url = await getDownloadURL(responseFileRef);
            const res = await fetch(url + `&v=${Date.now()}`);
            result = await res.json();
          } catch(e) {}
        }

        if (!result) throw new Error("AI request timed out waiting for background completion.");

        // Helper to safely escape HTML for the UI code review
        const escapeHTML = (str) => str.replace(/[&<>'"]/g, tag => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'
        }[tag]));

        // 7. Write updated files back to Firebase (WITH PATCHING LOGIC)
        appendToChatLog('System', `Writing ${result.updatedFiles.length} updated files to Firebase...`, 'muted');
        
        for (const file of result.updatedFiles) {
          let aiOutputContent = file.content.trim();
          if (aiOutputContent.startsWith('```')) {
              const lines = aiOutputContent.split('\n');
              if (lines[0].startsWith('```')) lines.shift();
              if (lines[lines.length - 1].trim().startsWith('```')) lines.pop();
              aiOutputContent = lines.join('\n').trim();
          }

          let fileName = file.path.split('/').pop(); 
          let safePath = file.path;

          if (fileName.toLowerCase() === 'worldcontroller.js' || fileName === '2.js') {
              fileName = '2';
              safePath = 'models/2';
          } else if (fileName.toLowerCase() === 'document.html' || fileName === '23.html') {
              fileName = '23';
              safePath = 'models/23';
          } else if (fileName.toLowerCase() === 'assets.json') {
              fileName = 'assets.json';
              safePath = 'json/assets.json';
          }

          const originalFileKey = Object.keys(projectFiles).find(k => k.toLowerCase().endsWith('/' + fileName.toLowerCase()));
          
          let finalContentToSave = aiOutputContent;
          let uiDisplayContent = escapeHTML(aiOutputContent); // Default if no patch tags

          // --- NEW PATCHING & UI INJECTION LOGIC ---
          if (aiOutputContent.includes('<<<<<<< SEARCH')) {
             let originalContent = originalFileKey ? projectFiles[originalFileKey] : "";
             
             if (!originalContent) {
                 appendToChatLog('System', `Warning: Could not find original content for ${fileName} to apply patch. Skipping file.`, 'error');
                 continue; 
             }

             const blockRegex = /<<<<<<< SEARCH[\r\n]+([\s\S]*?)[\r\n]+=======[\r\n]+([\s\S]*?)[\r\n]+>>>>>>> REPLACE/g;
             let normalizedResult = originalContent.replace(/\r\n/g, '\n');
             let uiResult = escapeHTML(normalizedResult); // Start with the full original escaped code
             let match;
             let changesMade = 0;

             while ((match = blockRegex.exec(aiOutputContent)) !== null) {
                 const searchTarget = match[1].replace(/\r\n/g, '\n');
                 const replacement = match[2];

                 if (normalizedResult.includes(searchTarget)) {
                     // 1. Execute standard patch for the file to be saved to Firebase
                     normalizedResult = normalizedResult.split(searchTarget).join(replacement);
                     
                     // 2. Execute UI string replacement with colors
                     const escapedSearch = escapeHTML(searchTarget);
                     const escapedReplace = escapeHTML(replacement);
                     const uiPatch = `<span style="color: var(--success); font-weight: bold;">${escapedSearch}</span>\n<span style="color: var(--danger); font-weight: bold;">${escapedReplace}</span>`;
                     
                     uiResult = uiResult.split(escapedSearch).join(uiPatch);
                     changesMade++;
                 } else {
                     console.warn(`Patch failed for ${fileName}. Code not found:\n`, searchTarget);
                     appendToChatLog('System', `Warning: A patch block for ${fileName} failed to match the existing code.`, 'error');
                 }
             }

             if (changesMade > 0) {
                 finalContentToSave = normalizedResult;
                 uiDisplayContent = uiResult; // Store the HTML-injected full file for UI rendering
             } else {
                 appendToChatLog('System', `Failed to apply any patches to ${fileName}. Ensure AI provides exact matching code.`, 'error');
                 continue; 
             }
          }
          
      file.uiContent = uiDisplayContent; // Attach the formatted HTML context for step 8
          file.rawContent = finalContentToSave; // Store the raw unescaped code for the clipboard
          // --------------------------

          const targetRef = ref(storage, `${ROOT}/${currentProject}/${safePath}`);
          await uploadString(targetRef, finalContentToSave);
          
          const catFolder = safePath.split('/')[0];
          const catConfig = FILE_CATEGORIES.find(c => c.folder === catFolder);
          if (catConfig) {
            const zone = document.getElementById(`zone_${catConfig.id}`);
            if (zone) {
              zone.classList.remove('pulse-update');
              void zone.offsetWidth; 
              zone.classList.add('pulse-update');
            }
          }
        }

        // 8. Update UI Code Review
        appendToChatLog('AI', result.message || "Files have been updated successfully.");
        setStatus('AI update complete.');

        aiCodeReviewLog.innerHTML = ''; 
        
        if (result.updatedFiles && result.updatedFiles.length > 0) {
            result.updatedFiles.forEach(file => {
                const fileContainer = document.createElement('div');
                // Creating a much larger and more visible separation block
                fileContainer.style.border = '2px solid var(--accent)';
                fileContainer.style.borderRadius = '12px';
                fileContainer.style.background = '#151a2a'; // Slightly offset from standard background
                fileContainer.style.padding = '24px';
                fileContainer.style.marginBottom = '50px'; 
                fileContainer.style.boxShadow = '0 6px 20px rgba(0,0,0,0.4)';

                const fileHeader = document.createElement('div');
                fileHeader.style.display = 'flex';
                fileHeader.style.justifyContent = 'space-between';
                fileHeader.style.alignItems = 'center';
                fileHeader.style.borderBottom = '2px solid var(--line)';
                fileHeader.style.paddingBottom = '12px';
                fileHeader.style.marginBottom = '16px';

                const titleSpan = document.createElement('span');
                titleSpan.style.color = 'var(--accent)';
                titleSpan.style.fontSize = '16px';
                titleSpan.style.fontWeight = 'bold';
                titleSpan.textContent = `File Updated: ${file.path} (Full Context View)`;

                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn btnSmall';
                copyBtn.textContent = 'Copy Code';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(file.rawContent || '').then(() => {
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.backgroundColor = 'var(--success)';
                        copyBtn.style.borderColor = 'var(--success)';
                        copyBtn.style.color = '#000';
                        setTimeout(() => {
                            copyBtn.textContent = 'Copy Code';
                            copyBtn.style.backgroundColor = '';
                            copyBtn.style.borderColor = '';
                            copyBtn.style.color = '';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy code: ', err);
                        copyBtn.textContent = 'Failed';
                    });
                };

                fileHeader.appendChild(titleSpan);
                fileHeader.appendChild(copyBtn);

                const editorContainer = document.createElement('div');
                editorContainer.style.width = '100%';
                
                fileContainer.appendChild(fileHeader);
                fileContainer.appendChild(editorContainer);
                aiCodeReviewLog.appendChild(fileContainer);

                // Determine language syntax based on file extension
                let editorMode = "javascript";
                if (file.path.endsWith('.html')) editorMode = "htmlmixed";
                else if (file.path.endsWith('.json')) editorMode = "application/json";

                // Initialize fully-fledged CodeMirror editor
                const editor = CodeMirror(editorContainer, {
                    value: file.rawContent || '',
                    mode: editorMode,
                    theme: "monokai",
                    lineNumbers: true,
                    lineWrapping: true, // Forces text to wrap correctly
                    readOnly: false     // Makes it fully editable
                });

                // Small timeout to force layout refresh after injection
                setTimeout(() => editor.refresh(), 100);
            });
        } else {
            aiCodeReviewLog.innerHTML = '<div style="color: var(--muted);">No code changes detected in this run.</div>';
        }

        refreshAllFiles();
        refreshReviewList(); 
        document.querySelectorAll('.asset-checkbox').forEach(cb => cb.checked = false);

      } catch (error) {
        console.error("AI Update Error:", error);
        appendToChatLog('System', `Error: ${error.message}`, 'error');
        setStatus('AI update failed.');
      } finally {
        sendToAiBtn.disabled = false;
      }
    });

// --- Zip Generation Logic (Template Matcher) ---
    generateGameBtn.addEventListener('click', async () => {
      if (!currentProject) return;
      
      try {
        generateGameBtn.disabled = true;
        progressContainer.style.display = 'block';
        progressBar.style.width = '5%';
        setStatus(`Fetching Reference ZIP for ${currentProject}...`);
        
        const refFolder = ref(storage, `${ROOT}/${currentProject}/reference_zip`);
        const refList = await listAll(refFolder);
        
        if (refList.items.length === 0) {
           alert("No Reference ZIP found! Please upload one to the Reference Project ZIP drop zone first.");
           throw new Error("Missing reference zip");
        }
        
        const referenceZipRef = refList.items[0]; 
        const refUrl = await getDownloadURL(referenceZipRef);
        const refCacheBust = refUrl.includes('?') ? `${refUrl}&_ts=${new Date().getTime()}` : `${refUrl}?_ts=${new Date().getTime()}`;

        const refRes = await fetch(refCacheBust, { cache: 'no-store' });
        const refBlob = await refRes.blob();
        
        progressBar.style.width = '15%';
        setStatus(`Loading template ZIP into memory...`);
        const zip = new JSZip();
        await zip.loadAsync(refBlob);
        const zipPaths = Object.keys(zip.files);
        
        setStatus(`Parsing assets.json for file mappings...`);
        const normalizeStr = (str) => String(str).toLowerCase().replace(/[^a-z0-9]/g, '');
        let assetMap = {};
        try {
            const assetsJsonRef = ref(storage, `${ROOT}/${currentProject}/json/assets.json`);
            const assetsJsonUrl = await getDownloadURL(assetsJsonRef);
            
            const safeAssetsUrl = assetsJsonUrl.includes('?') 
                ? `${assetsJsonUrl}&_ts=${new Date().getTime()}` 
                : `${assetsJsonUrl}?_ts=${new Date().getTime()}`;
                
            const assetsJsonRes = await fetch(safeAssetsUrl, {cache: 'no-store'});
            
            if (!assetsJsonRes.ok) throw new Error(`Failed to fetch assets.json: ${assetsJsonRes.statusText}`);
            const assetsData = await assetsJsonRes.json();
            
            function extractMappings(obj) {
                if (!obj) return;
                if (typeof obj === 'object') {
                    if (obj.key !== undefined && obj.title !== undefined) {
                        // Store the exact title for exact matching
                        assetMap[String(obj.title)] = String(obj.key);
                        
                        const titleStr = String(obj.title).toLowerCase();
                        assetMap[titleStr] = String(obj.key);
                        assetMap[normalizeStr(obj.title)] = String(obj.key);
                        
                        if (titleStr.includes('.')) {
                            const nameOnly = titleStr.substring(0, titleStr.lastIndexOf('.'));
                            assetMap[nameOnly] = String(obj.key);
                            assetMap[normalizeStr(nameOnly)] = String(obj.key);
                        } else {
                            assetMap[normalizeStr(obj.title)] = String(obj.key);
                        }
                    }
                    for (let k in obj) {
                        if (typeof obj[k] === 'object') extractMappings(obj[k]);
                    }
                }
            }
            extractMappings(assetsData);
        } catch (e) {
            console.warn("Could not pre-fetch/parse assets.json for mapping. Keys may not be renamed.", e);
        }

        progressBar.style.width = '20%';
        setStatus(`Indexing project files...`);
        let totalFiles = 0;
        let processedFiles = 0;
        const cachedCategories = {};

        for (const cat of FILE_CATEGORIES) {
          if (cat.id === 'reference' || cat.id === 'instructions') continue;
          const folderRef = ref(storage, `${ROOT}/${currentProject}/${cat.folder}`);
          try { 
             const res = await listAll(folderRef); 
             cachedCategories[cat.id] = res.items;
             totalFiles += res.items.length;
          } catch(e) { 
             cachedCategories[cat.id] = []; 
          }
        }

        for (const cat of FILE_CATEGORIES) {
          if (cat.id === 'reference' || cat.id === 'instructions') continue;
          
          const items = cachedCategories[cat.id];
          
          for (const itemRef of items) {
            setStatus(`Processing ${itemRef.name}...`);
            const url = await getDownloadURL(itemRef);
            const cacheBustUrl = url.includes('?') ? `${url}&_ts=${new Date().getTime()}` : `${url}?_ts=${new Date().getTime()}`;

            const response = await fetch(cacheBustUrl, { cache: 'no-store' });
            const blob = await response.blob();
            
            if (cat.id === 'object_zip') {
                const tempZip = new JSZip();
                await tempZip.loadAsync(blob);
                
                for (const relativePath in tempZip.files) {
                    const zipEntry = tempZip.files[relativePath];
                    if (zipEntry.dir || relativePath.includes('__MACOSX')) continue;
                    
                    const entryName = relativePath.split('/').pop();
                    let exactName = entryName;
                    const lowerName = entryName.toLowerCase();
                    const nameNoExt = lowerName.includes('.') ? lowerName.substring(0, lowerName.lastIndexOf('.')) : lowerName;
                    const normName = normalizeStr(entryName);
                    const normNoExt = normalizeStr(nameNoExt);
                    
                    let mappedKey = null;
                    if (assetMap[exactName]) {
                        mappedKey = assetMap[exactName];
                    } else if (assetMap[lowerName]) {
                        mappedKey = assetMap[lowerName];
                    } else if (assetMap[nameNoExt]) {
                        mappedKey = assetMap[nameNoExt];
                    } else if (assetMap[normName]) {
                        mappedKey = assetMap[normName];
                    } else if (assetMap[normNoExt]) {
                        mappedKey = assetMap[normNoExt];
                    }
                    
                    if (mappedKey) {
                        const entryBlob = await zipEntry.async('blob');
                        zip.file(`files/${mappedKey}`, entryBlob);
                    }
                }
                
                processedFiles++;
                if (totalFiles > 0) {
                   const percentComplete = 20 + ((processedFiles / totalFiles) * 65);
                   progressBar.style.width = `${percentComplete}%`;
                }
                continue; 
            }

            let searchName = itemRef.name;
            if (cat.folder === 'models' && itemRef.name === '2') {
                searchName = 'WorldController.js';
            } else if (cat.folder === 'models' && itemRef.name === '23') {
                searchName = 'document.html';
            }

            let possibleMatches = zipPaths.filter(p => 
                !p.includes('__MACOSX') && 
                !p.split('/').some(part => part.startsWith('.')) && 
                (p.toLowerCase() === searchName.toLowerCase() || p.toLowerCase().endsWith('/' + searchName.toLowerCase()))
            );
            
            possibleMatches.sort((a,b) => a.length - b.length);
            const match = possibleMatches.length > 0 ? possibleMatches[0] : null;

            if (match) {
               zip.remove(match);
            }
            
            if (cat.id === 'json' || itemRef.name.toLowerCase().endsWith('.json')) {
               const jsonPath = match ? match : `json/${itemRef.name}`;
               zip.file(jsonPath, blob);

                } else {
               let finalFileName = itemRef.name;
               let exactName = finalFileName;
               let lowerName = finalFileName.toLowerCase();
               
                if (finalFileName !== '2' && finalFileName !== '23') {
                   const nameNoExt = lowerName.includes('.') ? lowerName.substring(0, lowerName.lastIndexOf('.')) : lowerName;
                   const normName = normalizeStr(finalFileName);
                   const normNoExt = normalizeStr(nameNoExt);

                   if (assetMap[exactName]) {
                       finalFileName = assetMap[exactName];
                   } else if (assetMap[lowerName]) {
                       finalFileName = assetMap[lowerName];
                   } else if (assetMap[nameNoExt]) {
                       finalFileName = assetMap[nameNoExt];
                   } else if (assetMap[normName]) {
                       finalFileName = assetMap[normName];
                   } else if (assetMap[normNoExt]) {
                       finalFileName = assetMap[normNoExt];
                   }
               }
               
               zip.file(`files/${finalFileName}`, blob);
            }

            processedFiles++;
            if (totalFiles > 0) {
               const percentComplete = 20 + ((processedFiles / totalFiles) * 65);
               progressBar.style.width = `${percentComplete}%`;
            }
          }
        }
        
        progressBar.style.width = '90%';
        setStatus(`Compiling final Game ZIP...`);
        
        const finalZipBlob = await zip.generateAsync({ type: "blob", compression: "STORE" });
        
        progressBar.style.width = '100%';
        setStatus(`Game Zip Generated Successfully! Downloading...`);

        const downloadUrl = URL.createObjectURL(finalZipBlob);
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = `${currentProject}_Custom_Build.zip`;
        document.body.appendChild(a);
        a.click();
        
        document.body.removeChild(a);
        URL.revokeObjectURL(downloadUrl);

      } catch (error) {
        console.error("Zip generation error:", error);
        setStatus(`Error generating zip. Check console.`);
        progressBar.style.backgroundColor = 'var(--danger)';
      } finally {
        generateGameBtn.disabled = false;
        generateGameBtn.textContent = "Generate Game Zip"; 
        
        setTimeout(() => {
           progressContainer.style.display = 'none';
           progressBar.style.width = '0%';
           progressBar.style.backgroundColor = 'var(--accent)';
        }, 3000);
      }
    });

    window.addEventListener('DOMContentLoaded', () => {
      loadProjects();
    });
  </script>
</body>
</html>