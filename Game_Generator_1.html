<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Game-Generator-1</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/xml/xml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/htmlmixed/htmlmixed.min.js"></script>
  
  <style>
    :root { --bg:#0b0d12; --card:#121624; --muted:#8b93a7; --text:#e9ecf5; --line:#242a3d; --accent: #2b6cff; --success: #7fdb96; --danger: #fca5a5; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    .wrap{ padding:14px; display:grid; grid-template-columns: 350px 1fr; gap:14px; max-width: 1600px; margin: 0 auto;}
    .card{ background:var(--card); border:1px solid var(--line); border-radius:14px; padding:16px; }
    h1{ font-size:18px; margin:0 0 14px 0; color: #fff;}
    h2{ font-size:14px; margin:0 0 10px 0; color: var(--muted);}
    label{ display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    select, input, textarea { width:100%; border-radius:10px; border:1px solid var(--line); background:#0e1220; color:var(--text); padding:10px; box-sizing:border-box; outline: none; font-family: inherit; }
    textarea { line-height: 1.4; }
    .row{ display:flex; gap:8px; align-items: center; }
    .btn{ cursor:pointer; border-radius:12px; border:1px solid var(--line); padding:10px 12px; background:#0e1220; color:var(--text); font-weight: 600; transition: all 0.2s;}
    .btn:hover{ background: #1a1e2b; }
    .btnPrimary { background: var(--accent); color: #fff; border-color: #1a4bbf; }
    .btnPrimary:hover { background: #1a4bbf; }
    .btnDanger { color: var(--danger); border-color: #7a3838; background: #3d1c1c; }
    .btnDanger:hover { background: #5c2424; }
    .btnSmall{ padding:6px 10px; border-radius:8px; font-size:11px; line-height:1; }
    .btn:disabled{ opacity:0.5; cursor:not-allowed; }
    
    .drop-zone {
      border: 2px dashed #3a4262; border-radius: 14px; padding: 16px; background: #0e1220;
      transition: all 0.2s ease; display: flex; flex-direction: column; gap: 10px; margin-bottom: 14px;
    }
    .drop-zone.hover { border-color: var(--success); background: #13221c; }
    .drop-header { display: flex; justify-content: space-between; align-items: center; }
    .drop-header strong { font-size: 14px; color: #fff; }
    .drop-header span { font-size: 11px; color: var(--muted); background: #1a1e2b; padding: 3px 8px; border-radius: 999px; }
    
    .file-list { display: flex; flex-direction: column; gap: 6px; }
    .file-item { 
      display: flex; justify-content: space-between; align-items: center; 
      background: #0b0d12; border: 1px solid var(--line); padding: 8px 12px; border-radius: 8px; font-size: 12px;
    }
    .file-name { word-break: break-all; margin-right: 10px; }
    .file-actions { display: flex; gap: 6px; }

    /* Review Panel Styles */
    .review-panel { 
        margin-top: 20px; border: 1px dashed var(--accent); border-radius: 14px; 
        padding: 16px; background: rgba(43, 108, 255, 0.05); display: none; 
    }
    .review-panel.active { display: block; }
    .review-list { display: grid; grid-template-columns: 1fr; gap: 8px; margin-top: 10px; }
    .review-item { 
        display: flex; justify-content: space-between; align-items: center; 
        background: var(--card); border: 1px solid var(--accent); padding: 8px 12px; border-radius: 8px; font-size: 12px;
    }

    /* Progress UI */
    .status-bar { margin-top: 10px; padding: 10px; border-radius: 10px; background: #0e1220; border: 1px solid var(--line); font-size: 12px; color: var(--success); display: none;}
    .status-bar.active { display: block; }

    /* Visual Feedback for AI Updates */
    @keyframes pulse-border {
      0% { border-color: var(--line); box-shadow: 0 0 0 rgba(127, 219, 150, 0); }
      50% { border-color: var(--success); box-shadow: 0 0 10px rgba(127, 219, 150, 0.4); }
      100% { border-color: var(--line); box-shadow: 0 0 0 rgba(127, 219, 150, 0); }
    }
    .pulse-update {
      animation: pulse-border 2s ease-out;
    }

    /* AI Prompt Image Tag Styles */
    .img-ref-tag {
      background: #e9ecf5;
      color: #0b0d12;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      pointer-events: auto;
    }
    .img-ref-tag .remove-img {
      cursor: pointer;
      color: #555;
      font-weight: bold;
      transition: color 0.2s;
    }
    .img-ref-tag .remove-img:hover {
      color: var(--danger);
    }
    .ai-prompt-drag-hover {
      border-color: var(--accent) !important;
      background-color: rgba(43, 108, 255, 0.05) !important;
    }

    /* Image Preview Modal */
    .image-preview-modal {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.8); z-index: 9999; justify-content: center; align-items: center;
        backdrop-filter: blur(3px);
    }
    .image-preview-modal.active { display: flex; }
    .image-preview-content {
        position: relative; max-width: 90%; max-height: 90%; background: var(--card);
        padding: 8px; border-radius: 12px; border: 1px solid var(--line);
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    .image-preview-content img { 
        max-width: 100%; max-height: 85vh; border-radius: 6px; display: block; object-fit: contain;
    }
    .close-preview {
        position: absolute; top: -12px; right: -12px; background: var(--danger); color: #000;
        border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer;
        font-weight: bold; display: flex; justify-content: center; align-items: center; 
        box-shadow: 0 2px 8px rgba(0,0,0,0.4); transition: transform 0.2s;
    }
    .close-preview:hover { transform: scale(1.1); }

    /* Game Asset Library Styles */
    .asset-library { margin-top: 20px; border: 1px dashed var(--success); border-radius: 14px; padding: 16px; background: rgba(127, 219, 150, 0.05); display: none; }
    .asset-library.active { display: block; }
    .asset-item { display: flex; align-items: center; justify-content: space-between; padding: 10px; border-bottom: 1px solid var(--line); font-size: 12px; transition: background 0.2s; }
    .asset-item:hover { background: var(--card); }
    .asset-item:last-child { border-bottom: none; }
    .asset-item label { display: flex; align-items: center; gap: 10px; cursor: pointer; margin: 0; color: var(--text); flex: 1; font-weight: 500;}
    .asset-date { color: var(--muted); font-size: 11px; }
    input[type="checkbox"].asset-checkbox { width: 16px; height: 16px; accent-color: var(--success); cursor: pointer; margin: 0; }
    
    /* CodeMirror Custom Overrides */
    .CodeMirror { height: auto; min-height: 300px; border-radius: 8px; font-family: monospace; font-size: 13px; margin-top: 10px; z-index: 0; }
    .CodeMirror-scroll { max-height: 600px; }

    /* 3D Processing Modal Styles */
    .processing-modal {
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0.85); z-index: 10000; justify-content: center; align-items: center;
        backdrop-filter: blur(5px);
    }
    .processing-modal.active { display: flex; }
    .processing-content {
        background: var(--card); border: 1px solid var(--accent); border-radius: 14px;
        padding: 24px; width: 450px; max-width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        display: flex; flex-direction: column; gap: 16px;
    }
    .model-list-container {
        max-height: 200px; overflow-y: auto; border: 1px solid var(--line); border-radius: 8px; background: #0b0d12;
    }
    .model-item {
        display: flex; align-items: center; padding: 10px; border-bottom: 1px solid var(--line); font-size: 13px;
    }
    .model-item:last-child { border-bottom: none; }
    .model-item label { margin: 0; display: flex; align-items: center; gap: 10px; cursor: pointer; color: var(--text); flex: 1;}
    
    .proc-progress-container { display: none; flex-direction: column; gap: 8px; margin-top: 10px; }
    .proc-progress-container.active { display: flex; }
    .proc-progress-track { width: 100%; height: 8px; background: var(--line); border-radius: 4px; overflow: hidden; }
    .proc-progress-fill { width: 0%; height: 100%; background: var(--success); transition: width 0.3s ease; }
    .proc-status-text { font-size: 11px; color: var(--muted); text-align: right; }
  </style>
</head>

<body>
  <div class="wrap">
    
    <div class="card">
      <h1>Game Generator Projects</h1>
      
      <label>Active Project</label>
      <select id="projectSelect">
        <option value="">Loading projects...</option>
      </select>

      <div style="margin-top: 20px; border-top: 1px solid var(--line); padding-top: 20px;">
        <label>Create New Project</label>
        <div class="row">
          <input type="text" id="newProjectName" placeholder="e.g. SpaceShooter_v1" />
          <button class="btn btnPrimary" id="createProjectBtn">Create</button>
        </div>
      </div>

      <div id="globalStatus" class="status-bar">System ready.</div>
      <div id="progressContainer" style="display: none; margin-top: 10px; background: var(--line); border-radius: 8px; height: 8px; overflow: hidden;">
        <div id="progressBar" style="width: 0%; height: 100%; background: var(--accent); transition: width 0.2s ease;"></div>
      </div>
    </div>

    <div class="card" id="mainPanel" style="opacity: 0.5; pointer-events: none;">
      <div class="row" style="justify-content: space-between; margin-bottom: 20px;">
        <h1>Project Assets Manager</h1>
        <div class="row">
            <button class="btn btnPrimary" id="generateGameBtn" disabled>Generate Game Zip</button>
        </div>
      </div>

      <div id="dropZones">
      </div>

      <div id="reviewPanel" class="review-panel">
        <div class="row" style="justify-content: space-between;">
            <h2 style="color: var(--accent); margin:0;">AI Changes Review (Copies)</h2>
            <button class="btn btnSmall" id="clearReviewBtn">Dismiss All</button>
        </div>
        <div id="reviewFileList" class="review-list"></div>
      </div>

      <div id="assetLibrary" class="asset-library">
        <div class="row" style="justify-content: space-between; margin-bottom: 10px;">
            <h2 style="color: var(--success); margin:0;">Game Assets Library</h2>
            <span style="font-size: 11px; color: var(--muted);">Select files to include in your next AI prompt</span>
        </div>
        <div id="assetList" style="display:flex; flex-direction:column; max-height: 250px; overflow-y:auto; border: 1px solid var(--line); border-radius: 8px; background: #0b0d12;">
            </div>
      </div>

      <div style="margin-top: 30px; border-top: 1px solid var(--line); padding-top: 20px;">
        <h2>AI Context Window</h2>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <div id="aiChatLog" style="height: 400px; overflow-y: auto; background: #0b0d12; border: 1px solid var(--line); border-radius: 10px; padding: 14px; font-size: 13px; font-family: monospace; display: flex; flex-direction: column; gap: 12px; white-space: pre-wrap; line-height: 1.5;">
            <div style="color: var(--muted);">AI Context ready. Enter instructions below to modify the active project.</div>
          </div>
          
          <div style="position: relative; width: 100%;">
            <textarea id="aiPromptInput" placeholder="e.g., 'Change the player movement speed in main.js to 500 and update the index.html title...'" style="min-height: 80px; resize: vertical; width: 100%; padding-right: 140px;"></textarea>
            <div id="imageTagContainer" style="position: absolute; top: 10px; right: 10px; display: flex; flex-direction: column; gap: 6px; z-index: 10; pointer-events: none;"></div>
          </div>
          
          <div class="row" style="justify-content: flex-end;">
            <button class="btn btnPrimary" id="sendToAiBtn">Apply AI Update</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 30px; border-top: 1px solid var(--line); padding-top: 20px;">
        <h2>AI Context Code Review</h2>
        <div id="aiCodeReviewLog" style="height: 400px; overflow-y: auto; background: #0b0d12; border: 1px solid var(--line); border-radius: 10px; padding: 14px; font-size: 13px; font-family: monospace; display: flex; flex-direction: column; gap: 12px; white-space: pre-wrap; line-height: 1.5;">
          <div style="color: var(--muted);">Code diff updates will appear here after an AI run.</div>
        </div>
      </div>

    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getStorage, ref, uploadBytesResumable, uploadString, getDownloadURL, listAll, deleteObject, getMetadata } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const ROOT = "game-generator-1/projects";
    
    // Config matches your Listing Generator
    const firebaseConfig = {
      apiKey: "AIzaSyBXhQLsYRa4i0bX1TPTRiElF9Zjy5vSHlA",
      authDomain: "gokudatabase.firebaseapp.com",
      projectId: "gokudatabase",
      storageBucket: "gokudatabase.firebasestorage.app",
      messagingSenderId: "1078662308113",
      appId: "1:1078662308113:web:41df0e5d229ff2af7a6cb0"
    };

    const app = initializeApp(firebaseConfig);
    const storage = getStorage(app);
    const auth = getAuth(app);

    // AI INSTRUCTION CATEGORY UPDATED
    const FILE_CATEGORIES = [
      { id: "instructions", title: "AI System Instructions", accepts: "text/plain,.txt", folder: "ai_system_instructions" },
      { id: "assets", title: "Game Assets (Images/Audio)", accepts: "image/*,audio/*,.png,.jpg,.jpeg,.mp3,.wav", folder: "assets" },
      { id: "object_zip", title: "Animated/Textured Object ZIP Package", accepts: ".zip", folder: "object_zips" },
      { id: "models", title: "Models, Logic & HTML", accepts: ".obj,.glb,.fbx,.js,.mtl,.html", folder: "models" },
      { id: "json", title: "JSON Configs", accepts: ".json", folder: "json" },
      { id: "reference", title: "Reference Project ZIP", accepts: ".zip", folder: "reference_zip" }
    ];

    let currentProject = null;

    // --- UI Elements ---
    const projectSelect = document.getElementById('projectSelect');
    const newProjectName = document.getElementById('newProjectName');
    const createProjectBtn = document.getElementById('createProjectBtn');
    const mainPanel = document.getElementById('mainPanel');
    const dropZonesContainer = document.getElementById('dropZones');
    const globalStatus = document.getElementById('globalStatus');
    const generateGameBtn = document.getElementById('generateGameBtn');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');

    // AI UI Elements
    const aiPromptInput = document.getElementById('aiPromptInput');
    const sendToAiBtn = document.getElementById('sendToAiBtn');
    const aiChatLog = document.getElementById('aiChatLog');
    const aiCodeReviewLog = document.getElementById('aiCodeReviewLog');

    // Review UI Elements
    const reviewPanel = document.getElementById('reviewPanel');
    const reviewFileList = document.getElementById('reviewFileList');
    const clearReviewBtn = document.getElementById('clearReviewBtn');

    function setStatus(msg) {
        globalStatus.textContent = msg;
        globalStatus.classList.add('active');
        setTimeout(() => globalStatus.classList.remove('active'), 4000);
    }

    // --- Auth Initialization ---
    async function ensureAuth() {
      if (auth.currentUser) return auth.currentUser;
      try { await signInAnonymously(auth); } catch(e) { console.error("Auth failed", e); }
      return new Promise(resolve => {
        const unsub = onAuthStateChanged(auth, u => {
          if (u) { unsub(); resolve(u); }
        });
      });
    }

    // --- Project Management ---
    async function loadProjects() {
      await ensureAuth();
      const listRef = ref(storage, ROOT);
      try {
        const res = await listAll(listRef);
        projectSelect.innerHTML = res.prefixes.length > 0 ? '' : '<option value="">No projects found</option>';
        
        res.prefixes.forEach(folderRef => {
          const opt = document.createElement('option');
          opt.value = folderRef.name;
          opt.textContent = folderRef.name;
          projectSelect.appendChild(opt);
        });

        if (res.prefixes.length > 0) {
          selectProject(projectSelect.value);
        }
      } catch (e) {
        console.error("Error loading projects", e);
        projectSelect.innerHTML = '<option value="">Error loading</option>';
      }
    }

    createProjectBtn.addEventListener('click', async () => {
      const name = newProjectName.value.trim().replace(/[^a-zA-Z0-9_-]/g, '_');
      if (!name) return alert("Enter a valid project name.");
      
      setStatus(`Creating project: ${name}...`);
      await ensureAuth();
      
      const dummyRef = ref(storage, `${ROOT}/${name}/meta.json`);
      const blob = new Blob([JSON.stringify({ created: new Date() })], { type: 'application/json' });
      await uploadBytesResumable(dummyRef, blob);
      
      newProjectName.value = '';
      await loadProjects();
      projectSelect.value = name;
      selectProject(name);
    });

    projectSelect.addEventListener('change', (e) => selectProject(e.target.value));

    function selectProject(name) {
      if (!name) return;
      currentProject = name;
      mainPanel.style.opacity = '1';
      mainPanel.style.pointerEvents = 'all';
      
      generateGameBtn.disabled = false; 

      setStatus(`Switched to project: ${name}`);
      renderDropZones();
      refreshAllFiles();
      refreshReviewList();
      refreshAssetLibrary();
      aiChatLog.innerHTML = `<div style="color: var(--muted);">AI Context ready for project: ${name}. Enter instructions below.</div>`;
      aiCodeReviewLog.innerHTML = `<div style="color: var(--muted);">Code diff updates will appear here after an AI run.</div>`;
    }

    // --- Drag & Drop UI & Logic ---
    function renderDropZones() {
      dropZonesContainer.innerHTML = '';
      
      FILE_CATEGORIES.forEach(cat => {
        const zone = document.createElement('div');
        zone.className = 'drop-zone';
        zone.id = `zone_${cat.id}`;
        
        zone.innerHTML = `
          <div class="drop-header">
            <strong>${cat.title}</strong>
            <span>Accepts: ${cat.accepts}</span>
          </div>
          <div class="file-list" id="list_${cat.id}">
             <div style="font-size:11px; color:var(--muted);">Loading files...</div>
          </div>
          <input type="file" accept="${cat.accepts}" id="input_${cat.id}" style="display:none;" />
          <button class="btn btnSmall" onclick="document.getElementById('input_${cat.id}').click()" style="width: max-content;">+ Upload File</button>
        `;

        zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('hover'); });
        zone.addEventListener('dragleave', () => zone.classList.remove('hover'));
        zone.addEventListener('drop', async (e) => {
          e.preventDefault();
          zone.classList.remove('hover');
          handleFiles(e.dataTransfer.files, cat);
        });

        const fileInput = zone.querySelector(`#input_${cat.id}`);
        fileInput.addEventListener('change', (e) => {
          handleFiles(e.target.files, cat);
          fileInput.value = ''; 
        });

        dropZonesContainer.appendChild(zone);
      });
    }

    async function handleFiles(files, categoryConfig, specificName = null) {
      if (!files || files.length === 0) return;
      await ensureAuth();

      const validExts = categoryConfig.accepts.split(',');
      const isWildcard = categoryConfig.accepts.includes('*');
      
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        const parts = file.name.split('.');
        const hasExtension = parts.length > 1;
        const fileExt = hasExtension ? '.' + parts.pop().toLowerCase() : '';
        
        if (hasExtension && !validExts.includes(fileExt) && !isWildcard) {
           alert(`Invalid file: ${file.name}. Expected ${categoryConfig.accepts}`);
           continue;
        }

        const fileName = specificName || file.name.replace(/[^a-zA-Z0-9_.-]/g, '_');
        const path = `${ROOT}/${currentProject}/${categoryConfig.folder}/${fileName}`;
        const targetRef = ref(storage, path);
        
        setStatus(`Uploading ${fileName}...`);
        
        try {
          await new Promise((resolve, reject) => {
            const task = uploadBytesResumable(targetRef, file);
            task.on('state_changed', null, reject, resolve);
          });
        } catch(e) {
          console.error("Upload failed", e);
          alert(`Upload failed for ${fileName}`);
        }
      }
      
      setStatus(`Uploads complete.`);
      refreshFileList(categoryConfig);
    }

    // --- File Listing & Actions ---
    async function refreshAllFiles() {
      FILE_CATEGORIES.forEach(cat => refreshFileList(cat));
    }

    async function refreshFileList(categoryConfig) {
      if (!currentProject) return;
      const listContainer = document.getElementById(`list_${categoryConfig.id}`);
      if (!listContainer) return;
      
      const folderRef = ref(storage, `${ROOT}/${currentProject}/${categoryConfig.folder}`);
      
      try {
        const res = await listAll(folderRef);
        listContainer.innerHTML = '';
        
        if (res.items.length === 0) {
            listContainer.innerHTML = `<div style="font-size:11px; color:var(--muted);">No files uploaded. Drag & Drop here.</div>`;
            return;
        }

        res.items.forEach(itemRef => {
          const itemDiv = document.createElement('div');
          itemDiv.className = 'file-item';
          itemDiv.id = `item_${itemRef.name.replace(/[^a-zA-Z0-9]/g, '_')}`; // For animations
          
          itemDiv.innerHTML = `
            <div class="file-name">${itemRef.name}</div>
            <div class="file-actions">
               <input type="file" style="display:none;" id="replace_${itemRef.name.replace(/\./g,'_')}" accept="${categoryConfig.accepts}">
               <button class="btn btnSmall" onclick="document.getElementById('replace_${itemRef.name.replace(/\./g,'_')}').click()">Replace</button>
               <button class="btn btnSmall btnDanger" id="del_${itemRef.name.replace(/\./g,'_')}">Delete</button>
            </div>
          `;

          itemDiv.querySelector(`[id="del_${itemRef.name.replace(/\./g,'_')}"]`).addEventListener('click', async () => {
             if(confirm(`Delete ${itemRef.name}?`)) {
                 setStatus(`Deleting ${itemRef.name}...`);
                 await deleteObject(itemRef);
                 refreshFileList(categoryConfig);
                 setStatus(`Deleted.`);
             }
          });

          itemDiv.querySelector(`[id="replace_${itemRef.name.replace(/\./g,'_')}"]`).addEventListener('change', (e) => {
              handleFiles(e.target.files, categoryConfig, itemRef.name);
          });

          listContainer.appendChild(itemDiv);
        });

        if (categoryConfig.id === 'assets' || categoryConfig.id === 'models' || categoryConfig.id === 'object_zip') refreshAssetLibrary();

      } catch (e) {
        console.error(`Error loading files for ${categoryConfig.id}`, e);
        listContainer.innerHTML = `<div style="font-size:11px; color:var(--danger);">Error fetching files.</div>`;
      }
    }

// --- Game Assets Library Rendering ---
async function refreshAssetLibrary() {
        if (!currentProject) return;
        const libraryContainer = document.getElementById('assetLibrary');
        const listContainer = document.getElementById('assetList');
        
        const assetsRef = ref(storage, `${ROOT}/${currentProject}/assets`);
        const modelsRef = ref(storage, `${ROOT}/${currentProject}/models`);
        const objectZipsRef = ref(storage, `${ROOT}/${currentProject}/object_zips`);

        try {
            const [assetsRes, modelsRes, objectZipsRes] = await Promise.all([
                listAll(assetsRef).catch(() => ({items:[]})),
                listAll(modelsRef).catch(() => ({items:[]})),
                listAll(objectZipsRef).catch(() => ({items:[]}))
            ]);
            
            const allItems = [...assetsRes.items, ...modelsRes.items, ...objectZipsRes.items];

            if (allItems.length === 0) {
                libraryContainer.classList.remove('active');
                listContainer.innerHTML = '';
                return;
            }

            let htmlBuffer = '';

            for (const itemRef of allItems) {
                const meta = await getMetadata(itemRef);
                const url = await getDownloadURL(itemRef);
                const dateStr = new Date(meta.timeCreated).toLocaleString();
                const dataPath = `${itemRef.parent.name}/${itemRef.name}`;

                htmlBuffer += `
                    <div class="asset-item">
                        <label>
                            <input type="checkbox" class="asset-checkbox" 
                                data-path="${dataPath}" 
                                data-url="${url}" 
                                data-type="${meta.contentType || ''}" 
                                data-name="${itemRef.name}">
                            <span>‚ú® ${itemRef.name}</span>
                        </label>
                        <span class="asset-date">${itemRef.parent.name.toUpperCase()} ‚Ä¢ ${dateStr}</span>
                    </div>
                `;
            }
            
            listContainer.innerHTML = htmlBuffer;
            libraryContainer.classList.add('active');

        } catch (e) { 
            console.error("Asset library error", e); 
        }
    }

    // --- Image Drag & Drop for AI Prompt ---
    const imageTagContainer = document.getElementById('imageTagContainer');
    let attachedPromptImages = []; // Array to store the actual File objects for the AI payload

    function renderPromptImages() {
        imageTagContainer.innerHTML = '';
        attachedPromptImages.forEach((file, index) => {
            const tag = document.createElement('div');
            tag.className = 'img-ref-tag';
            tag.innerHTML = `
                <span class="preview-trigger" style="max-width: 120px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer;" title="Click to preview">üñºÔ∏è ${file.name}</span>
                <span class="remove-img" data-index="${index}">‚úï</span>
            `;
            imageTagContainer.appendChild(tag);

            // Open Preview Modal on click
            tag.querySelector('.preview-trigger').addEventListener('click', () => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('previewImageSrc').src = e.target.result;
                    document.getElementById('imagePreviewModal').classList.add('active');
                };
                reader.readAsDataURL(file);
            });
        });

        // Add event listeners to the new "x" buttons
        document.querySelectorAll('.remove-img').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const idx = parseInt(e.target.getAttribute('data-index'));
                attachedPromptImages.splice(idx, 1);
                renderPromptImages();
            });
        });
    }

    aiPromptInput.addEventListener('dragover', (e) => {
        e.preventDefault();
        aiPromptInput.classList.add('ai-prompt-drag-hover');
    });

    aiPromptInput.addEventListener('dragleave', (e) => {
        e.preventDefault();
        aiPromptInput.classList.remove('ai-prompt-drag-hover');
    });

    aiPromptInput.addEventListener('drop', (e) => {
        e.preventDefault();
        aiPromptInput.classList.remove('ai-prompt-drag-hover');
        
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            Array.from(e.dataTransfer.files).forEach(file => {
                if (file.type.startsWith('image/')) {
                    attachedPromptImages.push(file);
                }
            });
            renderPromptImages();
        }
    });

    // --- Close Preview Modal Logic ---
    const closePreviewBtn = document.getElementById('closePreviewBtn');
    if (closePreviewBtn) {
        closePreviewBtn.addEventListener('click', () => {
            document.getElementById('imagePreviewModal').classList.remove('active');
            document.getElementById('previewImageSrc').src = '';
        });
    }
    
    // Close modal if clicking outside the image itself
    const imagePreviewModal = document.getElementById('imagePreviewModal');
    if (imagePreviewModal) {
        imagePreviewModal.addEventListener('click', (e) => {
            if (e.target === imagePreviewModal) {
                imagePreviewModal.classList.remove('active');
                document.getElementById('previewImageSrc').src = '';
            }
        });
    }

    // --- AI Review Persistence Logic ---
    async function refreshReviewList() {
        if (!currentProject) return;
        const reviewFolderRef = ref(storage, `${ROOT}/${currentProject}/review`);

        try {
            const res = await listAll(reviewFolderRef);
            if (res.items.length === 0) {
                reviewPanel.classList.remove('active');
                return;
            }

            reviewPanel.classList.add('active');
            reviewFileList.innerHTML = '';

            for (const itemRef of res.items) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'review-item';
                itemDiv.innerHTML = `
                    <div class="file-name">‚ú® ${itemRef.name}</div>
                    <div class="file-actions">
                        <button class="btn btnSmall" id="dl_rev_${itemRef.name.replace(/\./g,'_')}">Download</button>
                        <button class="btn btnSmall btnDanger" id="del_rev_${itemRef.name.replace(/\./g,'_')}">Delete Copy</button>
                    </div>
                `;

                itemDiv.querySelector(`#dl_rev_${itemRef.name.replace(/\./g,'_')}`).onclick = async () => {
                    const url = await getDownloadURL(itemRef);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `PREVIEW_${itemRef.name}`;
                    a.click();
                };

                itemDiv.querySelector(`#del_rev_${itemRef.name.replace(/\./g,'_')}`).onclick = async () => {
                    await deleteObject(itemRef);
                    refreshReviewList();
                };

                reviewFileList.appendChild(itemDiv);
            }
        } catch (e) { console.error("Review list error", e); }
    }

    clearReviewBtn.onclick = async () => {
        const reviewFolderRef = ref(storage, `${ROOT}/${currentProject}/review`);
        const res = await listAll(reviewFolderRef);
        await Promise.all(res.items.map(item => deleteObject(item)));
        refreshReviewList();
    };

    // --- AI Context Window Logic & Loop ---
    function appendToChatLog(sender, message, type = 'normal') {
      const msgDiv = document.createElement('div');
      const color = sender === 'AI' ? 'var(--success)' : (type === 'error' ? 'var(--danger)' : 'var(--text)');
      msgDiv.innerHTML = `<strong style="color: ${color}">${sender}:</strong> ${message}`;
      aiChatLog.appendChild(msgDiv);
      aiChatLog.scrollTop = aiChatLog.scrollHeight;
    }

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    // --- NEW MODAL INTERCEPTOR LOGIC FOR SEND TO AI ---
    const modelProcessingModal = document.getElementById('modelProcessingModal');
    const modalModelList = document.getElementById('modalModelList');
    const skipProcessingBtn = document.getElementById('skipProcessingBtn');
    const startProcessingBtn = document.getElementById('startProcessingBtn');
    const procProgressContainer = document.getElementById('procProgressContainer');
    const procProgressFill = document.getElementById('procProgressFill');
    const procStatusText = document.getElementById('procStatusText');
    const procCurrentFile = document.getElementById('procCurrentFile');
    const procActionButtons = document.getElementById('procActionButtons');

    let available3DModels = [];
    let pendingAiPrompt = "";

    sendToAiBtn.addEventListener('click', async () => {
        pendingAiPrompt = aiPromptInput.value.trim();
        if (!pendingAiPrompt || !currentProject) return;

        setStatus("Checking for 3D models...");
        sendToAiBtn.disabled = true;

        available3DModels = [];
        const modelsRef = ref(storage, `${ROOT}/${currentProject}/models`);

        try {
            const res = await listAll(modelsRef);
            const validExtensions = ['.obj', '.glb', '.fbx', '.c3b'];

            res.items.forEach(item => {
                const lowerName = item.name.toLowerCase();
                if (validExtensions.some(ext => lowerName.endsWith(ext))) {
                    available3DModels.push(item);
                }
            });
        } catch(e) { console.warn("Could not fetch models folder", e); }

        // If no models found, bypass the modal and go straight to AI
        if (available3DModels.length === 0) {
            await executeAIPipeline(pendingAiPrompt);
            return;
        }

        // Populate Modal
        modalModelList.innerHTML = '';
        available3DModels.forEach((item, index) => {
            modalModelList.innerHTML += `
                <div class="model-item">
                    <label>
                        <input type="checkbox" class="modal-model-cb" data-index="${index}" checked>
                        <span>üì¶ ${item.name}</span>
                    </label>
                </div>
            `;
        });

        // Reset UI state and show modal
        procProgressContainer.classList.remove('active');
        procActionButtons.style.display = 'flex';
        modelProcessingModal.classList.add('active');
    });

    skipProcessingBtn.addEventListener('click', async () => {
        modelProcessingModal.classList.remove('active');
        await executeAIPipeline(pendingAiPrompt);
    });

    startProcessingBtn.addEventListener('click', async () => {
        const checkboxes = document.querySelectorAll('.modal-model-cb:checked');
        if (checkboxes.length === 0) {
            modelProcessingModal.classList.remove('active');
            await executeAIPipeline(pendingAiPrompt);
            return;
        }

        procActionButtons.style.display = 'none';
        procProgressContainer.classList.add('active');

        const total = checkboxes.length;
        let completed = 0;

        for (const cb of checkboxes) {
            const itemRef = available3DModels[cb.dataset.index];

            try {
                procCurrentFile.textContent = `Processing ${itemRef.name}...`;
                procStatusText.textContent = `Fetching file...`;

                const downloadUrl = await getDownloadURL(itemRef);
                const fileRes = await fetch(downloadUrl);
                const fileBlob = await fileRes.blob();

                procStatusText.textContent = `Centering pivot via server...`;

                /* NOTE: Ensure your Netlify function /.netlify/functions/center3dModel is set up to handle this Blob */
                const processRes = await fetch('/.netlify/functions/center3dModel', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/octet-stream', 'X-File-Name': itemRef.name },
                    body: fileBlob
                });

                if (!processRes.ok) throw new Error("Processing server failed.");
                const processedBlob = await processRes.blob();

                procStatusText.textContent = `Updating Firebase...`;
                const targetRef = ref(storage, `${ROOT}/${currentProject}/models/${itemRef.name}`);
                await uploadBytesResumable(targetRef, processedBlob);

                completed++;
                procProgressFill.style.width = `${(completed / total) * 100}%`;
                procStatusText.textContent = `${completed} / ${total} Completed`;

            } catch (error) {
                console.error(`Failed to process ${itemRef.name}:`, error);
                procStatusText.textContent = `Failed on ${itemRef.name}`;
                procStatusText.style.color = "var(--danger)";
                await new Promise(r => setTimeout(r, 2000)); // Pause to let user read error
            }
        }

        procCurrentFile.textContent = "All selected models processed!";
        procCurrentFile.style.color = "var(--success)";

        setTimeout(async () => {
            modelProcessingModal.classList.remove('active');
            await executeAIPipeline(pendingAiPrompt);
        }, 1500);
    });

    // --- ORIGINAL AI EXECUTION PIPELINE ---
    async function executeAIPipeline(promptOverride) {
      const prompt = promptOverride || aiPromptInput.value.trim();
      if (!prompt || !currentProject) {
          sendToAiBtn.disabled = false;
          return;
      }

      aiPromptInput.value = '';
      appendToChatLog('You', prompt);
      
      try {
        // 1. Read Reference ZIP and Map Structure
        appendToChatLog('System', 'Mapping project structure from Reference ZIP...', 'muted');
        let projectStructure = "Project Directory Map:\n";
        const refFolder = ref(storage, `${ROOT}/${currentProject}/reference_zip`);
        let zipFound = false;
        
        try {
          const refList = await listAll(refFolder);
          if (refList.items.length > 0) {
            const refUrl = await getDownloadURL(refList.items[0]);
            const refRes = await fetch(refUrl);
            const refBlob = await refRes.blob();
            
            const zip = new JSZip();
            await zip.loadAsync(refBlob);
            projectStructure += Object.keys(zip.files).join('\n');
            zipFound = true;
          }
        } catch (e) {
          console.warn("Could not read Reference ZIP for structure.", e);
        }

        if (!zipFound) {
            projectStructure += "(No Reference ZIP uploaded yet)";
        }

        // 2. Gather explicitly targeted files
        appendToChatLog('System', 'Gathering logic file "2", HTML file "23", and config "assets.json"...', 'muted');
        const projectFiles = {};
        const targetFiles = [
          { folder: 'models', name: '2' },
          { folder: 'models', name: '23' },
          { folder: 'json', name: 'assets.json' }
        ];

        for (const target of targetFiles) {
          const fileRef = ref(storage, `${ROOT}/${currentProject}/${target.folder}/${target.name}`);
          try { 
            const url = await getDownloadURL(fileRef);
            const fetched = await fetch(url + '&v=' + Date.now(), { cache: 'no-store' });
            if (fetched.ok) {
                projectFiles[`${target.folder}/${target.name}`] = await fetched.text(); 
            }
          } catch (e) { 
             console.warn(`Skipped ${target.name} - not found in Firebase storage.`); 
          } 
        }

        if (Object.keys(projectFiles).length === 0) {
          throw new Error("Could not find '2', '23', or 'assets.json'. Please upload them first.");
        }

        // Gather ALL Uploaded Assets & Extract Custom Object Zips on the fly
        const allAssetNodes = document.querySelectorAll('.asset-checkbox');
        const allAssets = Array.from(allAssetNodes).map(cb => ({
            name: cb.dataset.name,
            path: cb.dataset.path,
            url: cb.dataset.url,
            type: cb.dataset.type,
            isChecked: cb.checked
        }));
        
        // Preserve selectedAssets for the backend proxy payload
        const selectedAssets = allAssets.filter(a => a.isChecked);

        let assetString = "";
        let zipContextString = "";

        if (allAssets.length > 0) {
            assetString = "\n\n=== FULL ASSET INVENTORY ===\nCRITICAL: The following files are available in the project storage. You MUST ensure all relevant files are mapped into assets.json:\n";
            for (const a of allAssets) {
                const selectionNote = a.isChecked ? " [EXPLICITLY SELECTED BY USER]" : "";
                assetString += `- ${a.path}${selectionNote}\n`;
                
                // UNZIP LOGIC FOR ALL OBJECT ZIPS
                if (a.path.includes('object_zips') && a.name.toLowerCase().endsWith('.zip')) {
                    appendToChatLog('System', `Extracting contents of Object Package ${a.name}...`, 'muted');
                    try {
                        const zipUrl = await getDownloadURL(ref(storage, `${ROOT}/${currentProject}/${a.path}`));
                        const zipRes = await fetch(zipUrl);
                        const zipBlob = await zipRes.blob();
                        const zipObj = new JSZip();
                        await zipObj.loadAsync(zipBlob);
                        
                        let parsedModels = [];
                        let parsedTextures = [];
                        let parsedAudio = [];
                        let parsedOther = [];
                        let parsedAnimInfo = "";
                        
                        for (const relativePath of Object.keys(zipObj.files)) {
                            const file = zipObj.files[relativePath];
                            if (file.dir || relativePath.includes('__MACOSX')) continue;
                            
                            const lowerPath = relativePath.toLowerCase();
                            if (lowerPath.endsWith('.obj') || lowerPath.endsWith('.glb') || lowerPath.endsWith('.gltf') || lowerPath.endsWith('.fbx') || lowerPath.endsWith('.c3b')) {
                                parsedModels.push(relativePath);
                            } else if (lowerPath.endsWith('.jpg') || lowerPath.endsWith('.png') || lowerPath.endsWith('.jpeg') || lowerPath.endsWith('.webp')) {
                                parsedTextures.push(relativePath);
                            } else if (lowerPath.endsWith('.wav') || lowerPath.endsWith('.mp3') || lowerPath.endsWith('.ogg')) {
                                parsedAudio.push(relativePath);
                            } else if (lowerPath.endsWith('.txt')) {
                                parsedAnimInfo += `\n--- Content of ${relativePath} ---\n`;
                                parsedAnimInfo += await file.async('string');
                            } else {
                                parsedOther.push(relativePath);
                            }
                        }
                        
                        zipContextString += `\n\n=== PARSED ZIP PACKAGE CONTENTS: ${a.name} ===\n`;
                        zipContextString += `3D Models Included: ${parsedModels.length > 0 ? parsedModels.join(', ') : 'None'}\n`;
                        zipContextString += `Textures Included: ${parsedTextures.length > 0 ? parsedTextures.join(', ') : 'None'}\n`;
                        zipContextString += `Audio Included: ${parsedAudio.length > 0 ? parsedAudio.join(', ') : 'None'}\n`;
                        if (parsedOther.length > 0) zipContextString += `Other Files: ${parsedOther.join(', ')}\n`;
                        if (parsedAnimInfo) zipContextString += `Animation ID Reference File: ${parsedAnimInfo}\n`;
                        zipContextString += `AI INSTRUCTION: Map ALL of these extracted file names into assets.json. Automatically infer the PBR texture maps (Albedo, Normal, etc.) based on the texture file suffixes and apply them to the material using createMaterial(). Use the Animation ID Reference to trigger the correct animations via gameState.playAnimation().\n`;
                        
                    } catch (e) {
                        console.warn(`Failed to parse object zip ${a.name}`, e);
                        appendToChatLog('System', `Warning: Could not parse ${a.name}`, 'error');
                    }
                }
            }
        }

        // 2.5 Gather AI System Instructions
        appendToChatLog('System', 'Fetching AI System Instructions...', 'muted');
        let aiInstructionsText = "No AI System Instructions provided.";
        const instructionsFolderRef = ref(storage, `${ROOT}/${currentProject}/ai_system_instructions`);
        try {
            const instList = await listAll(instructionsFolderRef);
            if (instList.items.length > 0) {
                const instUrl = await getDownloadURL(instList.items[0]);
                const instRes = await fetch(instUrl + '&v=' + Date.now(), { cache: 'no-store' });
                if (instRes.ok) {
                    aiInstructionsText = await instRes.text();
                }
            }
        } catch (e) {
            console.warn("Could not fetch AI System Instructions.", e);
        }

        // 3. Combine Structure Map, Instructions & Selected Assets with the User Prompt
        const enhancedPrompt = `Here is the full project structure for reference:\n${projectStructure}${assetString}${zipContextString}

        === AI SYSTEM INSTRUCTIONS ===
        ${aiInstructionsText}
        ==============================

        CRITICAL PROCESSING STEPS:
        1. Before starting analysis, you must first strictly read and interpret the "AI SYSTEM INSTRUCTIONS" provided above.
        2. Next, read, interpret, and understand the purpose and context of the explicitly targeted files ("2", "23", and "assets.json"), their relationship to the other files in the project map, and their function specifically in the context of the "AI SYSTEM INSTRUCTIONS".

        CRITICAL SYSTEM RULE: The main logic file is named "2" and the main HTML file is named "23", both located in the "models" folder. You MUST use the exact name "2" instead of "WorldController.js" and "23" instead of "document.html" in all your code, updates, references, and output paths. Never save or output a file named "WorldController.js" or "document.html".

        ASSET CONFIGURATION RULE: You must ensure "assets.json" (in the "json" folder) is updated to include any new assets requested by the user. If an asset the user mentions is not yet mapped in "assets.json", you MUST map it and return the updated "assets.json" file in your payload. When updating "assets.json", assign sequential numbers for the "key" property. CRITICAL: The "title" property for each mapped asset MUST be transposed exactly as its original file name, with no changes (e.g., {"key":"34","type":"object","title":"plane.obj"}). If you add or update an asset in "assets.json", you MUST also update file "2" to properly reference, load, or instantiate that new asset key so it is recognized and works within the system.

        RESPONSE RULE - CRITICAL OPTIMIZATION:
        To save time and tokens, YOU MUST NEVER OUTPUT THE FULL CONTENT OF A FILE. You must ONLY output the specific lines being changed using a SEARCH/REPLACE block format inside the "content" field of your JSON response. 
        Format your "content" string EXACTLY like this for every change:

        <<<<<<< SEARCH
        [exact code from the original file to be replaced, including a few lines of context before and after]
        =======
        [the new code to replace it with]
        >>>>>>> REPLACE

        Rules for SEARCH/REPLACE blocks:
        1. The SEARCH section MUST match the existing code in the file exactly, line for line, preserving whitespace and indentation. 
        2. Include enough context lines to ensure a unique match.
        3. You can include multiple SEARCH/REPLACE blocks for a single file.
        4. If adding a completely new file (not editing an existing one), output the full code without SEARCH/REPLACE tags.

        In your 'message' response, provide a highly detailed changelog breaking down exactly which files you modified and summarize the logic shifts.

        User Request: ${prompt}`;

        // 4. Prepare Storage references and clean up old runs
        const projectPath = `${ROOT}/${currentProject}`;
        const responseFileRef = ref(storage, `${projectPath}/ai_response.json`);
        const errorFileRef = ref(storage, `${projectPath}/ai_error.json`);
        
        try { await deleteObject(responseFileRef); } catch(e) {}
        try { await deleteObject(errorFileRef); } catch(e) {}

        // 5. Trigger Gemini Background Proxy
        appendToChatLog('System', 'Sending targeted files and map to AI...', 'muted');
        setStatus('AI is processing files (This may take a minute)...');

        // 4.5 Convert attached prompt images to Base64 for the AI
        appendToChatLog('System', 'Processing attached reference images...', 'muted');
        const inlineImages = await Promise.all(attachedPromptImages.map(async (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    // Extract just the base64 data, removing the "data:image/png;base64," prefix
                    const base64Data = reader.result.split(',')[1];
                    resolve({
                        name: file.name,
                        mimeType: file.type,
                        data: base64Data
                    });
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }));

        // Clear the attached images from the UI now that they are processed
        attachedPromptImages = [];
        renderPromptImages();
        
        await fetch('/.netlify/functions/geminiCodeProxy-background', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt: enhancedPrompt, files: projectFiles, projectPath, selectedAssets, inlineImages })
        });

        // 6. Poll Firebase Storage for the result file
        let result = null;
        let attempts = 0;
        
        while (!result && attempts < 60) {
          await sleep(30000); 
          attempts++;

          let hasErrorFile = false;
          let errorMessage = "AI Generation Failed";
          try {
            const errUrl = await getDownloadURL(errorFileRef);
            const errRes = await fetch(errUrl);
            const errData = await errRes.json();
            errorMessage = errData.error || errorMessage;
            hasErrorFile = true;
          } catch(e) {}

          if (hasErrorFile) throw new Error(errorMessage);

          try {
            const url = await getDownloadURL(responseFileRef);
            const res = await fetch(url + `&v=${Date.now()}`);
            result = await res.json();
          } catch(e) {}
        }

        if (!result) throw new Error("AI request timed out waiting for background completion.");

        // Helper to safely escape HTML for the UI code review
        const escapeHTML = (str) => str.replace(/[&<>'"]/g, tag => ({
            '&': '&amp;', '<': '&lt;', '>': '&gt;', "'": '&#39;', '"': '&quot;'
        }[tag]));

        // 7. Write updated files back to Firebase (WITH PATCHING LOGIC)
        appendToChatLog('System', `Writing ${result.updatedFiles.length} updated files to Firebase...`, 'muted');
        
        for (const file of result.updatedFiles) {
          let aiOutputContent = file.content.trim();
          if (aiOutputContent.startsWith('```')) {
              const lines = aiOutputContent.split('\n');
              if (lines[0].startsWith('```')) lines.shift();
              if (lines[lines.length - 1].trim().startsWith('```')) lines.pop();
              aiOutputContent = lines.join('\n').trim();
          }

          let fileName = file.path.split('/').pop(); 
          let safePath = file.path;

          if (fileName.toLowerCase() === 'worldcontroller.js' || fileName === '2.js') {
              fileName = '2';
              safePath = 'models/2';
          } else if (fileName.toLowerCase() === 'document.html' || fileName === '23.html') {
              fileName = '23';
              safePath = 'models/23';
          } else if (fileName.toLowerCase() === 'assets.json') {
              fileName = 'assets.json';
              safePath = 'json/assets.json';
          }

          const originalFileKey = Object.keys(projectFiles).find(k => k.toLowerCase().endsWith('/' + fileName.toLowerCase()));
          
          let finalContentToSave = aiOutputContent;
          let uiDisplayContent = escapeHTML(aiOutputContent); // Default if no patch tags

          // --- NEW PATCHING & UI INJECTION LOGIC ---
          if (aiOutputContent.includes('<<<<<<< SEARCH')) {
             let originalContent = originalFileKey ? projectFiles[originalFileKey] : "";
             
             if (!originalContent) {
                 appendToChatLog('System', `Warning: Could not find original content for ${fileName} to apply patch. Skipping file.`, 'error');
                 continue; 
             }

             const blockRegex = /<<<<<<< SEARCH[\r\n]+([\s\S]*?)[\r\n]+=======[\r\n]+([\s\S]*?)[\r\n]+>>>>>>> REPLACE/g;
             let normalizedResult = originalContent.replace(/\r\n/g, '\n');
             let uiResult = escapeHTML(normalizedResult); // Start with the full original escaped code
             let match;
             let changesMade = 0;

             while ((match = blockRegex.exec(aiOutputContent)) !== null) {
                 const searchTarget = match[1].replace(/\r\n/g, '\n');
                 const replacement = match[2];

                 if (normalizedResult.includes(searchTarget)) {
                     // 1. Execute standard patch for the file to be saved to Firebase
                     normalizedResult = normalizedResult.split(searchTarget).join(replacement);
                     
                     // 2. Execute UI string replacement with colors
                     const escapedSearch = escapeHTML(searchTarget);
                     const escapedReplace = escapeHTML(replacement);
                     const uiPatch = `<span style="color: var(--success); font-weight: bold;">${escapedSearch}</span>\n<span style="color: var(--danger); font-weight: bold;">${escapedReplace}</span>`;
                     
                     uiResult = uiResult.split(escapedSearch).join(uiPatch);
                     changesMade++;
                 } else {
                     console.warn(`Patch failed for ${fileName}. Code not found:\n`, searchTarget);
                     appendToChatLog('System', `Warning: A patch block for ${fileName} failed to match the existing code.`, 'error');
                 }
             }

             if (changesMade > 0) {
                 finalContentToSave = normalizedResult;
                 uiDisplayContent = uiResult; // Store the HTML-injected full file for UI rendering
             } else {
                 appendToChatLog('System', `Failed to apply any patches to ${fileName}. Ensure AI provides exact matching code.`, 'error');
                 continue; 
             }
          }
          
      file.uiContent = uiDisplayContent; // Attach the formatted HTML context for step 8
          file.rawContent = finalContentToSave; // Store the raw unescaped code for the clipboard
          // --------------------------

          const targetRef = ref(storage, `${ROOT}/${currentProject}/${safePath}`);
          await uploadString(targetRef, finalContentToSave);
          
          const catFolder = safePath.split('/')[0];
          const catConfig = FILE_CATEGORIES.find(c => c.folder === catFolder);
          if (catConfig) {
            const zone = document.getElementById(`zone_${catConfig.id}`);
            if (zone) {
              zone.classList.remove('pulse-update');
              void zone.offsetWidth; 
              zone.classList.add('pulse-update');
            }
          }
        }

        // 8. Update UI Code Review
        appendToChatLog('AI', result.message || "Files have been updated successfully.");
        setStatus('AI update complete.');

        aiCodeReviewLog.innerHTML = ''; 
        
        if (result.updatedFiles && result.updatedFiles.length > 0) {
            result.updatedFiles.forEach(file => {
                const fileContainer = document.createElement('div');
                // Creating a much larger and more visible separation block
                fileContainer.style.border = '2px solid var(--accent)';
                fileContainer.style.borderRadius = '12px';
                fileContainer.style.background = '#151a2a'; // Slightly offset from standard background
                fileContainer.style.padding = '24px';
                fileContainer.style.marginBottom = '50px'; 
                fileContainer.style.boxShadow = '0 6px 20px rgba(0,0,0,0.4)';

                const fileHeader = document.createElement('div');
                fileHeader.style.display = 'flex';
                fileHeader.style.justifyContent = 'space-between';
                fileHeader.style.alignItems = 'center';
                fileHeader.style.borderBottom = '2px solid var(--line)';
                fileHeader.style.paddingBottom = '12px';
                fileHeader.style.marginBottom = '16px';

                const titleSpan = document.createElement('span');
                titleSpan.style.color = 'var(--accent)';
                titleSpan.style.fontSize = '16px';
                titleSpan.style.fontWeight = 'bold';
                titleSpan.textContent = `File Updated: ${file.path} (Full Context View)`;

                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn btnSmall';
                copyBtn.textContent = 'Copy Code';
                copyBtn.onclick = () => {
                    navigator.clipboard.writeText(file.rawContent || '').then(() => {
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.backgroundColor = 'var(--success)';
                        copyBtn.style.borderColor = 'var(--success)';
                        copyBtn.style.color = '#000';
                        setTimeout(() => {
                            copyBtn.textContent = 'Copy Code';
                            copyBtn.style.backgroundColor = '';
                            copyBtn.style.borderColor = '';
                            copyBtn.style.color = '';
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy code: ', err);
                        copyBtn.textContent = 'Failed';
                    });
                };

                fileHeader.appendChild(titleSpan);
                fileHeader.appendChild(copyBtn);

                const editorContainer = document.createElement('div');
                editorContainer.style.width = '100%';
                
                fileContainer.appendChild(fileHeader);
                fileContainer.appendChild(editorContainer);
                aiCodeReviewLog.appendChild(fileContainer);

                // Determine language syntax based on file extension
                let editorMode = "javascript";
                if (file.path.endsWith('.html')) editorMode = "htmlmixed";
                else if (file.path.endsWith('.json')) editorMode = "application/json";

                // Initialize fully-fledged CodeMirror editor
                const editor = CodeMirror(editorContainer, {
                    value: file.rawContent || '',
                    mode: editorMode,
                    theme: "monokai",
                    lineNumbers: true,
                    lineWrapping: true, // Forces text to wrap correctly
                    readOnly: false     // Makes it fully editable
                });

                // Small timeout to force layout refresh after injection
                setTimeout(() => editor.refresh(), 100);
            });
        } else {
            aiCodeReviewLog.innerHTML = '<div style="color: var(--muted);">No code changes detected in this run.</div>';
        }

        refreshAllFiles();
        refreshReviewList(); 
        document.querySelectorAll('.asset-checkbox').forEach(cb => cb.checked = false);

      } catch (error) {
        console.error("AI Update Error:", error);
        appendToChatLog('System', `Error: ${error.message}`, 'error');
        setStatus('AI update failed.');
      } finally {
        sendToAiBtn.disabled = false;
      }
    }

// --- Zip Generation Logic (Template Matcher) ---
    generateGameBtn.addEventListener('click', async () => {
      if (!currentProject) return;
      
      try {
        generateGameBtn.disabled = true;
        progressContainer.style.display = 'block';
        progressBar.style.width = '5%';
        setStatus(`Fetching Reference ZIP for ${currentProject}...`);
        
        const refFolder = ref(storage, `${ROOT}/${currentProject}/reference_zip`);
        const refList = await listAll(refFolder);
        
        if (refList.items.length === 0) {
           alert("No Reference ZIP found! Please upload one to the Reference Project ZIP drop zone first.");
           throw new Error("Missing reference zip");
        }
        
        const referenceZipRef = refList.items[0]; 
        const refUrl = await getDownloadURL(referenceZipRef);
        const refCacheBust = refUrl.includes('?') ? `${refUrl}&_ts=${new Date().getTime()}` : `${refUrl}?_ts=${new Date().getTime()}`;

        const refRes = await fetch(refCacheBust, { cache: 'no-store' });
        const refBlob = await refRes.blob();
        
        progressBar.style.width = '15%';
        setStatus(`Loading template ZIP into memory...`);
        const zip = new JSZip();
        await zip.loadAsync(refBlob);
        const zipPaths = Object.keys(zip.files);
        
        setStatus(`Parsing assets.json for file mappings...`);
        const normalizeStr = (str) => String(str).toLowerCase().replace(/[^a-z0-9]/g, '');
        let assetMap = {};
        try {
            const assetsJsonRef = ref(storage, `${ROOT}/${currentProject}/json/assets.json`);
            const assetsJsonUrl = await getDownloadURL(assetsJsonRef);
            
            const safeAssetsUrl = assetsJsonUrl.includes('?') 
                ? `${assetsJsonUrl}&_ts=${new Date().getTime()}` 
                : `${assetsJsonUrl}?_ts=${new Date().getTime()}`;
                
            const assetsJsonRes = await fetch(safeAssetsUrl, {cache: 'no-store'});
            
            if (!assetsJsonRes.ok) throw new Error(`Failed to fetch assets.json: ${assetsJsonRes.statusText}`);
            const assetsData = await assetsJsonRes.json();
            
            function extractMappings(obj) {
                if (!obj) return;
                if (typeof obj === 'object') {
                    if (obj.key !== undefined && obj.title !== undefined) {
                        // Store the exact title for exact matching
                        assetMap[String(obj.title)] = String(obj.key);
                        
                        const titleStr = String(obj.title).toLowerCase();
                        assetMap[titleStr] = String(obj.key);
                        assetMap[normalizeStr(obj.title)] = String(obj.key);
                        
                        if (titleStr.includes('.')) {
                            const nameOnly = titleStr.substring(0, titleStr.lastIndexOf('.'));
                            assetMap[nameOnly] = String(obj.key);
                            assetMap[normalizeStr(nameOnly)] = String(obj.key);
                        } else {
                            assetMap[normalizeStr(obj.title)] = String(obj.key);
                        }
                    }
                    for (let k in obj) {
                        if (typeof obj[k] === 'object') extractMappings(obj[k]);
                    }
                }
            }
            extractMappings(assetsData);
        } catch (e) {
            console.warn("Could not pre-fetch/parse assets.json for mapping. Keys may not be renamed.", e);
        }

        progressBar.style.width = '20%';
        setStatus(`Indexing project files...`);
        let totalFiles = 0;
        let processedFiles = 0;
        const cachedCategories = {};

        for (const cat of FILE_CATEGORIES) {
          if (cat.id === 'reference' || cat.id === 'instructions') continue;
          const folderRef = ref(storage, `${ROOT}/${currentProject}/${cat.folder}`);
          try { 
             const res = await listAll(folderRef); 
             cachedCategories[cat.id] = res.items;
             totalFiles += res.items.length;
          } catch(e) { 
             cachedCategories[cat.id] = []; 
          }
        }

        for (const cat of FILE_CATEGORIES) {
          if (cat.id === 'reference' || cat.id === 'instructions') continue;
          
          const items = cachedCategories[cat.id];
          
          for (const itemRef of items) {
            setStatus(`Processing ${itemRef.name}...`);
            const url = await getDownloadURL(itemRef);
            const cacheBustUrl = url.includes('?') ? `${url}&_ts=${new Date().getTime()}` : `${url}?_ts=${new Date().getTime()}`;

            const response = await fetch(cacheBustUrl, { cache: 'no-store' });
            const blob = await response.blob();
            
            if (cat.id === 'object_zip') {
                const tempZip = new JSZip();
                await tempZip.loadAsync(blob);
                
                for (const relativePath in tempZip.files) {
                    const zipEntry = tempZip.files[relativePath];
                    if (zipEntry.dir || relativePath.includes('__MACOSX')) continue;
                    
                    const entryName = relativePath.split('/').pop();
                    let exactName = entryName;
                    const lowerName = entryName.toLowerCase();
                    const nameNoExt = lowerName.includes('.') ? lowerName.substring(0, lowerName.lastIndexOf('.')) : lowerName;
                    const normName = normalizeStr(entryName);
                    const normNoExt = normalizeStr(nameNoExt);
                    
                    let mappedKey = null;
                    if (assetMap[exactName]) {
                        mappedKey = assetMap[exactName];
                    } else if (assetMap[lowerName]) {
                        mappedKey = assetMap[lowerName];
                    } else if (assetMap[nameNoExt]) {
                        mappedKey = assetMap[nameNoExt];
                    } else if (assetMap[normName]) {
                        mappedKey = assetMap[normName];
                    } else if (assetMap[normNoExt]) {
                        mappedKey = assetMap[normNoExt];
                    }
                    
                    if (mappedKey) {
                        const entryBlob = await zipEntry.async('blob');
                        zip.file(`files/${mappedKey}`, entryBlob);
                    }
                }
                
                processedFiles++;
                if (totalFiles > 0) {
                   const percentComplete = 20 + ((processedFiles / totalFiles) * 65);
                   progressBar.style.width = `${percentComplete}%`;
                }
                continue; 
            }

            let searchName = itemRef.name;
            if (cat.folder === 'models' && itemRef.name === '2') {
                searchName = 'WorldController.js';
            } else if (cat.folder === 'models' && itemRef.name === '23') {
                searchName = 'document.html';
            }

            let possibleMatches = zipPaths.filter(p => 
                !p.includes('__MACOSX') && 
                !p.split('/').some(part => part.startsWith('.')) && 
                (p.toLowerCase() === searchName.toLowerCase() || p.toLowerCase().endsWith('/' + searchName.toLowerCase()))
            );
            
            possibleMatches.sort((a,b) => a.length - b.length);
            const match = possibleMatches.length > 0 ? possibleMatches[0] : null;

            if (match) {
               zip.remove(match);
            }
            
            if (cat.id === 'json' || itemRef.name.toLowerCase().endsWith('.json')) {
               const jsonPath = match ? match : `json/${itemRef.name}`;
               zip.file(jsonPath, blob);

                } else {
               let finalFileName = itemRef.name;
               let exactName = finalFileName;
               let lowerName = finalFileName.toLowerCase();
               
                if (finalFileName !== '2' && finalFileName !== '23') {
                   const nameNoExt = lowerName.includes('.') ? lowerName.substring(0, lowerName.lastIndexOf('.')) : lowerName;
                   const normName = normalizeStr(finalFileName);
                   const normNoExt = normalizeStr(nameNoExt);

                   if (assetMap[exactName]) {
                       finalFileName = assetMap[exactName];
                   } else if (assetMap[lowerName]) {
                       finalFileName = assetMap[lowerName];
                   } else if (assetMap[nameNoExt]) {
                       finalFileName = assetMap[nameNoExt];
                   } else if (assetMap[normName]) {
                       finalFileName = assetMap[normName];
                   } else if (assetMap[normNoExt]) {
                       finalFileName = assetMap[normNoExt];
                   }
               }
               
               zip.file(`files/${finalFileName}`, blob);
            }

            processedFiles++;
            if (totalFiles > 0) {
               const percentComplete = 20 + ((processedFiles / totalFiles) * 65);
               progressBar.style.width = `${percentComplete}%`;
            }
          }
        }
        
        progressBar.style.width = '90%';
        setStatus(`Compiling final Game ZIP...`);
        
        const finalZipBlob = await zip.generateAsync({ type: "blob", compression: "STORE" });
        
        progressBar.style.width = '100%';
        setStatus(`Game Zip Generated Successfully! Downloading...`);

        const downloadUrl = URL.createObjectURL(finalZipBlob);
        const a = document.createElement('a');
        a.href = downloadUrl;
        a.download = `${currentProject}_Custom_Build.zip`;
        document.body.appendChild(a);
        a.click();
        
        document.body.removeChild(a);
        URL.revokeObjectURL(downloadUrl);

      } catch (error) {
        console.error("Zip generation error:", error);
        setStatus(`Error generating zip. Check console.`);
        progressBar.style.backgroundColor = 'var(--danger)';
      } finally {
        generateGameBtn.disabled = false;
        generateGameBtn.textContent = "Generate Game Zip"; 
        
        setTimeout(() => {
           progressContainer.style.display = 'none';
           progressBar.style.width = '0%';
           progressBar.style.backgroundColor = 'var(--accent)';
        }, 3000);
      }
    });

    window.addEventListener('DOMContentLoaded', () => {
      loadProjects();
    });
  </script>
  
  <div id="imagePreviewModal" class="image-preview-modal">
      <div class="image-preview-content">
          <button class="close-preview" id="closePreviewBtn">‚úï</button>
          <img id="previewImageSrc" src="" alt="Preview">
      </div>
  </div>

  <div id="modelProcessingModal" class="processing-modal">
      <div class="processing-content">
          <h2 style="color: #fff; font-size: 18px;">Pre-process 3D Models?</h2>
          <p style="font-size: 13px; color: var(--muted); margin-top: -10px; line-height: 1.4;">
              We detected 3D models in your project. Would you like to automatically center their pivot points (bottom-center) before sending context to the AI? This fixes scaling and floor-clipping issues.
          </p>
          
          <div class="model-list-container" id="modalModelList">
              </div>

          <div class="proc-progress-container" id="procProgressContainer">
              <div style="font-size: 12px; color: var(--success);" id="procCurrentFile">Preparing...</div>
              <div class="proc-progress-track"><div class="proc-progress-fill" id="procProgressFill"></div></div>
              <div class="proc-status-text" id="procStatusText">0 / 0 Completed</div>
          </div>

          <div class="row" style="justify-content: flex-end; margin-top: 10px;" id="procActionButtons">
              <button class="btn" id="skipProcessingBtn">Skip & Continue to AI</button>
              <button class="btn btnPrimary" id="startProcessingBtn">Process Selected</button>
          </div>
      </div>
  </div>
</body>
</html>